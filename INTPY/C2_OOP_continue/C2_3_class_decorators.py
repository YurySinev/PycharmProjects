#
# C2.3. Декораторы класса: @property, @classmethod.
# Ещё пару слов о нашей бывшей возлюбленной — инкапсуляции
#
# В данном юните мы рассмотрим встроенные средства языка Python для реализации
# вычисляемых свойств, ещё немножко поговорим про ООП в контексте инкапсуляции,
# научимся грамотно прописывать геттеры и сеттеры.
#
# Итак, будем идти по порядку.
#
# Для начала небольшое напоминание тем, кто подзабыл, что такое инкапсуляция.
#
# Инкапсуляция — это одна из основ объектно-ориентированного программирования,
# которая говорит нам о том, что поля (переменные) класса и его методы
# (функции класса) надо объединять в одну целую систему.
#
# Дальше, будьте уверены, вы вспомните про это по мере прочтения материала.
#
# Затрагивая тему инкапсуляции, почти во всех учебниках толком ничего
# не говорится о прекрасном встроенном декораторе @property.
#
# Напоминаю, что декораторы — это определённые штуки в языке Python, которые
# позволяют менять поведение функции (или, как вы сейчас убедитесь, и метода),
# не меняя её исходного кода. В прошлом юните мы с помощью декоратора писали
# статические методы, вспоминаем.
#
# @property очень классный декоратор, он-то, по сути, и обеспечивает нам
# прямой путь к инкапсуляции, позволяя объединить методы и поля. Давайте же
# скорее взглянем на пример кода с использованием этого декоратора.

# создадим класс собаки
class Dog:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    # создадим свойство human_age, которое будет переводить возраст животного в человеческий
    @property  # тот самый магический декоратор
    def human_age(self):
        return self.age * 7.3


jane = Dog("jane", 4)
# т.к. метод помечен декоратором property, то нам не надо вызывать этот метод, чтобы получить результат
print(jane.human_age)


# В этом куске кода мы пометили декоратором @property метод human_age. В итоге
# мы смогли получить результат работы метода, не вызывая его явно (без декоратора
# нам бы пришлось дописать в конец его вызов). Как правило, на этом объяснение
# этого потрясающего декоратора и заканчивается, а очень даже зря. Ведь помимо
# неявного вызова метода, мы можем похожим образом устанавливать значение в поле.
# Давайте же дополним наш код ещё одним свойством — шкалой счастья.
#
# Для этого поля мы создадим геттер и сеттер. Из темы инкапсуляция (модуль C1)
# вы должны помнить, что:
#         геттеры — это специальные методы для получения значения поля класса;
#         сеттеры — это специальные методы для установки значений в поле класса.

class Dog:
    _happiness = 10

    def __init__(self, name, age):
        self.name = name
        self.age = age

    @property
    def human_age(self):
        return self.age * 7.3

    # добавим новое поле — шкала счастья
    @property
    def happiness(self):
        return self._happiness

    # с помощью декоратора setter мы можем неявно передать во второй
    # аргумент значение, находящееся справа от равно, а не закидывать это
    # значение в скобки, как мы это делали в модуле C1, когда не знали о
    # декораторах класса
    @happiness.setter
    # допустим, мы хотим, чтобы счастье питомца измерялось шкалой от 0 до 100
    def happiness(self, value):
        if value <= 100 and value >= 0:
            self._happiness = value
        else:
            raise ValueError("Happiness must be between 0 ... 100")


jane = Dog("jane", 4)
jane.happiness = 100  # осчастливим нашу собаку < :
print(jane.happiness)


# В этом случае программа выведет нам на экран поле happiness, т. е. 100.
#
# Вдобавок к комментариям в коде важно отметить, что декораторы .setter должны
# называться так же, как и метод, помеченный декоратором @property, для которого
# вы хотите устанавливать значение, иначе интерпретатор выдаст ошибку.
#
# Благодаря декоратору @.setter можно использовать инкапсуляцию, сохраняя привычное
# нам обращение к полю через точку, а установку нового значения через =. Вот такой
# вот магический декоратор @property.
#
# Ну и напоследок стоит сказать пару слов о декораторе @classmethod, который встречается
# довольно редко, ввиду его малой понятности для обывателей и синтаксической громоздкости.
#
# Используется он, как правило, чтобы открыть путь в полиморфизм (вспоминаем модуль C1,
# но если кратко — полиморфизм это разное поведение методов класса-родителя в классах-наследниках).
#
# Смотрим код:

class ParentClass:

    @classmethod
    def method(cls, arg):
        print("%s classmethod. %d" % (cls.__name__, arg))

    @classmethod
    def call_original_method(cls):
        cls.method(5)

    def call_class_method(self):
        self.method(10)


class ChildClass(ParentClass):

    @classmethod
    def call_original_method(cls):
        cls.method(6)


# Вызываем методы класса через класс.
ParentClass.method(0)  # ParentClassclassmethod. 0
ParentClass.call_original_method()  # ParentClassclassmethod. 5

ChildClass.method(0)  # ChildClassclassmethod. 0
ChildClass.call_original_method()  # ChildClassclassmethod. 6

# Вызываем методы класса через объект.
my_obj = ParentClass()
my_obj.method(1)  # ParentClassclassmethod. 1
my_obj.call_class_method()  # ParentClassclassmethod. 10


# Задание 2.3.4
# Создать вычисляемое свойство для класса Square. Сделайте метод по вычислению площади
# свойством. Сделайте сторону квадрата свойством, которое можно установить только через
# сеттер. В сеттере добавьте проверку условия, что сторона должна быть неотрицательной.

# ( см. square_properties.py )
from square_properties import Square



