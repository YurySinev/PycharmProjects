from divide_line import line
line("«Синтаксический сахар»")
#
# Декораторы — настолько часто используемая конструкция в Python, что её оформили
# в качестве «синтаксического сахара».
# Синтаксический сахар в языке программирования — это синтаксические возможности,
# применение которых не влияет на поведение программы, но делает использование языка
# более удобным для человека.
#
# Пользоваться им можно так:
#
# @my_decorator
# def my_function():
#     pass
#
# При этом будет происходить всё то же самое, аналогичное.
#
# my_function = my_decorator(my_function)
#
# Имейте в виду, что при использовании синтаксического сахара на месте
# декорируемой функции появляется задекориванная функция!


def my_decorator(fn):
   def wrapper():
       fn()
   return wrapper  # возвращается задекорированная функция, которая заменяет исходную

# выведем незадекорированную функцию
def my_function():
   pass
print(my_function)  # <function my_function at 0x7f938401ba60>

# выведем задекорированную функцию
@my_decorator
def my_function():
   pass
print(my_function)  # <function my_decorator.<locals>.wrapper at 0x7f93837059d8>

# Видим, что после декорирования, под названием исходной функции будет не сама функция,
# а функция, которая была внутри декоратора, в данном случае функция wrapper.

line()
#
line("Передача аргументов в декорируемую функцию")

# До этого мы с вами декорировали только функции без аргументов. Но что будет,
# если мы попытаемся задекорировать функцию с аргументами?

# def do_it_twice(func):
#     def wrapper():
#         func(arg)
#         func(arg)
#     return wrapper
#
# @do_it_twice
# def say_word(word):
#     print(word)
#
# say_word("Oo!!!")
#
# При выполнении данного кода будет выведена такая ошибка:
# TypeError: wrapper() takes 0 positional arguments but 1 was given
#
# Связана она с тем, что задекорированная функция wrapper не принимает ни одного
# аргумента в отличие от исходной. А именно задекорированная функция теперь скрывается
# за именем переменной say_word. И каждый следующий вызов say_word – это вызов wrapper.
# Следовательно, wrapper должен уметь принимать те же аргументы, что и исходная функция
# и передавать их в неё. Чтобы не задумываться над количеством аргументов и сделать наш
# декоратор универсальным, мы будем использовать *args и **kwargs.

# декоратор, в котором встроенная функция умеет принимать аргументы
def do_it_twice(func):
   def wrapper(*args, **kwargs):
       func(*args, **kwargs)
       func(*args, **kwargs)
   return wrapper

@do_it_twice
def say_word(word):
   print(word)

say_word("Oo!!!")
# Oo!!!
# Oo!!!

# Подведём итог по декораторам:
#
#         Декораторы добавляют дополнительное поведение функции без изменения её исходного кода.
#         Декораторы —  вызовы дополнительных функций, поэтому они немного замедляют ваш код.
#         Для передачи аргументов декорируемой функции используйте *args и **kwargs.

line("Вот универсальный шаблон для декоратора:")
print(\
    """
def my_decorator(fn):
    print("Этот код будет выведен один раз в момент декорирования функции")
    def wrapper(*args, **kwargs):
        print('Этот код будет выполняться перед каждым вызовом функции')
        result = fn(*args, **kwargs)
        print('Этот код будет выполняться после каждого вызова функции')
        return result
    return wrapper
""")
