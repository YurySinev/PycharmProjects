# Функции-генераторы.

# Предположим, что нам понадобилась бесконечная числовая последовательность натуральных чисел.
# Мы можем попробовать сделать бесконечный цикл while, который будет возвращать нам числа, но
# рано или поздно оперативная память компьютера закончится, и он зависнет. Плюс она нам не
# нужна вся сразу, а нужно только текущее число.
#
# Такую проблему призваны решить функции-генераторы. Их задача выполнять те действия, которые
# прописаны в теле функции-генератора, дальше уходить в «спячку» и ждать следующего вашего обращения.
#
# Такой процесс выполнения называют ещё «ленивыми вычислениями», то есть вычислениями только
# в момент обращения, а не всего сразу, как это делают обычные функции.
#
# Синтаксис функций-генераторов отличается от обычных функции только оператором yield, он
# используется вместо оператора return. В обычной функции, когда интерпретатор встречает в теле
# функции оператор return, то он выходит из тела функции и возвращается к основной программе.
# Встречая же yield, он понимает, что функцию-генератор закрывать не нужно, а нужно приостановить
# и затем вернуться к ней.
#
# Прежде мы с вами писали рекурсивную функцию, которая вычисляет числа Фибоначчи. Мы же сейчас
# с вами реализуем бесконечную последовательность чисел Фибоначчи, при этом она будет эффективной,
# потому что для вычисления каждого следующего числа нам нужно будет хранить в памяти лишь
# два предыдущих значения.

# Новый вариант подсчета чисел Фибоначчи:

def fib():
    a, b = 0, 1
    yield a
    yield b

    while True:
        if a > 1000:
            break
        a, b = b, a + b
        yield b

# num = 2
for num in fib():
    print(num)

# в чем прикол, пока не усек...
