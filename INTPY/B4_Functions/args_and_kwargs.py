from divide_line import line
print("Запакованные переменные, или что такое *args и **kwargs")
# До этого мы рассматривали функции со строго определённым количеством переменных.
# Проектируя вашу программу, хорошо бы сразу знать, с чем вы будете работать. Но,
# к сожалению, не всегда это возможно. Как же тогда быть?
#
# Для начала давайте разберёмся с позиционными (positional) и именованными (keyword) аргументами.
# Из названий можно предположить, что одни аргументы зависят от позиции, а вторые от имени, всё логично.
#
# Но давайте рассмотрим практический пример:

def func(a, b, c):
   print('a =', a)
   print('b =', b)
   print('c =', c)

func(1, 2, 3)
# a = 1
# b = 2
# c = 3

func(3, 2, c=5)
# a = 3
# b = 2
# c = 1
# Видим, что в зависимости от того, в каком порядке мы передаём значения в функцию func,
# аргументы a, b, c принимают различные значения. В этом и есть суть позиционных аргументов.
line()
# Но никто не запрещает нам обращаться к переменным прямо по имени:
func(a=1, b=2, c=3)
# a = 1
# b = 2
# c = 3

func(c=3, b=2, a=1)
# a = 1
# b = 2
# c = 3

line()
# Важная особенность:
# все именованные аргументы должны идти строго после позиционных,
# как при объявлении функций, так и при их вызове.
print("""# Правильно
func(a, b, c=3)

Неправильно
func(a=1, b, c) SyntaxError: positional argument follows keyword argument""")
line()

# Оператор * чаще всего ассоциируется с операцией умножения, но в Python он имеет и другой смысл.
# Этот оператор позволяет «распаковывать» (получить все значения из какой-либо последовательности,
# а не саму последовательность) объекты (например, списки или кортежи), внутри которых хранятся
# некие элементы. Не используя оператор распаковки, если мы захотим поместить список а в список b,
# мы просто укажем его в качестве одного из элементов нового списка. Но если мы захотим добавить
# именно значение из первого списка, а не сам список. То как раз оператор распаковки сделает это,
# то есть он вытащит из нашего списка все значения.

a = [1, 2, 3]
b = [a, 4, 5, 6]
print(b)
# [[1, 2, 3], 4, 5, 6]

a = [1, 2, 3]
b = [*a, 4, 5, 6]
print(b)
# [1, 2, 3, 4, 5, 6]

# То есть оператор распаковки позволяет работать со значением последовательности,
# а не с самой последовательностью. В первом случае функция print печатает список,
# а во втором — все значения списка:
print(a)
print(b)
print(*b)
# 1 2 3 4 5 6

line('Чтобы правильно обрабатывать *args и **kwargs')
line('нужно представлять, чем они являются:')
line('args — это кортеж, kwargs  — это словарь')
# Вернёмся к аргументам функций, их существует два вида:
#         позиционные,
#         именованные.
#
# Чтобы функция могла принимать неограниченное количество позиционных аргументов,
# есть специальная конструкция *args, а для именованных аргументов **kwargs.
# Аrgs и kwargs не являются зарезервированными словами, это просто общее обозначение,
# args — это сокращение от «arguments» (аргументы), а kwargs — сокращение от «keyword arguments»
# (именованные аргументы). Важно, что они должны начинаться с одной и двух звёздочек соответственно.
# Каждая из этих конструкций используется для распаковки аргументов соответствующего типа,
# позволяя вызывать функции со списком аргументов переменной длины, как в случае функции print.
#
# Чтобы правильно обрабатывать *args и **kwargs нужно представлять, чем они являются.
# А собственно args — это кортеж, а kwargs  — это словарь.

def my_func(*args, **kwargs):
   print(type(args))
   print(type(kwargs))

my_func()
# <class 'tuple'>
# <class 'dict'>

line()
# Давайте рассмотрим задачку и сделаем функцию-сумматор, которая будет складывать
# любое количество переданных ей аргументов.
def adder(*nums):
    sum_ = 0
    for n in nums:
        sum_ += n

    return sum_


print(adder())  # 0
print(adder(1))  # 1
print(adder(1, 2))  # 3
print(adder(1, 2, 3, 12, 65))  # 6
