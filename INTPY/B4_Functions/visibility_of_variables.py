from divide_line import line
line('глобальные и локальные переменные')
# Имена, определяемые внутри инструкции def, не вступают в конфликт с именами,
# находящимися за пределами инструкции def, даже если и там, и там
# присутствуют одинаковые имена переменных.

def local():
   x = 5  # локальная переменная
   print(x)

x = 10
local()
print(x)

# 5
# 10
line('глобальная область видимости')
# Глобальная область видимости
# Рассмотрим следующий пример:

def local():
  print(x)  # так как x нет в локальной области видимости, мы берем её из глобальной области

x = 10
local()
print(x)
# 10
# 10

# не найдя переменной в локальной области, функция обращается к глобальной области видимости,
# которая находится на уровне модуля, и берёт значение оттуда. И здесь не нарушается
# так называемое «правило бункера». Из бункера мы можем увидеть, что происходит во внешнем мире,
# но вот наоборот это не работает.
line()

# Задание 4.3.1 # Задание на самопроверку.
# Укажите, что будет выведено в результате выполнения данной программы.

x = 3
def function():
    print(x)
    return x

print(function())
# 3
# 3

line()
print("Закомментировано")
# Попробуйте самостоятельно предугадать, что будет напечатано в результате
# выполнения данного кода, не смотря на ответ, который будет дан дальше.
#
# x = 3
#
#
# def func():
#    print(x)
#    x = 5
#    x += 5
#    return x
#
#
# print(func())

# line 55, in func
#     print(x)
# UnboundLocalError: local variable 'x' referenced before assignment
#
# Ошибка возникает, потому что Python замечает, что вы пытаетесь распечатать значение
# локальной (!) переменной х в функции func до её объявления, что и приводит к ошибке,
# так как х ещё не определён.
line('пример с global')
# Как обойти это ограничение? Нужно использовать оператор global, который объявляет переменную
# доступной для блока кода, следующим за оператором. Давайте попробуем использовать глобальную
# область видимости для исправления нашей ошибки из предыдущего примера:

x = 3

def func():
   global x # объявляем, что переменная является глобальной
   print(x)
   x = 5
   x += 5
   return x

func()
print(x)

# Хотим обратить ваше внимание на то, что не нужно менять глобальные переменные внутри функции.
# Комьюнити Python объявило такую практику очень нежелательной, так как из-за этого
# исправление кода становится намного сложнее.
line('нелокальная область видимости')

# Нелокальная область видимости
#
# Появилось это понятие в Python 3 вместе с ключевым словом nonlocal. Логика его написания примерно такая же,
# как и у global. Но у nonlocal есть особенность. Nonlocal используется чаще всего во вложенных функциях,
# когда мы хотим дать интерпретатору понять, что для вложенной функции определённая переменная
# не является локальной, но она и не является глобальной в общем смысле.
# Пример:
def get_my_func():
   def hello_world():
       print("Hello")
   return hello_world

hello_world_func = get_my_func()  # получить функцию в качестве результата

print(type(hello_world_func))  # <class 'function'>
hello_world_func()  # Hello
#
line('Nonlocal и замыкание фукций')
line('Использование переменных объявленных вне функции называется замыканием функций')
# Мы можем прямо внутри функции указать ещё одно объявление функции, и при вызове внешней функции
# она будет возвращать каждый раз новую функцию. Здесь возвращаемая функция всегда статична.
# Это не очень интересно, поэтому давайте рассмотрим пример, в котором будут возвращаться различные функции.
# Функция нам будет создавать функции, которые будут умножать на какое-то фиксированное число.

def get_mul_func(m):
   nonlocal_m = m
   def local_mul(n):
      return n * nonlocal_m

   return local_mul


two_mul = get_mul_func(2)  # возвращаем функцию, которая будет умножать числа на 2
print(two_mul(5))  # 5 * 2

# Переменная nonlocal_m по отношению к функции local_mul находится в некоем промежуточном состоянии.
# Она и не глобальная, потому что объявлена не на уровне скрипта, но и не локальная по отношению
# к функции local_mul. Использование переменных объявленных вне функции называется замыканием функций.
line('конец')
