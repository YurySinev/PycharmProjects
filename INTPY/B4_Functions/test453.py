# Задание 4.5.3 # Задание на самопроверку.
#
# Напишите декоратор, который будет сохранять результаты выполнения декорируемой функции
# в словаре. Словарь должен находиться в nonlocal области в следующем формате:
# по ключу располагается аргумент функции, по значению — результат работы функции, например, {n: f(n)}.
#
# И при повторном вызове функции декоратор будет брать значение из словаря, а не вычислять заново.
# То есть словарь можно считать промежуточной памятью на время работы программы, где будут храниться
# ранее вычисленные значения. Исходная функция, которую нужно задекорировать имеет следующий вид
# и выполняет простое умножение на число 123456789:
#       def f(n):
#           return n * 123456789

def my_decorator(fn): # эта функция тут вообще ни к чему, не используется
    print("Этот код будет выведен один раз в момент декорирования функции")
    def wrapper(*args, **kwargs):
        print('Этот код будет выполняться перед каждым вызовом функции')
        result = fn(*args, **kwargs)
        print('Этот код будет выполняться после каждого вызова функции')
        return result
    return wrapper

def cache(func):    # вот эта функция-декоратор участвует в решении задачи
   cache_dict = {}
   def wrapper(num):
       nonlocal cache_dict
       if num not in cache_dict:
           cache_dict[num] = func(num)
           print(f"Добавление результата в кэш: {cache_dict[num]}")
       else:
           print(f"Возвращение результата из кэша: {cache_dict[num]}")
       print(f"Кэш {cache_dict}")
       return cache_dict[num]
   return wrapper

@cache
def f(n):
   return n * 123456789

f(9)
f(2)
f(8)
f(2)
f(7)
f(8)


