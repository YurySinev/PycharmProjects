from

print('Декораторы:')
# Декораторы предназначены для подключения любого дополнительного поведения к основной функции,
# называемой декорируемой функцией, которое может выполняться до, после или даже вместо основной функции.
# При этом исходный код декорируемой функции никак не затрагивается.
#
# В качестве дополнительного поведения может выступать подсчёт времени выполнения функции, проверка
# дополнительных условий, разрешающих выполнение указанной функции.

# Давайте посмотрим на примере, как добавить дополнительное поведение к основной функции.
def my_decorator(a_function_to_decorate):
    # Здесь мы определяем новую функцию - «обёртку». Она нам нужна, чтобы выполнять
    # каждый раз при вызове оригинальной функции, а не только один раз
    def wrapper():
        # здесь поместим код, который будет выполняться до вызова, потом вызов
        # оригинальной функции, потом код после вызова
        print("Я буду выполнен до основного вызова!")

        result = a_function_to_decorate()  # не забываем вернуть значение исходной функции

        print("Я буду выполнен после основного вызова!")
        return result

    return wrapper

def my_function():
   print("Я - оборачиваемая функция!")
   return 0

print(my_function())
# Я - оборачиваемая функция!
# 0

decorated_function = my_decorator(my_function)  # декорирование функции
print(decorated_function())
# Я буду выполнен до основного вызова!

# Я - оборачиваемая функция!
# Я буду выполнен после основного вызова!
# 0

u_line()
# Видим, что задекорировав my_function, мы добавили к ней новый функционал, не меняя исходный код самой функции.
#
# Зачем это нужно? Например, декораторы могут замерять время выполнения функции либо количество запусков
# конкретной функции, также можно сохранять результаты вычисления (кеширование).
#
# Давайте попробуем замерить время выполнения системной функции для возведения числа в степень 2
# и соответствующего оператора.
#
import time

def decorator_time(fn):
   def wrapper():
       print(f"Запустилась функция {fn}")
       t0 = time.time()
       result = fn()
       dt = time.time() - t0
       print(f"Функция выполнилась. Время: {dt:.10f}")
       return dt  # задекорированная функция будет возвращать время работы
   return wrapper

def pow_2():
   return 10000000 ** 2


def in_build_pow():
   return pow(10000000, 2)


pow_2 = decorator_time(pow_2)
in_build_pow = decorator_time(in_build_pow)

pow_2()
# Запустилась функция <function pow_2 at 0x7f938401b158>
# Функция выполнилась. Время: 0.0000011921

in_build_pow()
# Запустилась функция <function in_build_pow at 0x7f938401b620>
# Функция выполнилась. Время: 0.0000021458
u_line()
# Задание 4.5.1 Задание на самопроверку.
#
# Взять из предыдущего примера декорированные функции, которые возвращают время работы
# основной функции, и найти среднее время выполнения для 100 выполнений каждой функции.

import time

N = 100


def decorator_time(fn):
   def wrapper():
       t0 = time.time()
       result = fn()
       dt = time.time() - t0
       return dt
   return wrapper


def pow_2():
   return 10000000 ** 2


def in_build_pow():
   return pow(10000000, 2)


pow_2 = decorator_time(pow_2)
in_build_pow = decorator_time(in_build_pow)

mean_pow_2 = 0
mean_in_build_pow = 0
for _ in range(N):
   mean_pow_2 += pow_2()
   mean_in_build_pow += in_build_pow()

print(f"Функция {pow_2} выполнялась {N} раз. Среднее время: {mean_pow_2 / N:.10f}")
print(f"Функция {in_build_pow} выполнялась {N} раз. Среднее время: {mean_in_build_pow / N:.10f}")

u_line()

print('Синтаксический сахар:')
# «Синтаксический сахар»
#
# Декораторы — настолько часто используемая конструкция в Python, что её оформили
# в качестве «синтаксического сахара».
# Синтаксический сахар в языке программирования — это синтаксические возможности,
# применение которых не влияет на поведение программы, но делает использование
# языка более удобным для человека.
def my_decorator(fn):
   def wrapper():
       fn()
   return wrapper  # возвращается задекорированная функция, которая заменяет исходную

# выведем незадекорированную функцию
def my_function():
   pass
print(my_function)  # <function my_function at 0x7f938401ba60>

# выведем задекорированную функцию
@my_decorator
def my_function():
   pass
print(my_function)  # <function my_decorator.<locals>.wrapper at 0x7f93837059d8>