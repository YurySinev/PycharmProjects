#
# C3.3. Работа с импортом
#
# При решении задачи может возникнуть две мысли: либо написать решение с нуля,
# либо воспользоваться уже готовыми решениями и адаптировать их под себя.
# Оба пути имеют место быть. Чаще всего новички пытаются писать что-либо
# самостоятельно, даже не предполагая, что для их задач уже есть готовые
# решения. Во-первых, это занимает много времени, во-вторых, вы не всегда
# сможете написать оптимальное решение, которое к тому же может работать
# неправильно на некоторых тестах.
#
# Когда вы в дальнейшем начнёте заниматься серьёзными проектами, допустим,
# на работе, то следует выбирать правильные инструменты для конкретных задач,
# да плюс ко всему желательно, чтобы они работали без ошибок. Поэтому можно
# использовать решения, которые были написаны профессионалами, ваша задача их
# правильно применить, при этом не стреляя из пушки по воробьям. Возможно, у
# вас есть какая-то своя заготовка кода, решающая какую-то локальную задачу,
# которая очень часто повторяется в вашей работе, и чтобы снова её не переписывать,
# вы можете выделить её в отдельную программу (модуль) и импортировать один и тот
# же модуль в нужный вам момент.
#
# Для чего это нужно:
#
#         1. Уменьшить объём кода путём его переиспользования. Исходники хранятся
#         в одном месте, а вы просто их импортируете (подгружаете) и используете
#         функционал данного модуля без переноса самих исходников. Также просто
#         исправлять ошибки. Вам не нужно искать, где использовался этот код.
#         Исправляете в одном месте, в остальных программах после их перезапуска
#         будет обновлённая версия.
#
#         2. Это способ структурировать ваш код. Плохая структура — много ошибок.
#         Когда всё находится «по своим полочкам», проще отыскать нужный момент,
#         и вы интуитивно будете знать, где его искать. Даже если будете работать
#         с чужим кодом, если он составлен с соблюдением общепринятых рекомендаций.
#
#         3. Использование уже готовых реализаций.


# Как импортировать модуль
#
# Импорт происходит с помощью зарезервированного слова import название модуля.

import os
import sys

# После импорта модуля в вашей программе становятся доступны все возможности
# импортированного модуля: его глобальные переменные, функции и прочее. Например,
# импортировав модуль os из стандартной библиотеки, вы можете узнать текущую
# директорию и список её файлов. Для того чтобы обратиться к содержимому модуля,
# нужно после его имени поставить точку и указать нужный вам элемент.

# import os

print(os.getcwd())  # получить текущую директорию
print(os.listdir())  # получить список файлов текущей директории

# Если вы работаете в IDE, то после нажатия на точку вам будет предложено, что
# можно вызвать из указанного модуля.

# Как узнать, что умеет тот или иной модуль? Если это сторонний модуль, который
# вы скачали с помощью менеджера пакетов, например, pip, или он из стандартной
# библиотеки, то можно найти документацию на него в сети интернет, благо Python
# славится подробной документацией. Как быть, если нет доступа в интернет? Для
# того чтобы получить документацию на тот или иной модуль, можно воспользоваться
# командой help.

# import os
# help(os)

# После этого в консоли будет выведена информация о взаимодействии с модулем. Своего
# рода шпаргалка, заранее составленная разработчиками модуля. Если вы не знаете или
# забыли какой-то функционал модуля — можете смело подглядывать туда. В отличие от
# функции dir, здесь вы также можете посмотреть и подсказки, а не только атрибуты модуля.
#
# Python очень серьёзно относится к качеству кода, поэтому давайте разберем, как следует
# импортировать модули. Мы сейчас смотрим не столько на синтаксические ошибки, сколько
# на вопросы связанные со стилем кода (см. PEP8). Не следует импортировать модули
# в одну строку, каждый отдельный модуль должен быть импортирован на отдельной строке:

# # правильно
# import os
# import sys
#
# # неправильно
# import os, sys

# Но если вы хотите импортировать, например, несколько функций из одного модуля, можно
# перечислить их через запятую:

from subprocess import Popen, PIPE

# Также для импорта существует несколько различных способов записи, но делают они
# то же самое — импорт всего модуля и обращение к функции через имя модуля:

import math

print(math.pi)  # 3.141592653589793

# Импортируем всё из модуля, это позволяет сократить запись и обращаться к функциям,
# не указывая имя модуля:
#
from math import *  # импортируем всё из модуля math

print(pi)  # 3.141592653589793

# Даём новое имя модулю, это позволяет избежать ошибок, если у вас есть функция,
# которая называется так же, как модуль, то вы можете дать новое имя модулю
# для данного скрипта:
#
import math as m  # использование нового имени для обращения к импортированному модулю

print(m.pi)  # 3.141592653589793

# Даём новое имя функции или переменной, это позволяет избежать ошибок, если у
# вас есть одноимённая функция в вашей программе, и вы не хотите её переименовать:
#
from math import pi as PI

print(PI)  # 3.141592653589793
#
# Единственно правильного решения нет. Нужно исходить из конкретной задачи и того,
# что используется в коде. Использование новых имён позволяет уменьшить размер кода
# и повысить его читабельность. А импорт отдельных элементов позволяет не захламлять
# возможные варианты, которые может выдать IDE.


# Как правильно составить модуль?

# Для того чтобы в модулях можно было легко найти нужные строки,
# принято их формировать стандартным образом.
#
# Для этого были сформированы следующие правила.
#
# 1 Вся основная логика модуля заключена в отдельные функции или классы.
# На глобальном уровне могут быть объявлены только константы или
# необходимые для инициализации модуля операции.
#   (иллюстрация)
# Слева представлен плохой пример, потому что в нём содержатся лишние
# функции print() в 3 и 11 строках. А также объявлена неконстантная
# переменная t, которая проверяет работу функции a в 11 строке.
# Справа представлен правильный вариант.
#
# 2 Если вы планируете, что модуль будут запускать как самостоятельный
# скрипт – используйте следующую инструкцию: if __name__ == '__main__':.
#
# Как правило, в блок if __name__ == '__main__' заносят все вызовы функций
# и вывод информации на стандартный поток вывода. Ещё один вариант — создать
# отдельную main() функцию, переписав в неё всю логику при запуске,
# и вызывать её в данном блоке.
#
# Как это работает? Ваш скрипт может выполняться и самостоятельно, а может быть
# импортирован как модуль другим скриптом. Чтобы выделить код, который не должен
# выполняться при импорте его следует поместить в условный оператор
# с условием if __name__ == '__main__':.
#
# Каждый скрипт при запуске получает от интерпретатора имя, хранящееся в специальной
# переменной __name__, которая будет равна "__main__", только если файл запускается
# как основная программа, и выставляется равной имени модуля при импорте модуля.
# То есть условие if __name__ == '__main__' проверяет, был ли файл запущен напрямую.

# 3 Хорошая структура модуля выглядит следующим образом:

# 1. Docstring (описание) модуля.
# 2. Область импорта:
#     импорты системных библиотек;
#     импорты стандартных пакетов (из PyPI);
#     импорты ваших модулей (локальных).
# 3. Область объявления глобальных констант.
# 4. Инициализация модуля.
# 5. Область определения функций и классов.
# 6. Функции.
# 7. if __name__ == '__main__' (метод main) по желанию (это одни
#       из немногих нюансов при работе с собственными модулями).

# ( образец правильно составленного модуля: module_pattern.py )

# В строках 1-3 представлено описание того, что выполняет модуль, так называемый
# docstring. Строки 5-6 импортируют модули стандартной библиотеки. В 8 строке
# импортируется дополнительная библиотека requests, которая была установлена.
# 10 строка импортирует ваш собственноручно написанный модуль. Все три этих
# блока следует отделять пустой строкой, чтобы визуально разделить их.
#
# Далее идёт объявление констант — 12 строка. Следом идёт инициализация модуля —
# это функция, содержащая код, который будет выполняться при непосредственном
# запуске модуля. Делается это затем, что модуль может содержать большое
# количество вспомогательных функций. И чтобы не искать основную логику
# работы модуля по многочисленным строкам кода или прокрутки файла до
# блока if __name__ == '__main__':, который находиться в самом конце,
# её выносят в отдельную функцию и ставят на первое место. В примере
# это строки 15-17. Далее идёт область определения функций, классов,
# которые необходимы для работы с модулями,  — строки 20-24.
#
# И остался блок if __name__ == '__main__':, содержащий код, который не должен
# выполняться при импорте, а только при непосредственном запуске. И заканчиваться
# ваш скрипт должен пустой строкой — строка 29.

# Чтобы создать и импортировать собственный модуль, давайте создадим два модуля
# (скрипта). В первом будет объявлена функция, печатающая приветственное
# сообщение «Hello world». А вот вызовем эту функцию уже в другом файле,
# предварительно импортировав её.
#
# Но перед тем, как мы это сделаем, небольшое отступление.
# ВАЖНО: чтобы модули заработали правильно, их нужно хранить в той же папке,
# в которой вы запускаете главный скрипт, иначе Python не найдёт ваш модуль!
#
# Если же вы используете чужие библиотеки, скачанные напрямую через интернет,
# то их необходимо скопировать в папку с проектом. Однако, как правило, этого
# не требуется, если вы устанавливаете библиотеки через пакетный менеджер PIP.
# Если вам понравилась какая-то библиотека из интернета и вы хотите с ней работать,
# то просто напишите в терминале (на Windows в cmd) следующую строчку:
#
# pip install <имя вашей библиотеки>
#
# и она станет доступна для импорта из любого вашего проекта!

# А теперь давайте вернёмся к нашей задаче:
#
# function.py
#
# def hello():
#     print('Hello world')
#
# main.py
#
# from function import hello
#
# hello()  # вызвали импортированную функцию
#
# В данном случае у нас есть два файла function.py и main.py. В первом объявлена
# функция, а во втором мы уже непосредственно вызываем её выполнение.
#
# Иногда однако может случиться такая неприятная штука как кросс-импорт или же
# перекрёстный импорт. В таком случае обычно разбивают файл на ещё более мелкие
# составляющие или всевозможные пакеты. Однако если так сделать не получается по
# каким-либо причинам, то помочь может шаблон проектирования «Фабрика», который
# помогает избежать кросс-импорта даже в самых сложных ситуациях.
#
# О том, как применять его при написании ваших программ, можно посмотреть в этом скринкасте.
#
# Если вы хотите импортировать собственные модули в ваших проектах, при этом
# не закидывая их напрямую в папку с ними, или же вы надумали писать собственную
# библиотеку на Python и выложить её на общее пользование, то можете ознакомиться
# с инструкцией по написанию собственных библиотек в скринкасте о сложном импорте.

#  Задание 3.3.1
# Выберите пункты, правильно описывающие, для чего нужны модули.
#   Способ структурирования кода    # верно
#   Повторное использование кода    # верно
#   Увеличение объёма кода
#   Возможность пользоваться готовыми реализациями  # верно
#   Python не умеет работать с файлами, отличными от эталонной структуры модуля

# Задание 3.3.2
# Найдите в сторонних источниках информацию о модуле math и соотнесите функцию и её действие.
# округление до ближайшего большего числа       # math.ceil(X)
# округление до ближайшего большего числа       # math.ceil(X)
# модуль X                                      # math.fabs(X)
# округление вниз                               # math.floor(X)
# является ли X числом                          # math.isfinite(X)
# квадратный корень из X                        # math.sqrt(X)

# Задание 3.3.3
# Используя модуль math, найдите значение данного выражения:
#
import math

print(math.trunc(math.fmod(math.fabs(-10000000), 55) + 0.3))  # 10

#  Задание 3.3.4
# Найдите в сторонних источниках информацию о модуле time и ответьте на вопросы.
#
# Какая функция позволяет узнать время с начала эпохи, выраженное в секундах?   # time
#
# Какая функция позволяет преобразовать время, выраженное в секундах
#   с начала эпохи в строку вида «Thu Sep 27 16:42:37 2012»?                    # ctime
#
# Какая функция позволяет приостановить выполнение программы
#   на заданное количество секунд? Впишите только название, без скобочек ().    # sleep

#
# Задание 3.3.5
# Поэкспериментируйте с модулем time. Выведите в консоль текущее время,
# попробуйте вывести следующие данные:
#
#         только время;
#         только минуты;
#         только дату;
#         только месяц.
#
# Если возникнут трудности, пишите менторам!

#  Задание 3.3.6
# Программист Вася пытался написать программу, которая запускает таймер
# от 10 до 0 включительно, но что-то пошло не так. Укажите номера строк
# через запятую с пробелом в порядке возрастания, где Вася ошибся.

# 1 import time
# 2
# 3 i = 10
# 4 while i != 0:
# 5    print(i, flush=True)
# 6    sleep(1)
# 7    i -= 1
# 8    print("Время вышло!")

# На мой взгляд, Вася ошибся в строках 6 и 8, но мой ответ не принимается:
import time

i = 10
while i >= 0:  # вот она третья ошибка: i != 0 - см. условия задачи!
    print(i, flush=True)
    time.sleep(1)
    i -= 1
print("Время вышло!")

# Задание 3.3.7
# Вам нужно написать два модуля:
#
#         Первый должен содержать число Пи в виде константы 3.14, и две функции,
#               которые будут считать площадь круга и прямоугольника.
#         Второй модуль должен импортировать первый, далее запрашивать у пользователя
#               размеры круга и квадрата. В результате выводить, какая из фигур больше.
#
# Пример ответа

# PI = 3.14
#
# def circle_area(r):
#    return PI * (r ** 2)
#
#
# def rect_area(a, b):
#    return a * b
#
#
# if __name__ == '__main__':
#    # проверяем работоспособность функции, дальнейшая часть не будет импортирована
#    assert circle_area(5) == 78.5  # если ответы будут отличаться, то будет вызвана ошибка
#    assert rect_area(5, 4) == 20
#
# ################################
# from module_name import *
#
# def main():
# r = int(input('Введите радиус круга:\n'))
#
# a = int(input('Введите длину прямоугольника:\n'))
# b = int(input('Введите ширину прямоугольника:\n'))
# if circle_area(r) > rect_area(a, b):
# print('Площадь круга больше')
# else:
# print('Площадь прямоугольника больше')
#
# if name == 'main':
# main()
