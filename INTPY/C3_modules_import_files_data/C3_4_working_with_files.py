import os

# C3.4. Работа с файлами
#

# Путь к файлу

#
# Путь (англ. path) — набор символов, показывающий расположение файла или каталога в файловой системе.
#
# В операционных системах UNIX разделительным знаком при записи пути является «/», в Windows — «\».
# Эти знаки служат для разделения названия каталогов, составляющих путь к файлу. Все вы видели,
# например, такой путь на ОС Windows: C:\Program Files. Это и есть путь до папки Program Files.
#
# Существует два типа пути:
#
#         абсолютный,
#         относительный.
#
# Абсолютный путь всегда считается от «корня», той папки, откуда потом вырастают все остальные папки.
# Для Windows это диск С:, D: и т. д., для Unix это «/» (обратный слеш). Абсолютный путь всегда уникальный.
#
# Абсолютный путь — это путь, который указывает на одно и то же место в файловой системе, вне зависимости
# от текущего рабочего каталога или других обстоятельств. Его ещё называют полным.
#
# Относительный путь — это путь по отношению к текущему рабочему каталогу пользователя.
#
# Чтобы поработать с путями есть модуль os. Функция os.chdir() позволяет нам изменить директорию,
# которую мы в данный момент используем. Если вам нужно знать, какой путь вы в данный момент
# используете, для этого нужно вызвать os.getcwd().
#
# ПРИМЕЧАНИЕ: все дальнейшие пути указаны для конкретной машины на ОС Linux.
# У вас эти результаты будут отличаться.

start_path = os.getcwd()  # получить текущий путь
print(start_path)  # /home/nbuser/library

# Далее попробуем подняться на директорию выше:

os.chdir("..")  # подняться на один уровень выше
print(os.getcwd())  # '/home/nbuser'

# Теперь вернёмся в ту директорию, из которой стартовали.
# Изначально мы сохраняли её в переменной start_path.

os.chdir(start_path)
print(os.getcwd())  # '/home/nbuser/library'

# С помощью функции os.listdir() можно получить весь список файлов, находящихся в директории.
# Если не указать никаких аргументов, то будет взята текущая директория.

# список файлов и директорий в папке
# import os

print(os.listdir())  # ['SnapchatLoader', 'FBLoader', 'tmp.py', '.gitignore', 'venv', '.git']

if 'tmp.py' not in os.listdir():
    print("Файл отсутствует в данной директории")

# Для того чтобы склеивать пути с учётом особенностей ОС, следует использовать
# функцию os.path.join(). Это связано с тем, что в разных операционных системах
# могут быть разные разделители каталогов, например, в ОС Windows этим разделителем
# является «\», а в Linux — «/», как мы и говорили в начале юнита. Поэтому чтобы
# поиск файла проходил гладко на обеих системах (ведь ваш скрипт могут запускать
# на любой системе в связи с кросс-платформенностью Python),
# лучше всё-таки использовать join.

# соединяет пути с учётом особенностей операционной системы
print(start_path)
print(os.path.join(start_path, 'test'))


# /home/nbuser/library
# /home/nbuser/library/test

#  Задание 3.4.1
# Путь, который указывает на одно и то же место в файловой системе,
# вне зависимости от текущего рабочего каталога или других обстоятельств,
# называется... # абсолютный
#
# Путь по отношению к текущему рабочему каталогу пользователя
# называется... # относительный

# Задание 3.4.3
# Сделайте функцию, которая принимает от пользователя путь и выводит всю
# информацию о содержимом этой папки. Для реализации используйте функцию
# встроенного модуля os.walk(). Если путь не указан,
# то сравнение начинается с текущей директории.
def show_dir(path=None):
    start_path = path if path is not None else os.getcwd()

    for root, dirs, files in os.walk(start_path):
        print("Текущая директория", root)
        print("---")

        if dirs:
            print("Список папок", dirs)
        else:
            print("Папок нет")
        print("---")

        if files:
            print("Список файлов", files)
        else:
            print("Файлов нет")
        print("---")

        if files and dirs:
            print("Все пути:")
        for f in files:
            print("Файл", os.path.join(root, f))
        for d in dirs:
            print("Папка", os.path.join(root, d))
        print("===")


show_dir()

#
# Работа с файлами
#
# Python «из коробки» располагает достаточно широким набором инструментов для работы с файлами.
# Для того чтобы начать работать с файлом, надо его открыть с помощью команды специальной функции open.
"""
f = open('path/to/file', 'filemode', encoding='utf8')
"""
# Результатом этой операции будет файл, в котором указатель текущей позиции
# поставлен на начало или конец файла.

# Перед тем как начнём разбирать аргументы, хотелось бы заранее отметить, что
# указателем называется скорее метка, которая указывает на определённое место
# в файле. Указателей в классическом понимании программиста, как например,
# в C или C++, в Python нет!
#
# Давайте по порядку разберём все аргументы:
#
# 1. path/to/file — путь к файлу может быть относительным или абсолютным.
#   Можно указывать в Unix-стиле (path/to/file) или в Windows-стиле (path\to\file).
# 2. filemode — режим, в котором файл нужно открывать.
#      Записывается в виде строки, состоит из следующих букв:
#         r — открыть на чтение (по умолчанию);
#         w — перезаписать и открыть на запись (если файла нет, то он создастся);
#         x — создать и открыть на запись (если уже есть — исключение);
#         a — открыть на дозапись (указатель будет поставлен в конец);
#         t — открыть в текстовом виде (по умолчанию);
#         b — открыть в бинарном виде.
# 3. encoding — указание, в какой кодировке файл записан (utf-8, cp1251 и т. д.).
#    По умолчанию стоит utf-8.
#
# Открытие файла на запись является блокирующей операцией, то есть она останавливает
# работу нашей программы до того, пока файл не откроется.

# Теперь давайте поговорим про то, как записывать какую-либо информацию в файл.
#
# При открытии файла внутри него ставится указатель текущей позиции для чтения.
# При открытии в режиме чтения или записи указатель ставится на начало,
# в режиме a (добавление новых записей в конец файла) — в конец.
#
# Откроем файл на запись и с помощью метода write запишем в него строку.
# В качестве результата метод write возвращает количество записанных символов.

f = open('test.txt', 'w', encoding='utf8')

# Запишем в файл строку
f.write("This is a test string\n")
f.write("This is a new string\n")
# моя отсебятина:
# f.write("Это текстовая строка\n")
# f.write("А это еще одна текстовая строка\n")

# После вызова команды write ваши данные не сразу попадут и сохранятся в файл.
# Связанно это с особенностями внутренней работы операционных систем. Если для
# вас критично своевременно попадание информации на жёсткий диск компьютера,
# то после записи вызывайте f.flush() или закрывайте файл. Закрыть файл можно
# с помощью метода close().
#
# # обязательно нужно закрыть, файл иначе он будет заблокирован ОС
f.close()

# Теперь давайте посмотрим, как читать данные из файла.
#
# Откроем файл для чтения, в который только что записали две строки:

f = open('test.txt', 'r', encoding='utf8')  # # считали остаток файла

# Вот его содержимое на жёстком диске:
# This is a test string
# This is a new string

# После того как файл открыт для чтения, мы можем читать из него данные.
#
# f.read(n) — операция, читающая с текущего места n символов,
# если файл открыт в t режиме, или n байт, если файл открыт в b режиме,
# и возвращающая прочитанную информацию

print(f.read(10))  # This is a

# После прочтения указатель на содержимое остаётся на той позиции, где чтение
# закончилось. Если n не указать, будет прочитано «от печки», т. е. от текущего
# места указателя и до самого конца файла.

print(f.read())     #   test string
                    #   This is a new string

# После работы обязательно закрываем файл:
#
f.close()  # обязательно закрываем файл!
