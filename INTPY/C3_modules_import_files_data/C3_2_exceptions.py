#
# C3.2. Тонкости обработки исключений. Собственные классы исключений
#
# Дисклеймер: данный материал попал к вам на страничку прямиком из пустыни Сахары,
# самого засушливого места на нашей планете. Если от сухости повествования у вас
# появится сухость во рту, не переживайте и не пугайтесь, это нормально. Такая уж
# тема, что тут поделать (чем дальше, тем суше, можно сказать). Поэтому, пожалуйста,
# заранее запаситесь прохладительными напитками и устраивайтесь поудобнее. Приятного прочтения!
#
# В прошлом юните мы познакомились с вами с конструкцией try-except. Научились
# отлавливать стандартные исключения и поднимать их при необходимости. В этом уроке
# мы закончим говорить об конструкции try-except, обсудим небольшие нюансы работы с ней,
# а также попробуем написать собственные классы-исключения.
#
# Пожалуйста, посмотрите на схему, представленную ниже.

# BaseException
#  +-- SystemExit
#  +-- KeyboardInterrupt
#  +-- GeneratorExit
#  +-- Exception
#   	+-- StopIteration
#   	+-- StopAsyncIteration
#   	+-- ArithmeticError
#   	|	FloatingPointError
#   	|	OverflowError
#   	|	ZeroDivisionError
#   	+-- AssertionError
#   	+-- AttributeError
#   	+-- BufferError
#   	+-- EOFError
#   	+-- ImportError
#   	|	+-- ModuleNotFoundError
#   	+-- LookupError
#   	|	+-- IndexError
#   	|	+-- KeyError
#   	+-- MemoryError
#   	+-- NameError
#   	|	+-- UnboundLocalError
#   	+-- OSError
#   	|	+-- BlockingIOError
#   	|	+-- ChildProcessError
#   	|	+-- ConnectionError
#   	|	|	+-- BrokenPipeError
#   	|	|	+-- ConnectionAbortedError
#   	|	|	+-- ConnectionRefusedError
#   	|	|	+-- ConnectionResetError
#   	|	+-- FileExistsError
#   	|	+-- FileNotFoundError
#   	|	+-- InterruptedError
#   	|	+-- IsADirectoryError
#   	|	+-- NotADirectoryError
#   	|	+-- PermissionError
#   	|	+-- ProcessLookupError
#   	|	+-- TimeoutError
#   	+-- ReferenceError
#   	+-- RuntimeError
#   	|	+-- NotImplementedError
#   	|	+-- RecursionError
#   	+-- SyntaxError
#   	|	+-- IndentationError
#   	|     	+-- TabError
#   	+-- SystemError
#   	+-- TypeError
#   	+-- ValueError
#   	|	+-- UnicodeError
#   	|     	+-- UnicodeDecodeError
#   	|     	+-- UnicodeEncodeError
#   	|     	+-- UnicodeTranslateError
#   	+-- Warning
#        	+-- DeprecationWarning
#        	+-- PendingDeprecationWarning
#        	+-- RuntimeWarning
#        	+-- SyntaxWarning
#        	+-- UserWarning
#        	+-- FutureWarning
#        	+-- ImportWarning
#        	+-- UnicodeWarning
#        	+-- BytesWarning
#        	+-- ResourceWarning

# Если вы заглядывали в документацию, как было предложено в конце предыдущего
# юнита, то могли уже видеть её.
#
# Эта система — дерево стандартных исключений.
#
# Как нетрудно было догадаться, исключения представлены определёнными классами,
# которые в той или иной степени наследуются от BaseException.
#
# Исключения классов SystemExit, KeyboardInterrupt, GeneratorExit не сигнализируют
# об ошибках. Эти исключения используют, чтобы сообщить о завершении работы кода
# (SystemExit), о нажатии клавиши прерывания (KeyboardInterrupt) или о
# закрытии генератора (GeneratorExit).
#
# Принято, что об ошибках сигнализируют объекты класса Exception и его потомков —
# с ними мы и будем работать далее.
#
# Важно понять, что в блоке except отлавливается не только сам указанный класс,
# но и его потомки. Например:

try:
    raise ZeroDivisionError  # возбуждаем исключение ZeroDivisionError
except ArithmeticError:  # ловим его родителя
    print("Hello from arithmetic error")

# Результат:
# Hello from arithmetic error

# Такой способ отлова будет работать прекрасно. Другое дело, что делать так
# лучше не стоит, потому что вы рискуете упустить детали, но с другой стороны,
# порой даже на больших проектах можно встретить что-то типа:

# пример из реального проекта
# try:
#     *код, который мог вызывать ошибку*
# except Exception:
#     pass

# Т.е. если что-то пошло не так, то мы просто забиваем и идём дальше по коду.
# Код настоящего пофигиста, что тут ещё скажешь. :)
#
# Однако, действуя от обратного, надо быть осторожным. Если, например, надо
# поймать несколько эксепшенов, то идти следует вверх по дереву.
#
# Например:

try:
    raise ZeroDivisionError
except ArithmeticError:
    print("Arithmetic error")
except ZeroDivisionError:
    print("Zero division error")

# Здесь результатом работы программы будет вывод на экран:
# Arithmetic error
#
# Потому как ArithmeticError является более абстрактным классом. Т.е. если
# вы хотите ловить сначала сами классы, а потом любой другой из наследуемых,
# то убедитесь, что вы идёте от конкретного к абстрактному.
#
# Вот правильный пример для наглядности:

try:
    raise ZeroDivisionError
except ZeroDivisionError:  # сначала пытаемся поймать наследника
    print("Zero division error")
except ArithmeticError:  # потом ловим родителя
    print("Arithmetic error")


# В данном случае код сработает как надо, и мы увидим:
# Zero division error
#
# Это всё, что хотелось ещё рассказать о конструкции try-except.
#
# Если кратко обобщить, то можно сказать так: исключения — это тоже классы.
# Только поведение их особое: они могут наследоваться; ловить можно как сам
# класс, так и его родителя (при том в любом колене). В этом случае надо,
# чтобы сначала обрабатывались более конкретные исключения, иначе они могут
# быть перекрыты их родителями и просто-напросто будут упущены.
#
# Иногда может понадобиться написать собственное исключение. Например, вы
# пишите собственную игру и вам нужно обработать ситуацию, когда ваш персонаж
# пытается выучить способность, при этом не достигнув нужного уровня. Или
# пытается положить в уже заполненный инвентарь ещё какой-то предмет.
#
# Принцип написания и отлова собственного исключения следующий:

class MyException(Exception):  # создаём пустой класс – исключения
    pass


try:
    raise MyException("message")  # поднимаем наше исключение
except MyException as e:  # ловим его за хвост как шкодливого котёнка
    print(e)  # выводим информацию об исключении


# Лучше всего, чтобы исключения были связаны между собой, т.е. наследоваться
# от общего класса исключения. Если продолжить пример с игрой из прошлого абзаца,
# то общим классом был бы GameplayException.
#
# Наследуются исключения для того, чтобы можно было, продолжая всё тот же пример,
# отлавливать отдельно игровые исключения и отдельно исключения, касающееся
# ресурсов (закончилась оперативная память, место на диске и т. д.).
#
# Давайте теперь попробуем построить собственные исключения с наследованием:

class ParentException(Exception):  # создаём пустой класс – исключения потомка, наследуемся от exception
    pass


class ChildException(ParentException):  # создаём пустой класс – исключение наследника, наследуемся от ParentException
    pass


try:
    raise ChildException("message")  # поднимаем исключение-наследник
except ParentException as e:  # ловим его родителя
    print(e)  # выводим информацию об исключении


# В этом случае мы успешно обработали собственный класс-наследник, хотя он
# и не является ParentException. Просто когда исключение возникает, в каждом
# блоке except по порядку интерпретатор проверяет, является ли исключение
# наследником или самим классом отлавливаемого исключения, и если да,
# то выполняет код в except.
#
# Кстати говоря, класс с самописным исключением необязательно должен быть
# пустым. Если вы хотите добавить собственные аргументы в конструктор,
# дополнительно произвести какие-либо операции, то можете спокойно это
# делать, главное — не забыть о нескольких нюансах:

class ParentException(Exception):
    def __init__(self, message, error):  # допишем к нашему пустому классу конструктор,
        # который будет печатать дополнительно в консоль информацию об ошибке.
        super().__init__(message)  # помним про вызов конструктора родительского класса
        print(f"Errors: {error}")  # печатаем ошибку


class ChildException(ParentException):  # создаём пустой класс – исключение наследника,
    # наследуемся от ParentException
    def __init__(self, message, error):
        super().__init__(message, error)


try:
    raise ChildException("message", "error")  # поднимаем исключение-наследник, передаём дополнительный аргумент
except ParentException as e:
    print(e)  # выводим информацию об исключении


# В консоли мы увидим следующее:
# Errors: error
# message
#
# Сначала мы увидим то, что напишет нам конструктор родительского класса,
# а потом уже увидим сообщение об ошибке.

# Конечно же, собственный класс исключений можно модернизировать как угодно:
# добавлять дополнительные аргументы, писать собственные методы, наследоваться
# хоть до десятого колена и т. д. Суть одна — помните про иерархию и полиморфизм,
# остальное за вас сделает Python.

# Давайте подведём итоги (если вы ещё не высохли от такого повествования,
# но что поделать, такая уж тема):
#
#     Исключения — это такие особенные классы, которые как и любые классы
#           можно наследовать. Если вы хотите ловить несколько исключений, то
#           сначала ловите потомков, а потом родителей, чтобы ничего не упустить.
#     Чтобы создать собственный класс, нужно просто написать пустой класс и
#           наследовать его от класса Exception, этого будет достаточно.
#     Необязательно отлавливать сам класс, при необходимости можно отлавливать его
#           родителя, это тоже будет работать, но вы можете упустить важную информацию.

#
# Задание 3.2.1
# В канале модуля в Slack обсудите со своими коллегами вопрос:
# почему наследоваться надо именно от класса Exception, а не от BaseException?

#  Задание 3.2.2
# Для того чтобы грамотно отлавливать исключения и ничего не упустить, надо...
#   отлавливать исключения от абстрактного к конкретному.
#   отлавливать исключения от конкретного к абстрактному. # верно
#   отлавливать исключения в любом порядке, интерпретатор сам определит,
#       какое именно исключение возникло, и сам перейдёт в нужный блок except.

#  Задание 3.2.3
# Исключения являются...
#   Объектами
#   Специальным ключевым словом
#   Классами с определённым поведением  # верно

#  Задание 3.2.4
# Для того чтобы создать минимально работающий собственный класс-исключение, надо...
#   Написать любой пустой класс, наследуемый от класса BaseException.
#   Написать любой пустой класс, наследуемый от класса Exception.   # верно
#   Написать класс, наследованный от класса Exception, и переопределить в нём все методы и конструктор.

# Задание 3.2.5
# Задание на самопроверку.
# Создать класс Square. Добавить в конструктор класса Square собственное исключение
# NonPositiveDigitException, унаследованное от ValueError, которое будет срабатывать
# каждый раз, когда сторона квадрата меньше или равна 0.

class NonPositiveDigitException(ValueError):
    pass


class Square:
    def __init__(self, side):
        if side <= 0:
            raise NonPositiveDigitException('Неправильно указана сторона!')
        self.side = side

    def area(self):
        return self.side ** 2
