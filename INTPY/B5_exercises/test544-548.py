# Усложним задачу и реализуем функцию, решающую квадратные уравнения.
# Вспомним сначала матчасть:

equation = """
Квадратное уравнение:
a*x**2 + b*x + c = 0    - общий вид уравнения
D = b**2 - 4*a*c        - дискриминант
Если D<0, то уравнение не имеет вещественных корней
Если D=0, то уравнение имеет один корень - x = -b/(2*a)
Если D>0, то уравнение имеет два корня:
x1 = (-b - D**0.5)/(2*a)
x2 = (-b + D**0.5)/(2*a)

P.S. D**0.5 - равносильно извлечению квадратного корня
"""
print(equation)

# Пойдём поэтапно. Сначала напишем функцию, вычисляющую дискриминант уравнения.

# Задание 5.4.3

# Напишите функцию D(a, b, c), возвращающую дискриминант квадратного уравнения.

def D(a, b, c):
    return b ** 2 - 4 * a * c

# Следующим этапом реализуем функцию, возвращающую «Нет вещественных корней»,
# если дискриминант отрицательный.

# Задание 5.4.4
# Реализуйте функцию quadratic_solve(a, b, c), возвращающую «Нет вещественных корней»
# в случае отрицательного дискриминанта.

def quadratic_solve(a, b, c):
    if D(a, b, c) < 0:
        return "Нет вещественных корней"

# Далее модифицируем функцию таким образом, чтобы при нулевом дискриминанте возвращалось значение единственного корня.

# Задание 5.4.5
# Модифицируйте функцию quadratic_solve(a, b, c), чтобы она возвращала
# единственный корень при условии нулевого дискриминанта.

def quadratic_solve(a, b, c):
    if D(a, b, c) < 0:
        return "Нет вещественных корней"
    elif D(a, b, c) == 0:
        return -b / (2 * a)

# И последним этапом нам нужно вернуть сразу два значения. Конечный вид функции будет выглядеть так:

def quadratic_solve(a, b, c):
    if D(a, b, c) < 0:
        return "Нет вещественных корней"
    elif D(a, b, c) == 0:
        return -b / (2 * a)
    else:
        return (-b - D(a,b,c) ** 0.5) / (2 * a), (-b + D(a, b, c) ** 0.5) / (2 * a)

# Задание 5.4.6
# Какой тип возвращаемого значения имеет функция при положительном дискриминанте?
# tuple

# И, наконец, потренируемся с одним удобным способом использования функций.
# Представим, что параметры уравнения хранятся в виде списка. Такое может быть,
# если аргументы были получены из консоли.
#
# разбили строку из input и преобразовали к float
L = list(map(float, input().split()))
# [1, 0, -1] - например
#
# Конечно, можно было бы присвоить новым переменным полученные значения
# или передавать в аргументы функции, обращаясь через индексы.
#
print(quadratic_solve(L[0], L[1], L[2]))
# (-1.0, 1.0)
#
# Отлично работает, но это не pythonic way. Согласитесь, что выглядит
# не очень-то красиво, а первый пункт философии Python гласит:
# «Красивое лучше, чем уродливое».

#  Задание 5.4.7
#
# Замените знаки «?» корректным выражением. Как можно передать список
# в аргументы функции, используя операцию распаковки?

print(quadratic_solve(*L))


# Представим, что у нас теперь аргументы хранятся не в виде списка, а в виде словаря.

M = {'a': 1,
     'b': 0,
     'c': -1}

# Задание 5.4.8
#
# Замените знаки «?» корректным выражением. Как можно передать словарь
# в аргументы функции, используя операцию распаковки?

print(quadratic_solve(**M))


# Практический совет: побочные эффекты

# В результате работы функции может произойти много чего. Иногда это предсказуемо,
# иногда не очень. Однако предсказуемое поведение функций принято проектировать
# согласно принципам функционального программирования. И один из главных принципов
# рекомендует создавать функции без побочных эффектов (side effects).

# К ним относят:
#
#         изменение переменных, находящихся на более высоком уровне видимости;
#         ввод/вывод данных;
#         чтение/запись в файл и др.
#
# Перечисленные побочные эффекты являются основными, но если говорить про них в общем,
# то это такие действия внутри функции, которые каким-либо образом влияют на внешнюю среду.
#
# Полностью избежать появления побочных эффектов в функциях, естественно, невозможно,
# но следует минимизировать их появление.

# см. test5409-5411.py
