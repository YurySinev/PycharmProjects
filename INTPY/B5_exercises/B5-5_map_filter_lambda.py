from divide_line import line

# функция map
line("Функция map")

L = ['THIS', 'IS', 'LOWER', 'STRING', 'dog', 'cat', 'fish', 'mouse', 'Python']  # список
txt = "Это строка"  # строка
T = ('это', 'кортеж')  # кортеж

print(list(map(str.lower, L)))
print(list(map(str.upper, L)))

print(list(map(len, L)))

print(tuple(map(str.upper, T)))
print(tuple(map(len, T)))

print(str.lower(txt))

# функция filter
line("Функция filter")


def positive(x): return x > 0


def even(x): return x % 2 == 0


L = [1, -3, 5, 6, -4, -2, 8, -9]

result = filter(positive, L)
print(list(result))

result = filter(even, L)
print(list(result))
# ----------------------------------
# map + filter
some_list = [i - 10 for i in range(20)]


def pow2(x): return x ** 2


def positive(x): return x > 0


print(some_list)
print(list(map(pow2, filter(positive, some_list))))

# То же самое через list comprehension.

print([i ** 2 for i in some_list if i > 0])

# -------------------------------------
# lambda функция
line("lambda функция")
# Предположим, мы хотим отсортировать словарь по значениям. Вообще говоря,
# словарь (его ещё называют ассоциативным массивом) является неупорядоченной
# структурой данных. Иными словами, порядок хранения пар ключ-значение в памяти
# может быть произвольным. Однако создатели языка Python, начиная с версии 3.6,
# изменили реализацию словарей таким образом, что порядок ключей «запоминается».
# И потому упорядочивание словаря в Python становится осмысленным.
# По умолчанию словарь сортируется по ключам.

d = {2: "c", 1: "d", 4: "a", 3: "b"}  # словарь

# Чтобы отсортировать его по ключам, нужно сделать так
print(dict(sorted(d.items())))
# {1: 'd', 2: 'c', 3: 'b', 4: 'a'}

# А вот, чтобы отсортировать словарь по значениям, необходимо указать,
# что сортировать нужно по второму элементу кортежа ключ-значение.
# Тут на помощь приходят lambda-функции. У встроенной функции sorted()
# можно задать аргумент key, который укажет, по какому ключу нужно
# производить сортировку.

print(dict(sorted(d.items(), key=lambda x: x[1])))

# Итог по lambda-функциям:
#         - используются один раз;
#         - не загромождают код программы;
#         - после выполнения сразу удаляются;
#         - могут выполнять только одно действие.

# Задание 5.5.3
#
# Предположим у нас есть список с данными о росте и весе людей.
# Задача — отсортировать их по индексу массы тела. Он вычисляется по формуле:
# свой рост в сантиметрах возвести в квадрат, потом массу тела в килограммах
# разделить на полученную цифру.

# (вес, рост)
data = [
    (82, 1.91),
    (68, 1.74),
    (90, 1.89),
    (73, 1.79),
    (76, 1.84)
]

print(data)
print(sorted(data, key=lambda x: x[0] / x[1] ** 2))

# Задание 5.5.4
# Из списка в предыдущем задании найти кортеж с минимальным индексом массы тела.
#
# Ответ
#
print(min(data, key=lambda x: x[0] / x[1] ** 2))  # отбор по ключу
print(max(data, key=lambda x: x[0] / x[1] ** 2))

#  Задание 5.5.5
# Замените знаки «?» корректным выражением. Вывести длину каждого элемента в списке.
#
a = ["asd", "bbd", "ddfa", "mcsa", "Moscow", "New York"]
#
# print( ??? )
#
# Примечание. Попробуйте выполнить это задание без lambda-функций, используя только встроенные функции.

print(list(map(len, a)))

#  Задание 5.5.6
# Замените знаки «?» корректным выражением. Переведите все строки из списка
# в верхний регистр (заглавные буквы).
#
a = ["это", "маленький", "текст", "обидно"]
#
print(list(map(str.upper, a)))
