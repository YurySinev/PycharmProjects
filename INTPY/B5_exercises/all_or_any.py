
# Все или любой?
#
# Представим, что на вход нашей программы подаётся число. А мы хотим проверить,
# является ли оно целым, находится ли в определённом промежутке (например,
# от 100 до 999 включительно), да ещё и делится ли на 2 и 3 одновременно.
# Очень много условий. И такое случается в реальных проектах.
#
# Решение в лоб — использовать вложенные условные операторы. Один if внутри другого if и т.д.
# Наверняка есть способ сделать это быстрее и эффективнее, но для начала попробуем написать
# решение в таком варианте, чтобы было с чем сравнить:

a = int(input())

# Задание 5.3.9
# Напишите алгоритм, реализованный с помощью вложенных условных операторов,
# который проверяет заданные выше условия.

# мое решение:
if a is not float:
    if 100 <= a <= 999:
        if a % 2 == 0 and a % 3 == 0:
            print("Да! Это искомое число:", a)
        else:
            print("Число не делится на 2 и 3 одновременно")
    else:
        print("Это число за пределами диапазона")
else:
    print("Это не целое число")

# предложенное решение:
if type(a) == int:
    if 100 <= a <= 999:
        if a % 2 == 0:
            if a % 3 == 0:
                print("Число удовлетворяет условиям")

# Задание 5.3.10
# Напишите тот же алгоритм, но объединив все условия в одну строку,
# используя логические операторы и операторы сравнения:

if type(a) == int and 100 <= a <= 999 and a % 2 == 0 and a % 3 == 0:
    print("Число удовлетворяет условиям")

# Выглядит лучше по объему кода, но теперь выражение в условном операторе выглядит громоздко.
# Можно задаться вопросом: а можно ли упростить это выражение? Хотя бы по той причине, что
# все условия «стыкуются» с помощью логического И.
#
# И ответ — да, можно. В Python есть функция all([ ]), которая возвращает True,
# если все условия, переданные в аргумент функции в виде списка, являются истинными.

if all([type(a) == int,
        100 <= a <= 999,
        a % 2 == 0,
        a % 3 == 0]):
    print("Число удовлетворяет всем условиям")

# Такой подход является достаточно лаконичным и более эффективным, он более «питоновский».
#
# Функция all([ ]) возвращает True, если все элементы списка являются истинными. А что,
# если нужно, чтобы был хотя бы один истинный? Тогда на помощь приходит функция any([ ]).
# Её синтаксис аналогичен рассмотренному выше примеру c функцией all([ ]).

# Задание 5.3.11
# Напишите программу, которая на вход принимает последовательность целых чисел и возвращает True,
# если все числа ненулевые, и False, если хотя бы одно число равно 0.

nums = list(map(int, input().split()))
# 1 2 3 4 5 6 7
# 3 5 6 0 3 4 5
print(all(nums))
# True
# False

# Задание 5.3.12
# Напишите программу, которая на вход принимает последовательность целых чисел и возвращает True,
# если все числа равны нулю, и False, если найдётся хотя бы одно ненулевое число.
# Разрешается использование только логических операторов и функций all([ ]) и any([ ]).

N = list(map(int, input().split()))
# 0 0 0 0 0 0 0 0 0
# 0 0 0 7 0 0 0 0 0
print(not any(N))
# True
# False

# Конечно, когда нужно писать список (в аргумент функции) вручную,
# эффективность кода не так уж и заметна. Но оказывается, что большие списки
# можно составлять на лету и буквально в одну строку.