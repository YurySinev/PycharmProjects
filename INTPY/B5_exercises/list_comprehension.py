#
# List comprehension
#
# К сожалению, дословно на русский язык перевести этот термин не представляется возможным,
# но в разных источниках можно встретить названия — списковые включения, списковые вложения
# или генераторы списков. Их стоит отличать от генераторов, которые рассматривались ранее в модуле B4.
#
# Генераторы списков — это специальный синтаксис, определяющий правила создания и заполнения списков.
# В общем виде эта конструкция записывается следующим образом:
#
# L = [ a for a in some_iter_obj if cond ]
#
# Такая запись аналогична следующей:
#
# L = []
#
# for a in some_iter_obj:
#     if cond:
#         L.append(a)
# Разберём синтаксис генератора списка по частям.
# В основе лежит цикл for-in,записывающийся по всем правилам, которые обсуждались ранее.
# Перед ним записывается общий вид элементов списка,
# а после — условие, по которому элемент включается в список.
#
# -------------------------------
# # мои эксперименты :)))
# list_ = list(map(int, input().split()))
# print(list_)
# # [1, 2, 3, 5, 6]
# # [1, 3, 2, 1, 0, 1, 3, 2, 8, 5, 6, 2, 3, 1, 5]
# L = [a for a in list_ if a > 3]
# print(L)
# # [5, 6]
# # [8, 5, 6, 5]
# -------------------------------

# Рассмотрим несколько примеров.
# Напишем генератор списков, в котором будут храниться квадраты первых 10 натуральных чисел.

squares = [i**2 for i in range(1,11)]
print(squares)
# [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]

# Можно модифицировать этот генератор списков таким образом, что
# в список будут включаться квадраты только от нечётных чисел.

squares = [i**2 for i in range(1,11) if i % 2 == 1]
print(squares)
# [1, 9, 25, 49, 81]

# Тип элемента, который будет включаться в список, может быть любым.
# Например, можно составить список из кортежей:
#
list_tuples = [(i, i**2) for i in range(1,11)]
for i in list_tuples:
    print(i)
# #[(1, 1),
# # (2, 4),
# # (3, 9),
# # (4, 16),
# # (5, 25),
# # (6, 36),
# # (7, 49),
# # (8, 64),
# # (9, 81),
# # (10, 100)]

# А используя вложенные генераторы списков, можно создать матрицу «одним махом»:
#
M = [[i+j for j in range(5)] for i in range(5)]
for i in M:
    print(i)
# #[[0, 1, 2, 3, 4],
# # [1, 2, 3, 4, 5],
# # [2, 3, 4, 5, 6],
# # [3, 4, 5, 6, 7],
# # [4, 5, 6, 7, 8]]

# ------------------------------
# Задание 5.3.13
# При помощи генератора списков создайте таблицу умножения чисел от 1 до 10.
#
# Ответ:
T = [[i*j for j in range(1,11)] for i in range(1,11)]
# ------------------------------

# Интересный эффект образуется в сочетании использования генераторов списков и функции input().
# На каждой итерации цикла консоль будет запрашивать данные для ввода и сохранять их в качестве элемента списка.
#
# L = [input() for i in range(5)]
#
# Приведённый выше пример 5 раз запросит у пользователя данные для входа и запишет их в список. Здесь же можно использовать сразу преобразование в необходимый тип, если он заранее известен.
#
L = [int(input("Введите целое число: ")) for i in range(5)]
print("Сумма введеных вами чисел", L, "=", sum(L))

# Задание 5.3.14
# Модифицируйте последний пример таким образом, чтобы в список сохранялось True,
# если элемент чётный, и False, если элемент нечётный.
L = [int(input()) % 2 == 0 for i in range(5)]
# 2 3 4 5 6
print(L)
# [True, False, True, False, True]

#  Задание 5.3.15
# А вот здесь нам и поможет использование функций all([ ]) и any([ ]).
# Замените знаки «?» таким образом, чтобы программа выводила True, если есть хотя бы одно чётное число.
#
# L = [int(input()) % 2 == 0 for i in range(5)]
# print( ???(L))

L = [int(input()) % 2 == 0 for i in range(5)]
# 1 2 3 4 5
print(any(L))
# True

# Задание 5.3.16
# Подумайте, как нужно записать логическое выражение, используя all([ ]) и any([ ])
# над списком чётности, если его результат будет истинным тогда и только тогда,
# когда в списке есть хотя бы один чётный и хотя бы один нечётный элемент.

print(any(L) and not all(L))
# True



