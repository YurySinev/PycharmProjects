#
# zip()
#
# Рассмотрим ещё одну полезную «фичу», которая упрощает работу со списками в циклах
# (а значит, и во вложенных генераторах).
#
# Допустим, у нас есть два списка одинакового размера:
#
L = [i for i in range(10)]
# 0 1 2 3 4 5 6 7 8 9
M = [i for i in range(10, 0, -1)]
# 10 9 8 7 6 5 4 3 2 1
#
# И нам необходимо создать новый список, который будет состоять
# из произведений соответствующих элементов друг на друга.
#
# он должен выглядеть так
# 0 9 16 21 24 25 24 21 16 9
#
# Мы знаем, что элементов в списке 10, поэтому можем пробежаться в цикле по индексам от 0 до 10:
#
N = []

for i in range(10):
    N.append(L[i] * M[i])
#
print(N)
# Такой код является корректным, но не «питоновским».
# Мы знаем, что циклом for можно итерировать сразу списки.
# Например:
#
# for a in L:
#     # какой-то код
#
# Но хотелось бы сделать так же, только сразу по двум спискам.
# В Python существует функция zip(), позволяющая объединить
# два списка в новый список кортежей, каждый из которых будет
# содержать по одному элементу из каждого списка.
#
# for a in zip(L,M):
#     print(a)
# #(0, 10)
# #(1, 9)
# #(2, 8) и т.д.

# Код можно сделать ещё более приятным:
#
for a, b in zip(L, M):
    print('a =', a, 'b =', b)
# #a = 0 b = 10
# #a = 1 b = 9
# #a = 2 b = 8
# #a = 3 b = 7 и т.д.

# Задание 5.3.17
# Используя функцию zip() внутри генераторов списков, вычислите поэлементные произведения списков L и M.
#
# Ответ:
#
# for a, b in zip(L, M): # так тоже работает
#     print(a*b, end=' ')

N = [a * b for a, b in zip(L, M)]
print(N)
