def linear_solve(a, b):
    return b / a
print(linear_solve(5, 15))
# 3.0
# но:
# print(linear_solve(0, 1))
# ZeroDivisionError!

def linear_solve(a, b):
    if a: # помним, что 0 интерпретируется как False, иначе True
        return b / a
    else:
        return "Нет корней"

# Однако и здесь кроется неожиданность:
print(linear_solve(0, 0))

# Ведь, если и a=0, и b=0, уравнение имеет бесконечное количество корней
# (любое число при умножении на ноль даст ноль). А наша программа вернёт
# «Нет корней». Так быть не должно. Модифицируем нашу программу ещё раз.

def linear_solve(a, b):
    if a:
        return b / a
    elif not a and not b: # снова используем числа в логических выражениях
        return "Бесконечное количество корней"
    else:
        return "Нет корней"
print(linear_solve(0, 0))

# Усложним задачу и реализуем функцию, решающую квадратные уравнения. Вспомним сначала матчасть:

# a*x**2 + b*x + c = 0 - общий вид уравнения
# D = b**2 - 4*a*c - дискриминант
# Если D<0, то уравнение не имеет вещественных корней
# Если D=0, то уравнение имеет один корень - x = -b/(2*a)
# Если D>0, то уравнение имеет два корня
# x1 = (-b - D**0.5)/(2*a)
# x2 = (-b + D**0.5)/(2*a)
#
# P.S. D**0.5 - равносильно извлечению квадратного корня

# Задание 5.4.3
# Напишите функцию D(a, b, c), возвращающую дискриминант квадратного уравнения.

# def D(a, b, c):
#     return b**2 - 4 * a * c
#
# print(D(1,2,3))

#Задание 5.4.4
# Реализуйте функцию quadratic_solve(a, b, c), возвращающую «Нет вещественных корней»
# в случае отрицательного дискриминанта.

def D(a, b, c):
    return b**2 - 4 * a * c
# print(D(1,2,3))
def quadratic_solve(a, b, c):
    if D(a, b, c) < 0:
        return "Нет вещественных корней"
    elif D(a, b, c) == 0:       # Задание 5.4.5 - чтобы она возвращала единственный корень
        return -b / (2 * a)     # при условии нулевого дискриминанта.
# И последним этапом нам нужно вернуть сразу два значения. Конечный вид функции будет выглядеть так:
    else:
        return (-b - D(a,b,c) ** 0.5) / (2 * a), (-b + D(a, b, c) ** 0.5) / (2 * a)

print(quadratic_solve(9, 12, 3))

#

# И, наконец, потренируемся с одним удобным способом использования функций.
# Представим, что параметры уравнения хранятся в виде списка. Такое может быть,
# если аргументы были получены из консоли.
#
# # разбили строку из input и преобразовали к float

# L = list(map(float, input().split()))

# # [1, 0, -1] - например
#
# Конечно, можно было бы присвоить новым переменным полученные значения или
# передавать в аргументы функции, обращаясь через индексы.
#
# print(quadratic_solve(L[0], L[1], L[2]))
# # (-1.0, 1.0)
#
# Отлично работает, но это не pythonic way. Согласитесь, что выглядит не очень-то красиво,
# а первый пункт философии Python гласит: «Красивое лучше, чем уродливое».
#
# Задание 5.4.7
#
# Замените знаки «?» корректным выражением. Как можно передать список
# в аргументы функции, используя операцию распаковки?
#
# print(quadratic_solve(*L)) # Правильно!
#

# Представим, что у нас теперь аргументы хранятся не в виде списка, а в виде словаря.

M = {'a': 1,
     'b': 0,
     'c': -1}
print(quadratic_solve(*M.values())) # это работает, но мой ответ не принят
print(quadratic_solve(**M))         # а вот этот принят как правильный

# В результате работы функции может произойти много чего. Иногда это предсказуемо,
# иногда не очень. Однако предсказуемое поведение функций принято проектировать
# согласно принципам функционального программирования. И один из главных принципов
# рекомендует создавать функции без побочных эффектов (side effects).
#
# К ним относят:
#
#         изменение переменных, находящихся на более высоком уровне видимости;
#         ввод/вывод данных;
#         чтение/запись в файл и др.
#
# Перечисленные побочные эффекты являются основными, но если говорить про них в общем,
# то это такие действия внутри функции, которые каким-либо образом влияют на внешнюю среду.
#
# Полностью избежать появления побочных эффектов в функциях, естественно, невозможно,
# но следует минимизировать их появление.
#
#-------------------------------------------
# Рекурсия
# Рекурсивные алгоритмы решения некоторых задач являются более эффективными,
# чем другие. В предыдущем модуле мы рассмотрели несколько примеров использования
# такого подхода, а сейчас потренируемся с некоторыми базовыми примерами.
#
# Задание 5.4.9
# Напишите рекурсивную функцию, находящую минимальный элемент списка
# без использования циклов и встроенной функции min().

L = [4, 6, 3, 8, 9, 4, 3, 5, 6, 7]
# не справился я с этим заданием
def min_list(L):
    if len(L) == 1:
        return L[0]
    return L[0] if L[0] < min_list(L[1:]) else min_list(L[1:])
print(min_list(L))

# Задание 5.4.10
# Напишите рекурсивную функцию, которая зеркально разворачивает число.
# Предполагается, что число не содержит нули.

N = 123456
# мое решение:
def recursed_number(x):
    if x // 10 == 0:
        return x
    return x % 10, recursed_number(x//10)
print(recursed_number(N))
# (6, (5, (4, (3, (2, 1))))) # Получилась матрешка из кортежей

# предложенное решение:
def mirror(a, res=0):
    return mirror(a // 10, res*10 + a % 10) if a else res
print(mirror(N))
# 654321

# Поработаем над более сложной рекурсивной функцией. Сейчас попробуем реализовать
# функцию equal(N, S), проверяющую, совпадает ли сумма цифр числа N с числом S.
# При написании программы следует обратить внимание на то, что, если S стала
# отрицательной, то необходимо сразу вернуть False.
#
# Задание 5.4.11
# Реализуйте описанную выше функцию.
#
# Ответ

def equal(N, S):
    if S < 0:
        return False
    if N < 10:
        return N == S
    else:
        return equal(N // 10, S - N % 10)
print(equal(51, 6))