#   ИСПОЛЬЗОВАНИЕ БУЛЕВЫХ ОПЕРАТОРОВ НЕ С БУЛЕВЫМИ ЗНАЧЕНИЯМИ!
#
# Ещё раз про логические операторы
#
# Ранее мы использовали логические операторы только в условных выражениях, что вполне закономерно.
# Однако их можно использовать в неожиданных местах.

a = None
b = a or 1
print(b)
# 1

# Что сейчас произошло?
# Мы объявили переменную как None, а потом использовали логический оператор or
# (логическое ИЛИ) в выражении, которое присвоили другой переменной.
# Может выглядеть странно, но это работает!

# Дело в том, что логические операторы возвращают не обязательно булевы значения (True или False),
# а значение одного из операндов. Это происходит согласно следующим правилам:
#         1. and: если все операнды являются истинными (ненулевые или непустые),
#         то возвращается последнее истинное значение.

print( 1 and "hello" and [False])
# [False]

# Несмотря на то, что последний операнд похож на False, он является непустым списком,а значит, он истинный.

#          2. and: если один из операндов является ложным, то возвращается первый такой операнд.

print(42 and 0 and '' and False)
# 0

# Первый операнд является ненулевым числом — значит, истинный, а все остальные — ноль, пустая строка,
# булево значение False — ложные. И согласно правилу возвращается первый ложный операнд (слева направо).

#           3. or: если один из операндов является истинным, то возвращается первый такой операнд,
#           а остальные игнорируются.

print([] or 3.14 or False)
# 3.14

# Первый операнд (пустой список) является ложным, следующий  (ненулевое число) — истинным,
# а значит, возвращается именно он, а все остальные игнорируются (не вычисляются).

#           4. or: если все операнды являются ложными, то возвращается последний.

print(0 or '' or False)
# False

# Поиск истинного операнда идёт также слева направо, но раз ни один такой не нашёлся,
# возвращается последнее значение, даже если оно ложное.

# И тогда становится понятным, почему сработал пример с присваиванием: оператор or искал
# первый истинный элемент и нашел его — 1. Такая конструкция удобна в нескольких случаях.

# Допустим, нужно инициализировать новую переменную и присвоить ей значение либо старой переменной,
# если значение старой переменной не None, либо 1 в любом другом случае.
#
# Это можно было бы сделать в виде условного оператора:

if a is None:
    b = 1
else:
    b = a

# Выглядит многострочно. Можно использовать тернарный оператор (или его ещё называют инлайновым условным оператором):

b = a if a is not None else 1

# Выглядит гораздо короче, но теперь можно запутаться в большом количестве ключевых слов.
# Согласитесь, что интуитивно очень непонятно. И потому конструкция:

b = a or 1

# является такой удобной. Она очень лаконична и интуитивно понятна:
# присвоить a, если с ней всё хорошо (не нулевая, не пустая, не None), или же единицу.


#  Задание 5.3.4 # Что выведет программа?

a = "foo"
b = "bar"
print(1 and a or b)

 # Задание 5.3.5

a = ""
b = ""

print(1 and a or b)

 # Задание 5.3.6
# Замените знаки «?» корректным выражением.

# пусть a и b - переменные, которые мы хотим проверить if ??? : # проверка истинности обеих переменных

if a and b:
    print("Обе переменные истинные")
    print(a, b)

#  Задание 5.3.7 # Замените знаки «?» корректным выражением.
#
# пусть a и b - переменные, которые мы хотим проверить
if a and b:
    print("Обе переменные истинные")
    print(a,b)
elif a or b:
    print("Одна из переменных истинная")
    print(a or b ) # печать значения одной переменной, которая является истинной

# Задание 5.3.8
# Программа должна выводить «Обе переменные ложные», если они являются таковыми.
# Дополните условный оператор последним блоком.

if a and b:
    print("Обе переменные истинные")
    print(a,b)
elif a or b:
    print("Одна из переменных истинная")
    print(a or b ) # печать значения одной переменной, которая является истинной
else:
    print("Обе переменные ложные")
