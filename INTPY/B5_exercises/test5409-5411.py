# Рекурсия
#
# Рекурсивные алгоритмы решения некоторых задач являются более эффективными,
# чем другие. В предыдущем модуле мы рассмотрели несколько примеров использования
# такого подхода, а сейчас потренируемся с некоторыми базовыми примерами.
#
# Задание 5.4.9
# Напишите рекурсивную функцию, находящую минимальный элемент списка
# без использования циклов и встроенной функции min().
#
L = [3, 6, 7, 4, 5, 8, 2, 56, 34, 21]


def min_list(L):
    if len(L) == 1:
        return L[0]
    else:
        return L[0] if L[0] < min_list(L[1:]) else min_list(L[1:])

# Не!.. мне это понятно, и то слава богу, но сам я такое сочинить не смог бы.
# Пока, по крайней мере. Потому просто подглядел.

print(min_list(L))

#
# Задание 5.4.10
# Напишите рекурсивную функцию, которая зеркально разворачивает число.
# Предполагается, что число не содержит нули.
#
num = 123456789

def mirror(a, res=0):
    return mirror(a // 10, res*10 + a % 10) if a else res

# та же история. Пока мне такое придумать - не по зубам

print(mirror(num))
#
# Поработаем над более сложной рекурсивной функцией. Сейчас попробуем реализовать
# функцию equal(N, S), проверяющую, совпадает ли сумма цифр числа N с числом S.
# При написании программы следует обратить внимание на то, что, если S стала
# отрицательной, то необходимо сразу вернуть False.
#
# Задание 5.4.11
# Реализуйте описанную выше функцию.

def equal(N, S):
    if S < 0:
        return False
    if N < 10:
        return N == S
    else:
        return equal(N // 10, S - N % 10)

print(equal(34567, 25))