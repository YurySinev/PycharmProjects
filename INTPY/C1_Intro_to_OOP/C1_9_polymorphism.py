#
# C1.9. Полиморфизм в Python
#
# Как использовать полиморфизм при создании классов
#
# Полиморфизм в ООП обрабатывает разные типы данных, принадлежащих к разным классам,
# с помощью одной и той же функции (метода). По сути одинаковым является только имя метода,
# но результаты работы одноимённых методов могут различаться.
#
# Рассмотрим пример
#
# Нам необходимо рассчитать площадь геометрической фигуры на основе полиморфизма:

class Rectangle:
    def __init__(self,a,b):
        self.a = a
       	self.b = b
    def get_area(self):
        return self.a * self.b

# Как организовать работу
#
# Откройте PyCharm и выполняйте параллельно все действия, в том числе копируйте код.
# Следите за ходом рассуждений.
#
# Итак, у нас есть класс Rectangle с двумя параметрами: ширина и высота (a и b).
# Мы можем найти площадь прямоугольника. Для этого нужно длину умножить на высоту
# (строка кода 6). Для решения используем специальный метод get_area. Он принимает
# аргумент self, то есть сам класс Rectangle и возвращает произведение атрибута a
# (ширина) на b (высота).
#
# Создадим файл rectangle_2.py в отдельной директории в папке (назовём её python_practice).
# Выполним импорт класса Rectangle:

from rectangle import Rectangle

#далее создаём два прямоугольника
rect_1 = Rectangle(3,4)
rect_2 = Rectangle(12,5)
#вывод площади наших двух прямоугольников
print(rect_1.get_area())
print(rect_2.get_area())

# Что мы видим в файле rectangle_2.py:

from rectangle import Rectangle

#далее создаём два прямоугольника

rect_1 = Rectangle(3,4)
rect_2 = Rectangle(12,5)
#вывод площади наших двух прямоугольников
print(rect_1.get_area())
print(rect_2.get_area())

# Запустим наш исходный код, чтобы получить результат вычисления площади уже двух прямоугольников.
#
# Добавим в нашу программу ещё один объект, например, Square (квадрат), который принимает
# в качестве аргументов одну сторону. Добавляем данные в исходном файле rectangle.py:

class Rectangle:
    def __init__(self, a, b):
        self.a = a
        self.b = b

    def get_area(self):
        return self.a * self.b


class Square:
    def __init__(self, a):
        self.a = a

    def get_area_square(self):
        return self.a ** 2
# возведение в степень **2 (в квадрат)

# Переходим в файл rectangle_2.py и импортируем наш новый объект:

from rectangle import Rectangle, Square

#далее создаём два прямоугольника

rect_1 = Rectangle(3,4)
rect_2 = Rectangle(12,5)
#вывод площади наших двух прямоугольников
print(rect_1.get_area())
print(rect_2.get_area())

square_1 = Square(5)
square_2 = Square(10)

print(square_1.get_area_square(),
      square_2.get_area_square())

# Запустите программу и посмотрите ожидаемый результат в консоли: площадь прямоугольника
# и квадрата. Можно более лаконично выводить два квадрата: через запятую (см. 14 строчку).
#
# Теперь мы хотим в нашей программе все объекты перенести в единую коллекцию. Назовём
# фигуры (figures). Коллекция содержит список, в который и помещаем наш первый прямоугольник,
# квадрат и т. д. (см. 17 строчку). Работаем в файле rectangle_2.py:

from rectangle import Rectangle, Square

# далее создаём два прямоугольника

rect_1 = Rectangle(3, 4)
rect_2 = Rectangle(12, 5)
# вывод площади наших двух прямоугольников
print(rect_1.get_area())
print(rect_2.get_area())

square_1 = Square(5)
square_2 = Square(10)

print(square_1.get_area_square(),
      square_2.get_area_square())

figures = [rect_1, rect_2, square_1, square_2]

# Далее пройдёмся по циклу for:

print(square_1.get_area_square(),
      square_2.get_area_square())

figures = [rect_1, rect_2, square_1, square_2]
for figure in figures:
    if isinstance(figure, Square):
        print(figure.get_area_square())
    else:
        print(figure.get_area())

# Мы обходим наши фигуры по циклу, чтобы для каждой фигуры найти площадь. Обратите внимание,
# мы будем работать с прямоугольниками и квадратами с помощью разных методов:
# (get_area() и get_area_square()).
#
# Внутри цикла проверяем:
#
#         если экземпляр класса figure является квадратом, то вызываем метод get_area_square();
#         в противном случае мы обрабатываем данные для прямоугольника методом get_area().
#
# В условии есть функция isinstance, поддерживающая наследование. Функция возвращает True,
# если первый аргумент функции является экземпляром класса, где класс задается вторым
# аргументом. Иными словами, функция проверяет, принадлежит ли объект к классу.


# Еще немного о полиморфизме и магических методах на примере __eq__ и __str__
#
# Давайте рассмотрим ещё один полезный пример полиморфизма в классах Python —
# перегрузку операторов и методов.
#
# Перегрузка представляет собой изменение поведения стандартного оператора
# или метода под особенности класса.
#
# Возьмём несколько наиболее часто используемых методов:
#         __eq__ — определяет поведение оператора равенства ==;
#         __str__ — определяет поведение функции str() или вызов внутри функции print().
#
# А теперь рассмотрим примеры.
#
# Создадим файл points.py. Внутри файла определим класс Dot, который будет хранить в себе
# информацию о точках на плоскости в системе координат х, y:

class Dot:
   def __init__(self,x,y):
       self.x=x
       self.y=y

# Нам необходимо уметь сравнивать точки между собой и выводить их для пользователя.
# Соответственно переопределим методы __eq__ и __str__ внутри класса Dot.

def __eq__(self,other):
    return self.x==other.x and self.y==other.y


def __str__(self):
    return f'Dot: {self.x,self.y}'

# Теперь давайте посмотрим на поведение экземпляров класса:

p1=Dot(1,2)
p2=Dot(1,2)
print(p1==p2)
print(str(p1))
print(p2)

# В выводе увидим:
#
# True
# Dot: (1, 2)
# Dot: (1, 2)

# В первой строке видим, что точки успешно сравниваются между собой.
# Во второй и третьей строке выводится информация об экземплярах класса.
# Обратите внимание, что перегруженный метод str автоматически используется
# в функции print, поэтому писать его необязательно.

# ( см. дальше C1_10_praktikum.py )






