# Весёлые картинки закончились. С кодом работаем по-взрослому
#
# Представим, что нам нужно создать множество однотипных объектов. Например,
# у нас есть пользователи нашего сервиса PetFriends (в прототипе социальной
# сети для проекта «Дом Питомца»). Мы хотим хранить данные о них, плюс
# дополнительно хранить предлагаемые товары для питомцев, а кроме них —
# соответствующие функции, которые рассчитывают, например, доступность.

user_peter = {
    "name": "Peter",
    "email": "peterrobertson@mail.com",
    "created_at": "2019-05-05",
    "is_email_verified": True,
    "purchases": ["Egg", "Spam", "Hat", "Knife", "Shield", "Book of Knight secrets"],
}

user_julia = {
    "name": "Julia Donaldson",
    "email": "juliadonaldson@mail.com",
    "created_at": "2019-06-13",
    "is_email_verified": True,
    "purchases": ["Egg", "Spam", "Magic Brush"],
}

product_eggs = {
    "name": "Egg",
    "category": "food",
    "is_available": False,
    "quantity_in_stock": 0,
    "vendor": "Dark Knight LTD",
    "manager": "William The Conqueror",
}


def is_product_available(product):
    return True if product["quantity_in_stock"] > 0 else False

# Мы видим, что, если мы продолжим создавать такие словари, скоро будет сложно
# справиться с их количеством и поддерживать их единообразие. Если мы захотим
# переименовать ключ, с которым работает какая-то из соответствующих объекту
# функций, то будет легко допустить ошибку, пропустив его в одном из мест,
# ведь структура многократно дублируется в разных местах кода. При введении
# более сложной логики запутаться станет ещё легче.
#
# Это одна из проблем, которую можно решить с помощью классов.
#
# Класс — это заготовка для создания объектов. После того как вы описали свой
# класс, вы сможете создавать любое количество объектов класса, которые будут
# устроены единообразно. Такие объекты называются экземплярами.
#
# Именно так мы избежим проблемы десятков одинаково устроенных словарей,
# с которой столкнулись выше.
#
# Фактически класс — это описание интересующих нас особенностей какой-то абстракции,
# на основе которого будут создаваться конкретные реализации этой абстракции.
#
# Мы помним, что нам нужна абстракция «пользователь». Давайте создадим такой класс.
#
# Для создания класса используем ключевое слово class:

class User:
    pass  # этот класс ничего не делает

# Ключевое слово class работает так же, как ключевое слово def для создания
# функций, только в данном случае дальше идёт объявление класса.
#
# В отличие от переменных, для наименования которых в Python принято использовать
# snake_case, для классов используют CamelCase — регистр, в котором слова склеены
# между собой и каждое начинается с заглавной буквы.
#
# Пока что мы создали класс, в котором ничего не происходит. Мы использовали
# ключевое слово pass, которое используется как плейсхолдер для пустых классов
# и функций, чтобы избежать синтаксической ошибки.
#
# Как мы обсуждали выше, классы используются как фабрика для создания объектов.
# Давайте создадим экземпляры нашего класса User, соответствующие
# двум пользователям, Питеру и Юлии, и укажем их имена.

class User:
    pass

peter = User()
peter.name = "Peter Robertson"

julia = User()
julia.name = "Julia Donaldson"

print(peter.name)
print(julia.name)

# Вывод:
#
# Peter Robertson
# Julia Donaldson
#
# Для создания экземпляра класса мы просто вызвали класс, как функцию, с помощью скобок.
# Дальше, чтобы сохранить в экземпляр какие-то данные, мы использовали уже знакомую нам
# нотацию точки. Мы уже сталкивались с ней, когда обращались к методам и, например,
# импортированным из других пакетов константам. Здесь .name — это атрибут экземпляра
# нашего класса. Атрибуты позволяют хранить произвольные данные в привязке к конкретному
# экземпляру (сам по себе класс тоже может хранить какие-то данные, но об этом позже).
#
# В этом смысле классы и экземпляры классов работают так же, как модули: они создают
# пространство имён, в котором доступны различные сущности. Как мы видим, после создания
# экземпляра мы смогли каждому задать произвольный атрибут и положить в него уникальное
# значение. При этом пространства имён наших экземпляров остаются независимыми:

peter.email = "peterrobertson@mail.com"
print(peter.email)
print('\n')
# print(julia.email)

# peterrobertson@mail.com
# Traceback (most recent call last):
#   File "User/path/script.py", line 20, in <module>

# print(julia.email)
# AttributeError: 'User' object has no attribute 'email'
#
# Создание произвольного атрибута у одного экземпляра не привело
# ни к каким изменениям у второго, что логично.
#
# Можно сравнить классы с формой и инструкцией для выпекания пирогов,
# а экземпляры — с конкретными испечёнными пирогами. Если вы откусили
# кусок от одного, это никак не повлияет на следующие.
#
# Дальше мы увидим, как правильно решить нашу изначальную проблему
# с повторяющимися по структуре словарями.

# Задание 1.4.1
# Что из этого является «настоятельно рекомендуемым» названием для класса в Python?

# cartState
# CartState             верно
# cart_state

# Задание 1.4.2
# Как создать экземпляр класса User с названием chris?
# User(chris)
# chris = User
# User.chris
# chris = User()        верно

# Задание 1.4.3
# Как создать атрибут phone_number у объекта peter?
# peter.phone_number = "+79116451238"       верно
# peter["phone_number"] = "+79116451238"
# peter.phone_number == "+79116451238"

#
# Мы можем задавать атрибуты, которые будут доступны из любого объекта, причём
# без дополнительных действий. Для этого их надо объявлять прямо внутри класса:

class User:
    number_of_fingers = 5
    number_of_eyes = 2

lancelot = User()
print("Количество пальцев у lancelot : ", lancelot.number_of_fingers)
print("Количество глаз у lancelot : ", lancelot.number_of_eyes)

# Вывод:
#
# 5
# 2

# ( см. дальше C1_5__init__method.py )
