#
# C1.6. Методы и функции

# Мы умеем задавать структуру для наших данных с помощью атрибутов. Но часто у объектов
# есть связанная с ними логика, которую мы хотим реализовывать в привязке к таким объектам
# — и это тоже можно реализовать с помощью классов. Для этого используются методы.
#
# Метод — это всего лишь функция, реализованная внутри класса, и первым аргументом принимающая self:

class Product:
    def __init__(self, name, category, quantity_in_stock):
        self.name = name
        self.category = category
        self.quantity_in_stock = quantity_in_stock

    def is_available(self):
        return True if self.quantity_in_stock > 0 else False


# Здесь и __init__, и is_available — это методы. По умолчанию первым аргументом во все
# методы класса подается self — именно так метод получает доступ к экземпляру класса.
# Мы рассмотрим исключения позже в течение курса. При этом, чтобы вызвать исполнение
# метода, передавать self уже не нужно:

eggs = Product("eggs", "food", 5)
print(eggs.is_available())


# Вывод:
#
# True

# Для вызова метода, как и для вызова функции, используются круглые скобки.
# Разница между методом и функцией только в том, что
# метод вызывается от конкретного объекта и реализован внутри класса,
# а функция работает сама по себе.
#
# Пусть мы хотим обрабатывать некоторые события из уже известных нам логов событий.
# Создадим класс с конструктором:

class Event:
    def __init__(self, timestamp, event_type, session_id):
        self.timestamp = timestamp
        self.type = event_type
        self.session_id = session_id


# Допустим, мы уже распарсили наши логи и получили список словарей вроде такого:

events = [
    {
        "timestamp": 1554583508000,
        "type": "itemViewEvent",
        "session_id": "0:NynteeXG:MYlskrqZbcmXNSFEJaZIsNVGeDLLpmct",
    },
    {
        "timestamp": 1555296337000,
        "type": "itemViewEvent",
        "session_id": "0:NynteeXG:MYlskrqZbcmXNSFEJaZIsNVGeDLLpmct",
    },
    {
        "timestamp": 1549461608000,
        "type": "itemBuyEvent",
        "session_id": "0:NynteeXG:MYlskrqZbcmXNSFEJaZIsNVGeDLLpmct",
    },
]

# Давайте для каждого события в списке создадим соответствующий ему объект
# с помощью конструктора, как мы уже делали. А чтобы убедиться, что
# объект создаётся, выведем на печать какой-нибудь из атрибутов:

for event in events:
    event_obj = Event(timestamp=event.get("timestamp"),
                      event_type=event.get("type"),
                      session_id=event.get("session_id"))
    print(event_obj.timestamp)


# Вывод:
#
# 1554583508000
# 1555296337000
# 1549461608000

# Здесь мы использовали метод словаря .get(), который возвращает значение ключа
# и не вызывает ошибку, если такого ключа в словаре нет.
#
# Вместо такого явного разбора словаря в цикле мы могли бы задать нашему классу
# метод, который позволяет инициализировать наш объект напрямую.
#
# Для этого давайте поправим объявление нашего класса и зададим для каждой переменной
# её значение по умолчанию, чтобы мы могли инициализировать объект без заполнения.
# Это делается с помощью указания значений по умолчанию сразу после названия аргумента:

class Event:
    def __init__(self, timestamp=0, event_type="", session_id=""):
        self.timestamp = timestamp
        self.type = event_type
        self.session_id = session_id

    # Отлично, а теперь добавим метод. Не забываем, что
    # метод принимает на вход self первым аргументом.
    def init_from_dict(self, event_dict):
        self.timestamp = event_dict.get("timestamp")
        self.type = event_dict.get("type")
        self.session_id = event_dict.get("session_id")


# Метод идёт с отступом и должен быть объявлен внутри класса.

# После этого мы скрыли реализацию логики от пользователя — то есть
# нам уже неважно, как это работает, мы знаем, что можем подать на вход
# словарь с нужными ключами, и всё будет работать само.

for event in events:
    event_obj = Event()
    event_obj.init_from_dict(event)
    print(event_obj.timestamp)


# Вывод:
#
# 1554583508000
# 1555296337000
# 1549461608000

# Методы облегчают работу с объектами класса, предоставляя готовую и удобную логику.

# Как вы уже заметили, стандартные типы данных Python также предоставляют
# готовый набор методов для работы с ними. Например, у строки есть метод .split(),
# который мы уже использовали — и это именно метод в полноценном смысле:
# где-то внутри Python определён класс строк и их метод.

# Важно перевести полученное знание в умение!
#
# Для этого мы рекомендуем воспроизвести весь код в PyCharm.

class Event:
    def __init__(self, timestamp, event_type, session_id):
        self.timestamp = timestamp
        self.type = event_type
        self.session_id = session_id


events = [
    {
        "timestamp": 1554583508000,
        "type": "itemViewEvent",
        "session_id": "@:NynteeXG:MYlskrqZbcmXNSFEJaZIsNVGeDLLpmct",
    },
    {
        "timestamp": 1555296337000,
        "type": "itemViewEvent",
        "session_id": "@:NynteeXG:MYlskrqZbcmXNSFEJaZIsNVGeDLLpmct",
    },
    {
        "timestamp": 1549461608000,
        "type": "itemBuyEvent",
        "session_id": "@:NynteeXG:MYlskrqZbcmXNSFEJaZIsNVGeDLLpmct",
    },
]

for event in events:
    event_obj = Event(timestamp=event.get("timestamp"),
                      event_type=event.get("type"),
                      session_id=event.get("session_id"))
    print(event_obj.timestamp)


# Давайте перед тем, как приступим к работе с наследованием,
# вернёмся к уже затронутому ранее понятию — инкапсуляции.
#
# Инкапусляция — это один из принципов ООП, который говорит нам о том, что
# поля и методы должны быть одной целой системой. Иначе говоря,
# работаем с полями класса только через методы.

# Сначала вспомним, как мы только что работали с полями класса:

# Пример неправильного кода

# Создаём неправильный класс
# """
class Human:
    # класс человек с полем возраста
    age = None

    def __init__(self, age=4):
        self.age = age


h = Human()
h.age = 15  # (Так делать лучше не стоит, если вы хотите когда-нибудь найти работу)
print(h.age)  # и так тоже


# """
#
# Но что же здесь неправильного, спросите вы? Сейчас мы всё разберём подробно на примере,
# и вы всё поймёте. Сначала спросите себя, а может ли человеку быть -20 лет? А «abcde» лет?
# Ну, конечно же, нет. Но при таком подходе, оставляя поля класса открытыми, вы оставляете
# их абсолютно беззащитными перед внешним воздействием. За этим и нужна инкапсуляция.
# Она говорит нам, что мы должны беречь наши классы и обрабатывать каждое обращение к его полям.
# Сейчас вы увидите, что нужно исправить, пока ещё не поздно.

# Более правильный пример

# Исправим наш предыдущий код.
class Human:
    age = None

    def __init__(self, age=4):
        self.age = age

    # добавляем геттер - специальный метод для получения поля
    def get_age(self):
        return self.age

    # добавляем сеттер - специальный метод для установки нового значения
    def set_age(self, age):
        # проверяем условия, что человеку должно быть больше 0 лет и его возраст - целое число
        if age > 0 and isinstance(age, int):
            self.age = age


h = Human()
h.set_age(15)
print(h.get_age())

# Здесь мы уже контролируем обращение к полям класса.
# Мы добавили специальные методы: геттеры и сеттеры.
#
# Геттеры — пишется так: get_<имя поля>. Геттер просто возвращает значение поля
# и не принимает никаких аргументов.
#
# Сеттер — пишется так: set_<имя поля>. Сеттер принимает один аргумент — значение,
# которое он должен установить в поле.
#
# В принципе на этом можно сказать, что с инкапсуляцией мы познакомились. Для начала
# такого понимания хватит. Мы ещё вернёмся к ней, когда будем изучать декораторы класса.
#
# Теперь у нас уже есть достаточно инструментов, чтобы почувствовать, зачем нужны классы:
# по факту, классы — это связка между определённой структурой данных, хранящихся в атрибутах,
# и логикой, которая непосредственно относится к ним. Плюс ко всему мы познакомились
# с нашей первой концепцией ООП — инкапсуляцией, которая говорит нам, что
# поля класса должны обрабатываться только через специальные методы — геттеры и сеттеры.

# Задание 1.6.1
# Верно ли то, что метод принимает первым аргументом self?
# False
# True      верно

# Задание 1.6.2
# Функция вызывается от конкретного объекта, а метод работает сам по себе. Правда или нет?
# True
# False     верно

# ( см. дальше C1_7_inheritance.py )
