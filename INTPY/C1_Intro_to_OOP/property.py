# Затрагивая тему инкапсуляции, почти во всех учебниках толком ничего не говорится
# о прекрасном встроенном декораторе @property.
#
# Напоминаю, что декораторы — это определённые штуки в языке Python, которые позволяют
# менять поведение функции (или, как вы сейчас убедитесь, и метода), не меняя её исходного
# кода. В прошлом юните мы с помощью декоратора писали статические методы, вспоминаем.
#
# @property очень классный декоратор, он-то, по сути, и обеспечивает нам прямой путь
# к инкапсуляции, позволяя объединить методы и поля. Давайте же скорее взглянем
# на пример кода с использованием этого декоратора.

class Dog:
    _happiness = 10
    def __init__(self, name, age):
        self.name = name
        self.age = age
    @property
    def human_age(self):
        return self.age * 7.3
    # добавим новое поле — шкала счастья
    @property
    def happiness(self):
        return self._happiness
    # с помощью декоратора setter мы можем неявно передать во второй
    # аргумент значение, находящееся справа от равно, а не закидывать это
    # значение в скобки, как мы это делали в модуле C1, когда не знали о
    # декораторах класса
    @happiness.setter   # пусть счастье питомца измеряется шкалой от 0 до 100
    def happiness(self, value):
        if value >= 0 and value <= 100:
        # if 0 <= value <= 100:             # или даже так
            self._happiness = value
        else:
            raise ValueError("Индекс счастья должен быть от 0 до 100")



# muhtar = Dog("Мухтар", 5)
# print(muhtar.human_age)

# Вдобавок к комментариям в коде важно отметить, что декораторы .setter должны называться
# так же, как и метод, помеченный декоратором @property, для которого вы хотите устанавливать
# значение, иначе интерпретатор выдаст ошибку.
#
# Благодаря декоратору @.setter можно использовать инкапсуляцию, сохраняя привычное нам обращение
# к полю через точку, а установку нового значения через =. Вот такой вот магический декоратор @property.
