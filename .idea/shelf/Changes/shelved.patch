Index: INTPY/C3_modules_import_files_data/file_open_write.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import os\r\n\r\nf= open('test.txt', 'a', encoding='utf8')\r\n\r\n# Запишем в файл строку\r\n# f.write(\"This is a test string\\n\")\r\n# f.write(\"This is a new string\\n\")\r\n#\r\n# f.write(\"Это текстовая строка\\n\")\r\n# f.write(\"А это еще одна текстовая строка\\n\")\r\nf.write(\"\\nИ вот еще дополнительная текстовая строка\\n\")\r\nf.write(\"Пожалуй, закроем теперь этот файл\\n\")\r\nf.write(\"=================================\")\r\nf.close()\r\n\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/INTPY/C3_modules_import_files_data/file_open_write.py b/INTPY/C3_modules_import_files_data/file_open_write.py
--- a/INTPY/C3_modules_import_files_data/file_open_write.py	(revision aceb5b78e04eb6a1b997e1467f1364daa24c3211)
+++ b/INTPY/C3_modules_import_files_data/file_open_write.py	(date 1661945680102)
@@ -1,16 +1,62 @@
 import os
 
-f= open('test.txt', 'a', encoding='utf8')
+f= open('test.txt', 'w', encoding='utf8')
 
 # Запишем в файл строку
-# f.write("This is a test string\n")
-# f.write("This is a new string\n")
+f.write("This is a test string\n")
+f.write("This is a new string\n")
 #
 # f.write("Это текстовая строка\n")
 # f.write("А это еще одна текстовая строка\n")
-f.write("\nИ вот еще дополнительная текстовая строка\n")
-f.write("Пожалуй, закроем теперь этот файл\n")
+# f.write("\nИ вот еще дополнительная текстовая строка\n")
+# f.write("Пожалуй, закроем теперь этот файл\n")
 f.write("=================================")
 f.close()
+f = open('test.txt','r', encoding='utf8')
+print(f.read(25))
+print(f.read())
+f.close()
+
+f = open('test.txt', 'a', encoding='utf8')  # открываем файл на дозапись
+
+sequence = ["other string\n", "123\n", "test test\n"]
+f.writelines(sequence)  # берёт строки из sequence и записывает в файл (без переносов)
+
+f.close()
+
+# Попробуем теперь построчно считать файл с помощью readlines:
+
+f = open('test.txt', 'r', encoding='utf8')
+
+print(f.readlines())  # считывает все строки в список и возвращает список
+
+f.close()
+
+# Метод f.readline() возвращает строку (символы от текущей позиции до символа переноса строки):
+
+f = open('test.txt', 'r', encoding='utf8')
+
+print(f.readline())  # This is a test string
+print(f.read(4))  # This
+print(f.readline())  #  is a new string
+#
+# f.close()
+
+print("###########################################")
+
+f = open('test.txt')
+for line in f:
+    print(line, end=' ')
+f.close()
+
+##############################################################3
+
+with open("test.txt", 'rb') as f:
+    a = f.read(10)
+    b = f.read(23)
+    print(a)
+    print(b)
+
+print(f.read(3))  # Error!
 
 
Index: INTPY/C4_Algorythms_Data_structures/C4_2_O-notation.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/INTPY/C4_Algorythms_Data_structures/C4_2_O-notation.py b/INTPY/C4_Algorythms_Data_structures/C4_2_O-notation.py
new file mode 100644
--- /dev/null	(date 1662031404822)
+++ b/INTPY/C4_Algorythms_Data_structures/C4_2_O-notation.py	(date 1662031404822)
@@ -0,0 +1,272 @@
+########################################################################
+# C4.2. О-нотация
+########################################################################
+# В повседневной жизни мы так или иначе пользуемся алгоритмами: алгоритмы приготовления ужина,
+# алгоритм составления пути от дома до любимого места в городе, алгоритм уборки квартиры и
+# многие другие. Мы, конечно, обычно их так не называем, но, в общем-то, выполняем некоторую
+# последовательность действий.
+#
+# Любую цель из представленных выше (ужин, местоположение в городе, чистая квартира) можно
+# выполнить большим количеством способов. И, как правило, мы выбираем наиболее эффективный
+# способ это сделать. Эффективность уборки квартиры напрямую связана с количеством времени,
+# которое было затрачено на неё. Чем быстрее мы выполним все запланированные действия, тем
+# более эффективен будет наш «алгоритм». С другой стороны, приготовление ужина неизбежно
+# связано с количеством загрязнённой посуды во время готовки. Большое её количество будет
+# нас расстраивать, потому что мытьё посуды обычно входит в план приготовления ужина. :)
+# И пусть время здесь уже не играет значимую роль, если нет задачи приготовить как можно
+# быстрее, очень весомым становятся вот такие «побочные» эффекты наших действий.
+#
+# Разрезая круглую пиццу по кусочку от центра, мы должны сделать n разрезов, если мы хотим
+# получить n кусочков. Однако можно пиццу резать каждый раз вдоль диаметра (от края до края).
+# И пусть мы всегда получим чётное количество кусочков, но сможем сделать это намного быстрее!
+
+########################################################################
+#  Задание 4.2.1
+# Сравните количество разрезов пиццы для получения 16 кусочков при использовании
+# одного и другого способа. Найдите отношение p/q, если p — количество разрезов
+# от центра, q — количество разрезов по диаметру.
+# Ответ: 2
+
+########################################################################
+# С алгоритмами, которые реализуют программисты, происходит абсолютно то же самое, только
+# наши «инструменты» — не кастрюли и швабры, а переменные и данные. По аналогии критериями
+# эффективности или, иначе, сложности алгоритмов являются временной и пространственный.
+#
+# Временная сложность алгоритма говорит нам о том, какое количество времени может потребоваться
+# для выполнения этого алгоритма. И, естественно, она зависит от размера входных данных — точно
+# так же,  как уборка от площади квартиры.
+#
+# Пространственная сложность алгоритма связана с количеством памяти, которое он использует
+# в ходе своей работы. Здесь работает та же аналогия с приготовлением ужина — зависимость
+# от количества посуды, которая загрязняется из-за готовки. Здесь и далее в основном будем
+# говорить о временной сложности алгоритмов и в некоторых случаях затрагивать пространственную,
+# когда это будет необходимо.
+
+########################################################################
+# Алгоритмы различной сложности
+########################################################################
+
+# Самый простой, самый эффективный алгоритм, к которому все стремятся,
+# — это константный алгоритм.
+
+# Константным, или постоянным по времени, называется алгоритм, который выполняет
+# необходимое действие всегда за одинаковое количество времени (с точностью до
+# небольшого множителя, вызванного техническими характеристиками вычислительной машины).
+
+# К таким «алгоритмам» относят очень простые операции:
+#
+#         присваивание,
+#         арифметические операции,
+#         логические операции,
+#         сравнение объектов,
+#         некоторые другие действия, которые мы рассмотрим в ходе изучения модуля.
+
+# Более сложные алгоритмы уже могут зависеть от количества входных данных. Например,
+# если вам нужно найти максимальный элемент в списке, то самый простой способ —
+# пройтись по всем элементам списка. Здесь константного времени уже не хватит,
+# потому что велика разница между поиском максимального среди 3 элементов
+# или среди 3 миллионов элементов.
+
+# Однако больше ни от чего такой поиск не зависит — чем больше элементов, тем больше
+# времени нужно, и, более того, количество времени возрастает в то же самое количество
+# раз, как и размер списка. Такие алгоритмы называют линейными. Если продолжать аналогию
+# с ужином, то «пространственная сложность» приготовления ужина зависит от количества
+# гостей на нём. Чем больше гостей, тем больше тарелок придётся мыть после него.
+
+# Бывают ситуации, когда алгоритмы могут работать быстрее, чем линейные:
+# самые распространённые — это логарифмические алгоритмы. Их название напрямую связано
+# с тем, как возрастает временная сложность алгоритма с ростом размера входных данных.
+
+# В computer science принято основание логарифма считать равным двум (двоичный логарифм),
+# если не сказано иное. Здесь ( https://www.berdov.com/docs/logarithm/what/ )
+# можно вспомнить про логарифмы.
+
+# Удивительно, но и вполне естественно, что логарифмические алгоритмы также встречаются
+# в бытовой сфере. Например, вам нужно разрезать лист А4 на 16 частей. Можно сделать
+# разметку и отрезать кусочек за кусочком — такой алгоритм будет линейным, но можно
+# разрезать пополам, потом сложить их и разрезать сразу оба. Получившиеся четверти
+# снова сложить и снова разрезать, но уже сразу 4 штуки и т. д.
+# — это и есть логарифмический алгоритм.
+
+########################################################################
+#  Задание 4.2.2
+# Во сколько раз быстрее будет разрезать листок А4 «логарифмически», чем «линейно»?
+# В ответ запишите отношение (округлив до целого, если необходимо) p/q, где p —
+# количество разрезов по кусочкам, а q — количество разрезов, накладывая части друг
+# на друга после каждого разреза. (рис.1 и рис.2 - лист А4 на 16 кусочков)
+#  В линейном случае предполагается, что каждый отрезок разрезается отдельно.
+# Ответ: 6
+########################################################################
+
+# Естественно, бывают алгоритмы и сложнее. Линейный алгоритм является частным случаем
+# полиномиальных алгоритмов, а всех их объединяет, что для обработки объектов входных
+# данных (чисел, например) требуется операций.
+
+########################################################################
+# Пример
+########################################################################
+# Чтобы расставить книги в алфавитном порядке нам понадобится примерно n**2 операций.
+#
+# Почему n**2 ? Давайте попробуем посчитать на примере расстановки 10 книг в алфавитном
+# порядке (слева направо):
+#
+    # 1. Сначала мы должны найти самую первую книгу: просматриваем одну за одной, чтобы
+    #         найти, какая должна стоять первой. Выбираем любую из 10 и сравниваем с каждой,
+    #         чтобы убедиться, что она должна быть первой, или установить, что сравниваемая
+    #         книга должна стоять левее. Всего проводим 9 сравнений. Ставим её на полку.
+    # 2. Берём произвольно следующую книгу (вторую) из оставшихся девяти. Для неё
+    #         проводим такую же операцию — сравниваем с оставшимися 8. Таким образом
+    #         имеем ещё 8 сравнений.
+    # 3. Берем N-ную книгу из 10. Предполагается, что к этому моменту мы уже поставили
+    #         на полку N-1 книгу. Для сравнения c N-ой у нас останется 10-N книг. А значит,
+    #         столько же сравнений.
+    # 4. И, наконец, когда остаётся только 2 книги, нам нужно сделать только одно сравнение.
+    #
+    # 5. И для последней книги мы не должны ничего сравнивать, поэтому просто ставим на полку
+    #         — имеем 0 сравнений. После этого завершаем работу «алгоритма».
+#
+# Проведём расчёты общего количества сравнений. Имеется операций взятия книги и сравнения
+# с оставшимися. В нашем примере — это десять — столько раз мы берём произвольную книгу из
+# «кучи» и сравниваем с нерасставленными. Сложим все сравнения, которые мы делали все эти 10 раз:
+
+#               9 + 8 + 7 + 6 + 5 + 4 + 3 + 2 + 1 + 0
+
+# В математике такая последовательность чисел называется арифметической прогрессией (каждый
+# последующий член последовательности отличается от предыдущего на постоянное число).
+# Существует формула для нахождения суммы членов арифметической прогрессии: мы должны найти
+# среднее арифметическое первого и последнего членов прогрессии и умножить на количество всех членов.
+
+# Юный Карл Гаусс (известнейший математик) решил похожую задачку ещё в 10 лет! Здесь
+# ( https://zen.yandex.ru/media/math4u/summa-chisel-ot-1-do-100-5c92467fd8c70400b330e166 )
+# можно почитать, как он это сделал.
+#
+# Для нашей арифметической прогрессии имеем:
+
+#           (9 + 0) / 2 * 10 = 45
+
+# Это общее количество операций сравнения, которое мы должны сделать, чтобы расставить
+# книги в произвольном порядке. А что, если у нас не 10 книг, а какое-то очень большое N ?
+# Давайте попробуем обобщить эту формулу. Здесь 9 — это общее количество книг в «куче»
+# минус единица (потому что нам не нужно сравнивать книгу с самой собой). Для произвольно
+# большого количества книг это число будет равно N - 1. Найденное среднее арифметическое
+# мы должны умножить на количество книг в куче согласно формуле:
+
+#           (N - 1 + 0) / 2 * N
+
+# Разомнём «математические» мышцы и раскроем скобки, упростив это выражение:
+
+#           0.5N**2 - 0.5N
+
+# Вспомним, что мы искали что-то похожее на n**2, и мы нашли! Конечно, здесь есть
+# множитель перед квадратом N да ещё и дополнительное слагаемое. Стоит сказать,
+# что n**2 только оценка сложности. Для анализа алгоритмов нам, как правило, не
+# нужно знать точный множитель, а находить только общую зависимость от входных данных.
+
+########################################################################
+# Алгоритмическая троица: «О» большая, омега, тета
+########################################################################
+
+# Становится сложно? Сейчас будет ещё немного сложнее, но можем гарантировать, что
+# это оправдано. Ведь действительно, если программист хочет писать эффективные программы,
+# он должен понимать, по каким критериям оценивать эту эффективность. И чем точнее эти
+# критерии, тем правильнее будет оценка сложности программы. Сначала может показаться,
+# что в web-приложениях это не является столь необходимым, но, как можно увидеть позже,
+# это часто играет решающую роль при работе с базой данных. Согласитесь, что гораздо
+# быстрее выгрузить один раз все данные, а потом их обрабатывать, чем запрашивать объекты
+# один за другим. Допустим, приехали вы в ресторан. Как будет быстрее? Заказать всё сразу
+# (но, например, попросить приносить блюда в определённом порядке) или после завершения
+# каждого блюда ждать официанта, чтобы заказать что-то ещё, он в свою очередь должен
+# сходить на кухню, передать заказ поварам, а также внести заказ в кассовый терминал,
+# что потребует от него поиска вашего счёта и ещё множества-множества действий.
+# Кажется, что ответ очевиден.
+#
+# Вернёмся к алгоритмам.
+#########################################################################
+#  Для оценки сложности алгоритмов вводятся 3 математические величины:  #
+# ------------------------------------------------------------------    #
+#     «О»     большая   — верхняя оценка сложности алгоритма;           #
+#     «Ω»     (омега)   — нижняя оценка сложности;                      #
+#     «Θ»     (тета)    — точная оценка сложности.                      #
+# ------------------------------------------------------------------    #
+#########################################################################
+
+# Для одного и того же алгоритма часто бывает необходимо знать, как он работает
+# в худшем случае, и об этом нам говорит «О» большая. Эта оценка указывает на то,
+# хуже чего алгоритм точно не будет работать. Однако входные данные не всегда самые
+# плохие. И даже наоборот — встречаются данные, на которых алгоритм работает «как по
+# маслу», может быть, даже ничего с ними не делает кроме какого-то минимума. Если
+# обратиться к предыдущему примеру с расстановкой книг. Если мы взяли случайную книгу
+# из кучи нерасставленных, и она оказалась самой левой (в алфавитном порядке), то нам
+# всё равно нужно сравнить её с остальными, чтобы убедиться в этом.
+
+# Про этот случай нам говорит нижняя оценка сложности — оценка работы алгоритма в самом
+# лучшем из возможных случаев. И чтобы совсем не отвертеться, существуют точные оценки
+# сложности — ни шага влево, ни шага вправо — алгоритм будет работать именно с этой
+# сложностью. В среднем, конечно. :) Это оценка «Θ» (тета). Как правило, мы будем
+# оценивать алгоритмы по верхней границе, с помощью «О» большой, чтобы быть уверенным,
+# что медленнее алгоритм работать не будет. Более того, допуская некоторую математическую
+# вольность, сложности как в среднем, так и в лучшем случае обозначать через O(n),
+# дополнительно указывая, к какому случаю это относится.
+#
+# Мы рассматривали ранее примеры различных алгоритмов — константные, логарифмические,
+# линейные. При помощи символа «О» можно записать так называемую асимптотическую
+# сложность алгоритма. Такое обозначение имеет сильную математическую базу, но для
+# нас это важно тем, что это удобная краткая запись. Общепринято оценивать, насколько
+# «проблемный» алгоритм, именно с помощью такого символа.
+
+#########################################################################################
+# Сложность алгоритма 	|    О-нотация 	  |  Примеры                                    #
+# ------------------------------------------------------------------------------------- #
+# Константная 		    |    O(1)         |   Сложение, присваивание                    #
+#-------------------------------------------------------------------------------------- #
+# Логарифмическая 	    |   O(log(n))     |  Разрезание бумаги на части                 #
+--------------------------------------------------------------------------------------- #
+# Линейная 		        |    O(n)         |   Поиск максимального элемента из списка    #
+--------------------------------------------------------------------------------------- #
+# Квадратичная 		    |    O(n**2)      |   Расстановка книг в алфавитном порядке     #
+--------------------------------------------------------------------------------------- #
+# Полиномиальная 		|    O(n**k)      |   Про такие алгоритмы лучше забыть          #
+--------------------------------------------------------------------------------------- #
+# Факториальная 		|    O(n!)        |  А такие наводят ужас на всех программистов #
+#########################################################################################
+
+########################################################################
+# Зачем усложнять про сложности
+
+# И всё-таки зачем?! Если этот вопрос вас ещё до сих пор мучает, давайте посмотрим,
+# как работают алгоритмы (в условных единицах) различной сложности с некоторыми
+# примерами размеров данных.
+
+Сложность/размер входных данных     n=5     n=10        n=20            n=30
+O(1)                                1       1           1               1
+O(log(n))                           2       3           4               4
+O(n)                                5       10          20              30
+O(n**2)                             25      100         400             900
+O(n!)                               120     3628800     243290200       2652528598
+                                                        8176640000      1219106821
+                                                                        7601719009280
+
+# Вот это число слева внизу и пугает людей. И не зря. Представьте, что это количество
+# микросекунд, коих в секунде миллион. Если перевести это число в миллиарды лет, то
+# получится 8411113007. Словами это число даже проговорить сложно. Конечно, даже опытный
+# программист вряд ли напишет алгоритм, работающий как факториал, но даже на сравнении
+# алгоритмов линейной и квадратичной сложности видна заметная разница — аж в 30 раз,
+# и это только на 30 объектах входных данных. И на числах становится видно, что даже
+# небольшие (казалось бы) изменения в алгоритме могут дать заметное уменьшение
+# сложности работы. А чтобы уметь распознавать такие тонкости, нам и нужна О-нотация!
+
+########################################################################
+
+# Задание 4.2.3
+# Во сколько раз (примерно) возрастёт время работы алгоритма сложностью O(n**2) по сравнению с
+# O(n * log(n)) на входных данных размера n = 10000? Ответ округлите до целого.
+# Помните также, что логарифм берётся по основанию 2.
+
+
+# Теме О-нотации и анализу алгоритмов с помощью неё посвящено много научных трудов и исследований.
+#
+# В дополнительных материалах ( https://lms.skillfactory.ru/assets/courseware/v1/927375069e4816047d01403cb9d9c596/asset-v1:SkillFactory+INTPY+2022+type@asset+block/%D0%94%D0%BE%D0%BF._%D0%BC%D0%B0%D1%82%D0%B5%D1%80%D0%B8%D0%B0%D0%BB._%D0%9C%D0%B0%D1%82%D0%B5%D0%BC%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5_%D0%BE%D1%81%D0%BD%D0%BE%D0%B2%D1%8B_%D0%9E-%D0%BD%D0%BE%D1%82%D0%B0%D1%86%D0%B8%D0%B8.pdf )
+# к этой теме можно найти ещё некоторые подробности, касающиеся математического фундамента,
+# на котором стоит О-нотация, а также несколько правил по анализу алгоритмов.
+
+
Index: INTPY/C5_Requests_JSON_Redis_etc/C5_2_Requests_JSON.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/INTPY/C5_Requests_JSON_Redis_etc/C5_2_Requests_JSON.py b/INTPY/C5_Requests_JSON_Redis_etc/C5_2_Requests_JSON.py
new file mode 100644
--- /dev/null	(date 1662487390957)
+++ b/INTPY/C5_Requests_JSON_Redis_etc/C5_2_Requests_JSON.py	(date 1662487390957)
@@ -0,0 +1,303 @@
+#########################################################################
+#  C5.2. Библиотека Requests и её лучший друг JSON
+#########################################################################
+
+# На момент изучения этого материала, вы уже должны знать, что такое библиотеки
+# в Python, как их установить и использовать в ваших проектах, а также вы умеете
+# пользоваться браузером. :) Это всё, что нам понадобится для изучения нового
+# материала в данном юните.
+#
+# Но перед тем, как говорить о библиотеке Requests, давайте немного поработаем
+# с браузером.
+#
+# В данном юните представлен как пример браузер Firefox. При открытии веб-страницы
+# вы получаете HTML-код этой самой страницы и такие дополнительные вещи, как стили
+# и скрипты в виде отдельных файлов и инструкций о том, как их надо соединить вместе,
+# чтобы получить полноценную картинку и функционал. О стилях и скриптах мы будем
+# говорить подробнее на нашем курсе, когда коснёмся фронтенд разработки. Сейчас же
+# остановимся только на HTML.
+#
+# HTML — это язык гипертекстовой разметки.
+#
+# Грубо говоря, это скелет самой страницы без стилей, анимаций, рекламы и т. д.
+# Страничка на чистом HTML выглядит примерно следующим образом: ( илл. )
+
+# Теперь давайте перейдём в браузер. Если мы нажмём клавишу F12, находясь на
+# каком-либо сайте, то внизу (или справа) откроется консоль разработчика.
+#
+# Давайте посмотрим, что у нас здесь есть: ( илл. )
+#
+# Для того чтобы увидеть сам HTML-код, необходимо перейти во вкладку «Инспектор». ( илл. )
+
+# Именно в этот обыкновенный текст подстраиваются все стили и анимации, и в результате
+# мы получаем то, что мы видим в браузере. Но что, если мы не хотим видеть все эти
+# картинки через браузер и постоянно заходить в консоль? Возможно ли забирать со
+# страницы лишь самую главную информацию, не ища её через браузер? Конечно же, да!
+#
+# Для этого и существуют специальные Python-библиотеки, одна из которых называется
+# Requests. Она позволяет отправлять запросы на серверы (сайты, для простоты на
+# данный момент) и получать от них ответ в виде, например, кода на HTML.
+#
+# Давайте сначала попробуем получить данные с одного интересного API, который
+# генерирует случайные тексты.
+#################################################################################
+# API (Application programming interface) — это набор публичных свойств и методов
+# для взаимодействия с другими программами, которые могут быть написаны
+# даже на другом языке программирования. API можно определить как:
+# «Ко мне можно обращаться так и так, я обязуюсь делать то и это».
+#################################################################################
+
+# Это делается очень просто — переходим по ссылке через ваш браузер. :)
+# https://baconipsum.com/api/?type=all-meat&paras=3&start-with-lorem=1&format=html
+# В итоге мы увидим примерно следующую картину: ( илл. )
+
+# Нам пришло в ответ нечто, непохожее на веб-страницы с тремя случайными текстами.
+#
+# Давайте теперь попробуем прочитать эти же тексты, но не через браузер, а через
+# наш Python-скрипт с помощью библиотеки Requests. Для этого отправим GET-запрос:
+"""
+import requests
+
+r = requests.get(
+    'https://baconipsum.com/api/?type=all-meat&paras=3&start-with-lorem=1&format=html')  # делаем запрос на сервер по переданному адресу
+print(r.content)
+"""
+# В результате работы данного кода в консоль выведется HTML-код сгенерированного текста,
+# т. к. запрос на получение странички через браузер на самом деле эквивалентен вызову
+# функции .get() (и то, и то отправляет GET-HTTP-запрос, о котором мы будем говорить
+# более подробно чуть позже на нашем курсе). ( илл. )
+
+# Ничего не напоминает? Да-да. Это всё тот же HTML-код страницы, который мы видели
+# через консоль, только полученный текстом через Python-скрипт. А знаете к чему это
+# ведёт? Это должно подталкивать нас на мысль, что возможно собирать просто огромные
+# данные с тех же самых страниц, не заходя на них и оставив скрипт работать в фоновом
+# режиме. Именно для этого и нужна библиотека Requests.
+#
+# Кстати, такие программы, которые забирают и сохраняют главную информацию с каких-либо
+# сайтов, называются парсерами, их мы будем писать в следующем юните.
+#
+# Как вы заметили, чтобы получить содержание ответа надо обратится к полю content
+# объекта response, который возвращается, когда приходит ответ от сервера через
+# библиотеку Requests. У этого объекта, на самом деле, есть много полей, например,
+# status_code, который говорит нам о том, какой вообще ответ пришёл. Давайте поменяем
+# наш код и посмотрим, что программа выведет теперь.
+
+# import requests
+
+# r = requests.get('https://baconipsum.com/api/?type=all-meat&paras=3&start-with-lorem=1&format=html')
+"""
+print(r.status_code)  # узнаем статус полученного ответа
+"""
+# Теперь при его выполнении нам в консоли должно было напечататься 200. Это означает,
+# что ответ от сервера поступил нормальный и мы можем его обрабатывать.
+#
+# Есть несколько категорий ответов, например:
+#
+# 200, 201, 202 и т. д. — ответы, которые говорят, что с запросом всё хорошо
+#           и ответ приходит правильный, т. е. его можно обрабатывать и как-либо
+#           взаимодействовать с ним. На самом деле почти все серверы всегда в ответ
+#           шлют именно ответ 200, а не какой-либо другой из этой же категории.
+# 300, 301 и т. д. — ответы, которые говорят, что вы будете перенаправлены на
+#           другой ресурс (необязательно на этом же сервере).
+# 400, 401 и т. д. — ответы, которые говорят, что что-то неправильно с запросом.
+#           Запрашивается либо несуществующая страница (всем известная 404 ошибка),
+#           либо же недостаточно прав для просмотра страницы (403) и т. д.
+# 501, 502 и т. д. — ответы, которые говорят, что с запросом всё хорошо, но вот
+#           на сервере что-то сломалось, и поэтому нормальный ответ прийти не может.
+#
+# Более подробно со всеми типами ответов можно ознакомиться здесь.
+#  https://developer.mozilla.org/en-US/docs/Web/HTTP/Status
+
+##################################################################################
+
+# Информацию с сайта мы можем получать не только в виде HTML, но и в формате JSON.
+#
+# JSON расшифровывается как JavaScriptObjectNotation, это определённый тип ответов
+# от сервера, который уже содержит только нужную нам информацию, без всяких HTML-кодов.
+# По сути своей JSON очень похож на структуры данных в Python (словари и списки),
+# но, на самом деле, его изначальной целью было сохранять состояние объектов языка
+# JavaScript (как нетрудно было догадаться из названия). Давайте посмотрим на
+# JSON-ответ, присланный нам с того же самого ресурса. Попробуем с помощью
+# библиотеки Requests обратиться по адресу.
+"""
+import requests
+
+r = requests.get('https://baconipsum.com/api/?type=meat-and-filler')  # попробуем поймать json-ответ
+print(r.content)
+"""
+# В результате в консоли мы должны будем увидеть что-то подобное: ( илл. )
+
+# Если приглядеться, то здесь можно увидеть нечто похожее на список в Python. Однако,
+# чтобы использовать полученный ответ как Python-объект, надо воспользоваться
+# дополнительной библиотекой, которая упрощает работу с JSON-ответами и может легко
+# переконвертировать ответ от сервера в Python-объекты, с которыми удобно работать.
+# Давайте поменяем наш код и превратим данный текст в список, на который он так сильно похож.
+
+
+import requests
+import json  # импортируем необходимую библиотеку
+
+r = requests.get('https://baconipsum.com/api/?type=meat-and-filler')
+texts = json.loads(r.content)  # делаем из полученных байтов Python-объект для удобной работы
+print(type(texts))  # проверяем тип сконвертированных данных
+
+for text in texts:  # выводим полученный текст. Но для того чтобы он влез в консоль, оставим только первые 50 символов.
+    print(text[:50], '\n')
+
+# После запуска скрипта увидим следующее:
+
+# Ut shankle corned beef eiusmod, brisket voluptate
+# Minim shoulder est tri-tip sed irure et drumstick
+# Ad pork chop sed, duis proident enim adipisicing a
+# Porchetta minim picanha, aliquip voluptate venison (и т.д.)
+
+# Теперь мы сделали ответ от сервера списком — структурой данных Python,
+# с которой гораздо приятнее работать, чем просто с байтами.
+#
+# Давайте посмотрим теперь на ещё один тип возвращаемых значений. Он тоже
+# будет JSON, но в данном случае он скорее будет похож на словарь.
+
+# import requests
+# import json
+
+r = requests.get('https://api.github.com')
+print(r.content)
+
+# В консоли мы увидим структуру, похожую на словарь.
+
+# Дело в том, что на самом деле это не совсем словарь. JavaScriptObjectNotation
+# (он же JSON) есть ничто иное, как правило записи JS-объектов в файл, чтобы
+# сохранять их состояния и затем загружать обратно в программу. В модуле JSON,
+# а конкретно в функции loads, за нас уже заранее обо всём позаботились.
+# В зависимости от вида полученного ответа от сервера JSON-функция сама будет
+# обрабатывать его и возвращать нужный нам объект (список или словарь). Подробнее
+# о самой нотации можно почитать вот здесь. https://www.json.org/json-en.html
+#
+# Но хватит лирики. Давайте всё же теперь сделаем его настоящим словарём.
+
+# import requests
+# import json
+
+r = requests.get('https://api.github.com')
+
+d = json.loads(r.content)  # делаем из полученных байтов Python-объект для удобной работы
+
+print(type(d))
+print(d['following_url'])  # обращаемся к полученному объекту как к словарю и попробуем
+# напечатать одно из его значений
+
+# Результатом работы программы будет:
+# https://api.github.com/user/following{/target}
+
+# Таким образом мы можем удобно превращать данные, полученные из ответа JSON,
+# в объекты структур данных Python с помощью библиотеки JSON и удобно работать
+# с ними. В следующем юните разберём более подробно получение данных из больших
+# HTML с помощью специальных библиотек для парсинга.
+#
+# Как вы могли заметить, здесь мы использовали только GET-запросы (применяли
+# функцию .get() из библиотеки requests). Однако одним из наиболее
+# распространённых запросов помимо GET является POST-запрос. Если же GET
+# используется, как правило, для получения данных (например, JSON-ответ или
+# HTML-код для браузера, как мы уже увидели), то при помощи POST-запросов
+# отправляются данные для обработки на сервер. Например, чаще всего вместе
+# с POST-запросом используются параметры (data) для записи каких-либо
+# новых данных в базу данных.
+#
+# Давайте попробуем отправить POST-запрос:
+
+import requests
+
+r = requests.post('https://httpbin.org/post', data={'key': 'value'})  # отправляем POST-запрос
+print(r.content)  # содержимое ответа и его обработка происходит так же, как и
+# с GET-запросами, разницы никакой нет
+
+# Это простенькое API копирует наш запрос и выводит о нём главную информацию.
+# Давайте посмотрим на вывод в консоль:
+
+# b'{\n  "args": {}, \n  "data": "", \n  "files": {}, \n  "form": {\n    "key": "value"\n  },
+# \n  "headers": {\n    "Accept": "*/*", \n    "Accept-Encoding": "gzip, deflate", \n
+# "Content-Length": "9", \n    "Content-Type": "application/x-www-form-urlencoded", \n
+# "Host": "httpbin.org", \n    "User-Agent": "python-requests/2.28.0", \n
+# "X-Amzn-Trace-Id": "Root=1-6317850e-67748fa828ce06f970d71e1e"\n  }, \n
+# "json": null, \n  "origin": "109.252.29.231", \n  "url": "https://httpbin.org/post"\n}\n'
+
+# Здесь мы видим, что запрос отправлен с помощью Python-requests, и нашу операционную
+# систему ("User-Agent": "Python-requests/2.7.0 CPython/3.6.6 Windows/10"),  а также,
+# приглядевшись, мы можем увидеть и наши параметры (строчка: "form": {\n "key": "value"\n }).
+# Обратите внимание, что здесь тип отправляемых нами данных указан как FORM, но многие
+# API, однако, требуют тип JSON в качестве отправляемых данных.
+#
+# Давайте посмотрим, как с помощью уже знакомой нам библиотеки отправить данные в нужном нам формате:
+
+import requests
+import json
+
+data = {'key': 'value'}
+
+r = requests.post('https://httpbin.org/post', json=json.dumps(
+    data))  # отправляем POST-запрос, но только в этот раз тип передаваемых данных будет JSON
+print(r.content)
+
+# Проверяем консоль:
+
+# b'{\n  "args": {}, \n  "data": "\\"{\\\\\\"key\\\\\\": \\\\\\"value\\\\\\"}\\"", \n
+# "files": {}, \n  "form": {}, \n  "headers": {\n    "Accept": "*/*", \n
+# "Accept-Encoding": "gzip, deflate", \n    "Content-Length": "22", \n
+# "Content-Type": "application/json", \n    "Host": "httpbin.org", \n
+# "User-Agent": "python-requests/2.28.0", \n
+# "X-Amzn-Trace-Id": "Root=1-63178716-6fee22f6687eddff2f0e0a17"\n  }, \n
+# "json": "{\\"key\\": \\"value\\"}", \n  "origin": "109.252.29.231", \n
+# "url": "https://httpbin.org/post"\n}\n'
+
+# Здесь нас интересует строчка: "JSON": "{\\"key\\": \\"value\\"}". Из неё мы
+# можем понять, что тип отправленных нами данных был именно JSON. Поле FORM же
+# у нас теперь пустое, что означает, что напрямую никаких данных мы не передавали.
+#
+# Таким образом отправляются POST-запросы через библиотеку Requests. Есть ещё
+# другие типы запросов, такие как OPTIONS, PUT, DELETE и т. д. Они используются
+# в основном в так называемых RESTful-сервисах. О них мы будем говорить подробнее
+# дальше на нашем курсе, когда сами будем писать такого рода сервис. В общем-то
+# алгоритм действия с PUT, DELETE и т.д. такой же, как и с другими двумя методами
+# (GET и POST), меняется только название вызываемой функции. Обработка и отправка
+# происходит так же, как и с уже изученными нами методами.
+#
+# Таким образом, мы научились отправлять GET- и POST-запросы с помощью библиотеки
+# Requests в Python. Как правило, разработчики используемого вами API будут
+# указывать, каким методам и типом данных нужно отправлять запросы к их серверу,
+# и будут предоставлять примеры ответов (если это, конечно, хорошее API), что
+# позволит вам легко разобраться с их сервисом.
+
+# Изучив документацию библиотеки Requests, ответьте на вопросы.
+# https://requests.readthedocs.io/en/master/
+
+# Задание 5.2.1
+# Выберите верные утверждения.
+#
+# Библиотека Requests используется только для получения HTML-кода страницы
+# Библиотека Requests может отправлять HTTP-запросы методами GET и POST №верно
+# Библиотека Requests может принимать ответы любого характера (HTML-код или JSON-ответ) #верно
+# JSON-ответ от сервера может быть интерпретирован только как словарь
+# JSON можно конвертировать в структуры данных из Python    # верно
+
+#  Задание 5.2.2
+# Функция из библиотеки JSON, которая конвертирует байты в Python-объект
+# (например, список или словарь), называется...
+
+# load
+# loads # верно
+# dump
+# dumps
+
+# Задание 5.2.3
+# Напишите программу, которая отправляет запрос на генерацию случайных
+# текстов (используйте этот сервис). Выведите первый из сгенерированных текстов.
+#
+# Решение
+#
+# import requests
+# import json
+#
+
+r = requests.get('https://baconipsum.com/api/?type=meat-and-filler')
+r = json.loads(r.content)
+print(r[0])
Index: INTPY/C4_Algorythms_Data_structures/algorythm_Deikstra.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/INTPY/C4_Algorythms_Data_structures/algorythm_Deikstra.py b/INTPY/C4_Algorythms_Data_structures/algorythm_Deikstra.py
new file mode 100644
--- /dev/null	(date 1662285833937)
+++ b/INTPY/C4_Algorythms_Data_structures/algorythm_Deikstra.py	(date 1662285833937)
@@ -0,0 +1,97 @@
+# При работе с графами одна из наиболее частых задач — поиск кратчайшего пути
+# от одной вершины к другой. Сейчас мы с вами попытаемся реализовать алгоритм,
+# позволяющий найти его.
+########################################
+# Он носит название «алгоритм Дейкстры».
+########################################
+# Его суть заключается в том, чтобы последовательно перебирать вершины одну
+# за другой в поисках кратчайшего пути до этой вершины. Вершину будем называть
+# предком для другой, если она идёт раньше по пути перемещения по рёбрам в графе.
+# Ближайший предок — это предок, имеющий прямую связь (ребро) с рассматриваемой.
+# Рассмотрим этот алгоритм также на примере взвешенного графа станций метро
+# из последней задачи.
+#
+# Для начала нам потребуется дополнительная структура данных для хранения расстояний.
+# Если вершины пронумерованы числами, то можно использовать массив, но т. к. мы имеем
+# проименованные узлы, то удобнее пользоваться словарём.
+#
+# D = {k : 100 for k in G.keys()}
+#
+# Проинициализируем словарь расстояний числами, которые заведомо больше максимального
+# расстояния в графе. Значения 100 в данной задаче нам будет более чем достаточно.
+# Одну из вершин мы должны выбрать как стартовую. Поэтому стартовая вершина будет
+# предком для всех остальных. Расстояние для неё (от неё же самой) будет равно нулю.
+# Пусть это будет «Адмиралтейская».
+#
+# D["Адмиралтейская"] = 0
+#
+# Также нам потребуется хранить словарь с булевыми значениями, в котором True — если
+# вершина просмотрена, иначе — False.
+#
+# U = {k : False for k in G.keys()}
+#
+# Далее мы должны пройти циклом из n итераций, выбирая вершину с наименьшим D среди
+# непросмотренных. Очевидно, что на первой итерации будет выбрана стартовая вершина.
+# Из неё мы должны проверить все вершины, в которые можем перейти, и в D записать
+# наименьшее расстояние до них. Пока что мы можем идти только из стартовой вершины,
+# поэтому запишутся именно эти расстояния. Стартовая вершина станет помеченной как
+# уже просмотренная. После чего начнётся поиск вершины с минимальным D из уже
+# просмотренных (куда можно добраться из стартовой). От неё также будут строиться
+# возможные ребра и проверяться минимум расстояний. И так далее, пока процесс не
+# завершится. Утверждается, что достаточно числа итераций равного количеству вершин.
+# При достижении этого алгоритм завершится корректно.
+
+
+G = {
+    "Адмиралтейская": {
+        "Садовая": 4},
+    "Садовая": {
+        "Сенная площадь": 4,
+        "Спасская": 3,
+        "Адмиралтейская": 4,
+        "Звенигородская": 5},
+    "Сенная площадь": {
+        "Садовая": 4,
+        "Спасская": 4},
+    "Спасская": {
+        "Садовая": 3,
+        "Сенная площадь": 4,
+        "Достоевская": 6},
+    "Звенигородская": {
+        "Пушкинская": 3,
+        "Садовая": 5},
+    "Пушкинская": {
+        "Звенигородская": 3,
+        "Владимирская": 4},
+    "Владимирская": {
+        "Достоевская": 3,
+        "Пушкинская": 4},
+    "Достоевская": {
+        "Владимирская": 3,
+        "Спасская": 6}
+}
+
+D = {k: 100 for k in G.keys()}  # расстояния
+D["Адмиралтейская"] = 0
+start_k = 'Адмиралтейская'  # стартовая вершина
+D[start_k] = 0  # расстояние от неё до самой себя равно нулю
+U = {k: False for k in G.keys()}  # флаги просмотра вершин
+
+for _ in range(len(D)):
+    # выбираем среди непросмотренных наименьшее по расстоянию
+    min_k = min([k for k in U.keys() if not U[k]], key=lambda x: D[x])
+
+    for v in G[min_k].keys():  # проходимся по всем смежным вершинам
+        D[v] = min(D[v], D[min_k] + G[min_k][v])  # минимум
+    U[min_k] = True  # просмотренную вершину помечаем
+
+if __name__ == '__main__':
+    for k, v in D.items():
+        print(k, ':', v)
+# Результат работы программы можно увидеть в словаре D.
+
+# В нём отражено кратчайшее расстояние от «Адмиралтейской» до станции,
+# которая задаёт ключ.
+#
+# Таким образом мы реализовали тот же самый алгоритм, который использует
+# Яндекс для поиска кратчайшего пути между станциями!
Index: INTPY/C4_Algorythms_Data_structures/tests_for_webinar.html
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/INTPY/C4_Algorythms_Data_structures/tests_for_webinar.html b/INTPY/C4_Algorythms_Data_structures/tests_for_webinar.html
new file mode 100644
--- /dev/null	(date 1662389251622)
+++ b/INTPY/C4_Algorythms_Data_structures/tests_for_webinar.html	(date 1662389251622)
@@ -0,0 +1,27 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <title>Title</title>
+</head>
+<body>
+<h1>Вебинар «Практикум. Алгоритмы и структуры данных. Python»</h1>
+
+<p>Добро пожаловать на вебинар «Практикум. Алгоритмы и структуры данных. Python» от 03.10.21.</p>
+
+<p>Спикер: Никита Мещеряков.</p>
+
+<p>План вебинара: решение задач совместно с экспертом.</p>
+
+<p>Задачи от спикера:</p>
+<a href="https://codeforces.com/contest/1579/problem/B">Задача 1: B. Сортировка сдвигами</a><br>
+<a href="https://codeforces.com/contest/1579/problem/E1">Задача 2: E1. Минимизация перестановки деком</a><br>
+
+<p>После просмотра записи вебинара вам предоставляется возможность оценить его и
+    поделиться своими впечатлениями/комментариями в форме обратной связи. Для нас
+    это очень важно. Просим оставить детальный комментарий. Это поможет нам
+    скорректировать/улучшить планы и форматы вебинаров, что позволит сделать
+    ваш процесс обучения более эффективным и интересным.</p>
+
+</body>
+</html>
\ No newline at end of file
Index: INTPY/C3_modules_import_files_data/C3_4_working_with_files.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import os\r\n\r\n# C3.4. Работа с файлами\r\n#\r\n\r\n# Путь к файлу\r\n\r\n#\r\n# Путь (англ. path) — набор символов, показывающий расположение файла или каталога в файловой системе.\r\n#\r\n# В операционных системах UNIX разделительным знаком при записи пути является «/», в Windows — «\\».\r\n# Эти знаки служат для разделения названия каталогов, составляющих путь к файлу. Все вы видели,\r\n# например, такой путь на ОС Windows: C:\\Program Files. Это и есть путь до папки Program Files.\r\n#\r\n# Существует два типа пути:\r\n#\r\n#         абсолютный,\r\n#         относительный.\r\n#\r\n# Абсолютный путь всегда считается от «корня», той папки, откуда потом вырастают все остальные папки.\r\n# Для Windows это диск С:, D: и т. д., для Unix это «/» (обратный слеш). Абсолютный путь всегда уникальный.\r\n#\r\n# Абсолютный путь — это путь, который указывает на одно и то же место в файловой системе, вне зависимости\r\n# от текущего рабочего каталога или других обстоятельств. Его ещё называют полным.\r\n#\r\n# Относительный путь — это путь по отношению к текущему рабочему каталогу пользователя.\r\n#\r\n# Чтобы поработать с путями есть модуль os. Функция os.chdir() позволяет нам изменить директорию,\r\n# которую мы в данный момент используем. Если вам нужно знать, какой путь вы в данный момент\r\n# используете, для этого нужно вызвать os.getcwd().\r\n#\r\n# ПРИМЕЧАНИЕ: все дальнейшие пути указаны для конкретной машины на ОС Linux.\r\n# У вас эти результаты будут отличаться.\r\n\r\nstart_path = os.getcwd()  # получить текущий путь\r\nprint(start_path)  # /home/nbuser/library\r\n\r\n# Далее попробуем подняться на директорию выше:\r\n\r\nos.chdir(\"..\")  # подняться на один уровень выше\r\nprint(os.getcwd())  # '/home/nbuser'\r\n\r\n# Теперь вернёмся в ту директорию, из которой стартовали.\r\n# Изначально мы сохраняли её в переменной start_path.\r\n\r\nos.chdir(start_path)\r\nprint(os.getcwd())  # '/home/nbuser/library'\r\n\r\n# С помощью функции os.listdir() можно получить весь список файлов, находящихся в директории.\r\n# Если не указать никаких аргументов, то будет взята текущая директория.\r\n\r\n# список файлов и директорий в папке\r\n# import os\r\n\r\nprint(os.listdir())  # ['SnapchatLoader', 'FBLoader', 'tmp.py', '.gitignore', 'venv', '.git']\r\n\r\nif 'tmp.py' not in os.listdir():\r\n    print(\"Файл отсутствует в данной директории\")\r\n\r\n# Для того чтобы склеивать пути с учётом особенностей ОС, следует использовать\r\n# функцию os.path.join(). Это связано с тем, что в разных операционных системах\r\n# могут быть разные разделители каталогов, например, в ОС Windows этим разделителем\r\n# является «\\», а в Linux — «/», как мы и говорили в начале юнита. Поэтому чтобы\r\n# поиск файла проходил гладко на обеих системах (ведь ваш скрипт могут запускать\r\n# на любой системе в связи с кросс-платформенностью Python),\r\n# лучше всё-таки использовать join.\r\n\r\n# соединяет пути с учётом особенностей операционной системы\r\nprint(start_path)\r\nprint(os.path.join(start_path, 'test'))\r\n\r\n\r\n# /home/nbuser/library\r\n# /home/nbuser/library/test\r\n\r\n#  Задание 3.4.1\r\n# Путь, который указывает на одно и то же место в файловой системе,\r\n# вне зависимости от текущего рабочего каталога или других обстоятельств,\r\n# называется... # абсолютный\r\n#\r\n# Путь по отношению к текущему рабочему каталогу пользователя\r\n# называется... # относительный\r\n\r\n# Задание 3.4.3\r\n# Сделайте функцию, которая принимает от пользователя путь и выводит всю\r\n# информацию о содержимом этой папки. Для реализации используйте функцию\r\n# встроенного модуля os.walk(). Если путь не указан,\r\n# то сравнение начинается с текущей директории.\r\ndef show_dir(path=None):\r\n    start_path = path if path is not None else os.getcwd()\r\n\r\n    for root, dirs, files in os.walk(start_path):\r\n        print(\"Текущая директория\", root)\r\n        print(\"---\")\r\n\r\n        if dirs:\r\n            print(\"Список папок\", dirs)\r\n        else:\r\n            print(\"Папок нет\")\r\n        print(\"---\")\r\n\r\n        if files:\r\n            print(\"Список файлов\", files)\r\n        else:\r\n            print(\"Файлов нет\")\r\n        print(\"---\")\r\n\r\n        if files and dirs:\r\n            print(\"Все пути:\")\r\n        for f in files:\r\n            print(\"Файл\", os.path.join(root, f))\r\n        for d in dirs:\r\n            print(\"Папка\", os.path.join(root, d))\r\n        print(\"===\")\r\n\r\n\r\nshow_dir()\r\n\r\n#\r\n# Работа с файлами\r\n#\r\n# Python «из коробки» располагает достаточно широким набором инструментов для работы с файлами.\r\n# Для того чтобы начать работать с файлом, надо его открыть с помощью команды специальной функции open.\r\n\"\"\"\r\nf = open('path/to/file', 'filemode', encoding='utf8')\r\n\"\"\"\r\n# Результатом этой операции будет файл, в котором указатель текущей позиции\r\n# поставлен на начало или конец файла.\r\n\r\n# Перед тем как начнём разбирать аргументы, хотелось бы заранее отметить, что\r\n# указателем называется скорее метка, которая указывает на определённое место\r\n# в файле. Указателей в классическом понимании программиста, как например,\r\n# в C или C++, в Python нет!\r\n#\r\n# Давайте по порядку разберём все аргументы:\r\n#\r\n# 1. path/to/file — путь к файлу может быть относительным или абсолютным.\r\n#   Можно указывать в Unix-стиле (path/to/file) или в Windows-стиле (path\\to\\file).\r\n# 2. filemode — режим, в котором файл нужно открывать.\r\n#      Записывается в виде строки, состоит из следующих букв:\r\n#         r — открыть на чтение (по умолчанию);\r\n#         w — перезаписать и открыть на запись (если файла нет, то он создастся);\r\n#         x — создать и открыть на запись (если уже есть — исключение);\r\n#         a — открыть на дозапись (указатель будет поставлен в конец);\r\n#         t — открыть в текстовом виде (по умолчанию);\r\n#         b — открыть в бинарном виде.\r\n# 3. encoding — указание, в какой кодировке файл записан (utf-8, cp1251 и т. д.).\r\n#    По умолчанию стоит utf-8.\r\n#\r\n# Открытие файла на запись является блокирующей операцией, то есть она останавливает\r\n# работу нашей программы до того, пока файл не откроется.\r\n\r\n# Теперь давайте поговорим про то, как записывать какую-либо информацию в файл.\r\n#\r\n# При открытии файла внутри него ставится указатель текущей позиции для чтения.\r\n# При открытии в режиме чтения или записи указатель ставится на начало,\r\n# в режиме a (добавление новых записей в конец файла) — в конец.\r\n#\r\n# Откроем файл на запись и с помощью метода write запишем в него строку.\r\n# В качестве результата метод write возвращает количество записанных символов.\r\n\r\nf = open('test.txt', 'w', encoding='utf8')\r\n\r\n# Запишем в файл строку\r\nf.write(\"This is a test string\\n\")\r\nf.write(\"This is a new string\\n\")\r\n# моя отсебятина:\r\n# f.write(\"Это текстовая строка\\n\")\r\n# f.write(\"А это еще одна текстовая строка\\n\")\r\n\r\n# После вызова команды write ваши данные не сразу попадут и сохранятся в файл.\r\n# Связанно это с особенностями внутренней работы операционных систем. Если для\r\n# вас критично своевременно попадание информации на жёсткий диск компьютера,\r\n# то после записи вызывайте f.flush() или закрывайте файл. Закрыть файл можно\r\n# с помощью метода close().\r\n#\r\n# # обязательно нужно закрыть, файл иначе он будет заблокирован ОС\r\nf.close()\r\n\r\n# Теперь давайте посмотрим, как читать данные из файла.\r\n#\r\n# Откроем файл для чтения, в который только что записали две строки:\r\n\r\nf = open('test.txt', 'r', encoding='utf8')  # # считали остаток файла\r\n\r\n# Вот его содержимое на жёстком диске:\r\n# This is a test string\r\n# This is a new string\r\n\r\n# После того как файл открыт для чтения, мы можем читать из него данные.\r\n#\r\n# f.read(n) — операция, читающая с текущего места n символов,\r\n# если файл открыт в t режиме, или n байт, если файл открыт в b режиме,\r\n# и возвращающая прочитанную информацию\r\n\r\nprint(f.read(10))  # This is a\r\n\r\n# После прочтения указатель на содержимое остаётся на той позиции, где чтение\r\n# закончилось. Если n не указать, будет прочитано «от печки», т. е. от текущего\r\n# места указателя и до самого конца файла.\r\n\r\nprint(f.read())     #   test string\r\n                    #   This is a new string\r\n\r\n# После работы обязательно закрываем файл:\r\n#\r\nf.close()  # обязательно закрываем файл!\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/INTPY/C3_modules_import_files_data/C3_4_working_with_files.py b/INTPY/C3_modules_import_files_data/C3_4_working_with_files.py
--- a/INTPY/C3_modules_import_files_data/C3_4_working_with_files.py	(revision aceb5b78e04eb6a1b997e1467f1364daa24c3211)
+++ b/INTPY/C3_modules_import_files_data/C3_4_working_with_files.py	(date 1661950254406)
@@ -2,8 +2,9 @@
 
 # C3.4. Работа с файлами
 #
-
+##############################################################################
 # Путь к файлу
+##############################################################################
 
 #
 # Путь (англ. path) — набор символов, показывающий расположение файла или каталога в файловой системе.
@@ -73,6 +74,7 @@
 # /home/nbuser/library
 # /home/nbuser/library/test
 
+############################################################################3
 #  Задание 3.4.1
 # Путь, который указывает на одно и то же место в файловой системе,
 # вне зависимости от текущего рабочего каталога или других обстоятельств,
@@ -81,6 +83,7 @@
 # Путь по отношению к текущему рабочему каталогу пользователя
 # называется... # относительный
 
+############################################################################3
 # Задание 3.4.3
 # Сделайте функцию, которая принимает от пользователя путь и выводит всю
 # информацию о содержимом этой папки. Для реализации используйте функцию
@@ -116,8 +119,9 @@
 
 show_dir()
 
-#
+############################################################################3
 # Работа с файлами
+############################################################################3
 #
 # Python «из коробки» располагает достаточно широким набором инструментов для работы с файлами.
 # Для того чтобы начать работать с файлом, надо его открыть с помощью команды специальной функции open.
@@ -127,13 +131,15 @@
 # Результатом этой операции будет файл, в котором указатель текущей позиции
 # поставлен на начало или конец файла.
 
+
 # Перед тем как начнём разбирать аргументы, хотелось бы заранее отметить, что
 # указателем называется скорее метка, которая указывает на определённое место
 # в файле. Указателей в классическом понимании программиста, как например,
 # в C или C++, в Python нет!
 #
+############################################################################
 # Давайте по порядку разберём все аргументы:
-#
+############################################################################
 # 1. path/to/file — путь к файлу может быть относительным или абсолютным.
 #   Можно указывать в Unix-стиле (path/to/file) или в Windows-стиле (path\to\file).
 # 2. filemode — режим, в котором файл нужно открывать.
@@ -150,7 +156,9 @@
 # Открытие файла на запись является блокирующей операцией, то есть она останавливает
 # работу нашей программы до того, пока файл не откроется.
 
+############################################################################3
 # Теперь давайте поговорим про то, как записывать какую-либо информацию в файл.
+############################################################################3
 #
 # При открытии файла внутри него ставится указатель текущей позиции для чтения.
 # При открытии в режиме чтения или записи указатель ставится на начало,
@@ -205,3 +213,191 @@
 # После работы обязательно закрываем файл:
 #
 f.close()  # обязательно закрываем файл!
+
+###########################################################################
+# Чтение и запись построчно
+###########################################################################
+#
+# Зачастую с файлами удобнее работать построчно, поэтому для этого есть отдельные методы:
+#
+#         writelines — записывает список строк в файл;
+#         readline — считывает из файла одну строку и возвращает её;
+#         readlines — считывает из файла все строки в список и возвращает их.
+#
+# Метод f.writelines(sequence) не будет сам за вас дописывать символ конца строки (‘\n’).
+# Поэтому при необходимости его нужно прописать вручную.
+
+f = open('test.txt', 'a', encoding='utf8')  # открываем файл на дозапись
+
+sequence = ["other string\n", "123\n", "test test\n"]
+f.writelines(sequence)  # берёт строки из sequence и записывает в файл (без переносов)
+
+f.close()
+
+# Попробуем теперь построчно считать файл с помощью readlines:
+
+f = open('test.txt', 'r', encoding='utf8')
+
+print(f.readlines())  # считывает все строки в список и возвращает список
+
+f.close()
+
+# Метод f.readline() возвращает строку (символы от текущей позиции до символа переноса строки):
+
+f = open('test.txt', 'r', encoding='utf8')
+
+print(f.readline())  # This is a test string
+print(f.read(4))  # This
+print(f.readline())  #  is a new string
+
+# Подробный материал с разбором работы с файловой системой представлен в скринкасте.
+
+#######################################################################
+# Файл как итератор
+#######################################################################
+
+# Объект «файл» является итератором, поэтому его можно использовать в цикле for.
+#
+# Для чего это нужно?
+#
+# Итераторы представляют собой такой объект, который вычисляет какие-то действия
+# на каждом шаге, а не все сразу. На примере файла это выглядит примерно так.
+# Предположим, у вас есть огромный текстовый файл, который весит несколько гигабайт.
+# Если попытаться разом считать его полностью с помощью f.readlines(), то он будет
+# загружен в вашу программу, в то время как переменная, в которую будет записан файл,
+# станет весить так же, как и объём считанного файла.
+#
+# В большинстве задач с обработкой текста весь он разом не нужен, поэтому мы можем,
+# например, считывать его построчно, обрабатывать строку и забывать из нашей программы,
+# чтобы считать новую. Тогда весь файл огромного объёма не будет попросту висеть в памяти компьютера.
+#
+# Так, конечно же, делать не стоит. В большинстве задач с обработкой текста весь файл
+# разом читать не требуется. В таком случае с файлом работают построчно.
+
+f = open('test.txt')  # можно перечислять строки в файле
+for line in f:
+    print(line, end='')
+
+# This is a test string
+# This is a new string
+# other string
+# 123
+# test test
+
+f.close()
+
+# Цикл for, как мы помним, это цикл который перебирает по очереди.
+
+###############################################################################
+#  Менеджер контекста with
+###############################################################################
+
+# После работы с файлом его нужно закрыть с помощью метода close(). Обработчик
+# данного файла освобождается для операционной системы (если файл был открыт для
+# записи), и другие приложения могут получать к нему доступ. Если не закрыть файл
+# явно, то информация, записываемая в него, может быть утеряна, или же сам файл
+# может повредиться.
+
+# Для явного указания места работы с файлом, а также чтобы не забывать закрывать
+# файл после обработки, существует менеджер контекста with.
+
+# В блоке менеджера контекста открытый файл «жив» и с ним можно работать,
+# при выходе из блока файл закрывается.
+
+with open("test.txt", 'rb') as f:
+    a = f.read(10)
+    b = f.read(23)
+    print(a)
+    print(b)
+
+print(f.read(3))  # Error!
+
+# Тело менеджера контекста определяется одним отступом вправо относительно отступов
+# ключевого слова with. Менеджер контекста неявно вызывает закрытие файла после работы,
+# что освобождает вас от забот о том, закрыли ли вы файл или нет. Закрытие файла
+# происходит при любом стечении обстоятельств, даже если внутри with будет ошибка.
+# В дальнейшем мы научимся писать собственные структуры, работающие похожим образом.
+
+##############################################################################
+# Задание 3.4.4
+# Создайте любой файл на операционной системе под название input.txt и
+# построчно перепишите его в файл output.txt.
+##############################################################################
+
+f = open('input.txt', 'w', encoding='utf8')
+f.write("Раз, два, три, четыре, пять!\n")
+f.write("Вышел зайчик погулять.\n")
+f.write("Вдруг охотник выбегает,\n")
+f.write("Прямо в зайчика стреляет!\n")
+f.close()
+
+with open('input.txt', 'r') as input_file:
+    with open('output.txt', 'w') as output_file:
+        for line in input_file:
+            output_file.write(line)
+
+#######################################################################
+# Задание 3.4.5
+# Дан файл numbers.txt, компоненты которого являются действительными числами
+# (файл создайте самостоятельно и заполните любыми числами, в одной строке одно
+# число). Найдите сумму наибольшего и наименьшего из значений
+# и запишите результат в файл output.txt.
+#######################################################################
+
+filename = 'numbers.txt'
+output = 'output.txt'
+# sum_ = None
+
+with open(filename) as f:
+    min_ = max_ = float(f.readline())
+    for line in f:
+        num = float(line)
+        if num > max_:
+            max_ = num
+        elif num < min_:
+            min_ = num
+
+    sum_ = min_ + max_
+
+with open('output.txt', 'w') as f:
+    f.write(str(sum_))
+    f.write('\n')
+
+#####################################################################
+# Задание 3.4.6
+# В текстовый файл построчно записаны фамилии и имена учащихся класса и
+# их оценки за контрольную. Выведите на экран всех учащихся, чья оценка
+# меньше 3 баллов. Cодержание файла:
+#
+# Иванов О. 4
+# Петров И. 3
+# Дмитриев Н. 2
+# Смирнова О. 4
+# Керченских В. 5
+# Котов Д. 2
+# Бирюкова Н. 1
+# Данилов П. 3
+# Аранских В. 5
+# Лемонов Ю. 2
+# Олегова К. 4
+#####################################################################
+
+filename = 'pupils.txt'
+
+with open(filename, encoding='utf8') as file:
+    for line in file:
+        grade = int(line.split()[-1])
+        if grade < 3:
+            name = ' '.join(line.split()[:-1])
+            print(name)
+
+######################################################################
+# Задание 3.4.7
+# Выполните реверсирование строк файла (перестановка строк файла в обратном порядке).
+######################################################################
+
+with open('input.txt', 'r') as input_file:
+   with open('output.txt', 'w') as output_file:
+       for line in reversed(input_file.readlines()):
+           output_file.write(line)
+
Index: INTPY/C4_Algorythms_Data_structures/C4_7_search_algorythms.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/INTPY/C4_Algorythms_Data_structures/C4_7_search_algorythms.py b/INTPY/C4_Algorythms_Data_structures/C4_7_search_algorythms.py
new file mode 100644
--- /dev/null	(date 1662318198950)
+++ b/INTPY/C4_Algorythms_Data_structures/C4_7_search_algorythms.py	(date 1662318198950)
@@ -0,0 +1,129 @@
+#########################################################################
+# C4.7. Алгоритмы поиска
+#########################################################################
+
+# На текущий момент мы познакомились со всеми основными структурами данных
+# и даже научились создавать собственные. Это победа!
+#
+# Однако эти структуры существуют для какой-то цели. Одна из самых
+# распространённых — поиск элемента в структуре. В этой части модуля мы
+# рассмотрим базовые алгоритмы поиска в различных структурах.
+
+#########################################################################
+# Линейный поиск
+#########################################################################
+
+# Алгоритм линейного поиска определяется на таких структурах данных как
+# массивы, списки и надстройки над ними — очередь и стек. Такой алгоритм
+# является «решением в лоб» и сводится к перебору одного элемента за другим
+# и операции сравнения на каждом. Как правило, линейный поиск применяется
+# к неотсортированным структурам.
+#
+# Пусть на вход программы поступает массив из произвольного количества целых
+# чисел и ещё одно целое число, которое будем проверять на вхождение в этот
+# массив. Задача состоит в том, чтобы вернуть индекс первого вхождения элемента,
+# если он входит в него, и False, если не входит.
+
+def find(array, element):
+    for i, a in enumerate(array):
+        if a == element:
+            return (f"Число {element} входит в массив")
+
+    return (f"Число {element} не входит в массив")
+
+
+array = list(map(int, input("Введите несколько чисел через пробел: ").split()))
+element = int(input("Введите число: "))
+
+print(find(array, element))
+
+# В худшем случае этот алгоритм работает за O(n), потому что, если элемент не
+# входит в массив, придётся провести сравнений. Все они не увенчаются успехом.
+
+#
+# ---------------------------------------------------------------
+# Линейный алгоритм поиска может применяться для следующих целей:
+#
+#         Нахождение минимального/максимального элемента.
+#         Поиск элемента с определённым значением.
+#         Количество вхождений элемента в массив.
+#         Количество элементов больше заданного.
+# ---------------------------------------------------------------
+
+# В случае нахождения минимального (максимального) элемента линейный поиск
+# имеет смысл применять только при небольшом количестве элементов, и если
+# структура не отсортирована. Для больших структур, а тем более, если они
+# уже сортированы, имеет смысл применять более эффективные алгоритмы.
+
+# Задание 4.7.1
+# Напишите функцию count, которая возвращает количество вхождений элемента в массив
+#
+# Ответ:
+# def count(array, element):
+#     count = 0
+#     for a in array:
+#         if a == element:
+#             count += 1
+#     return count
+# Мой ответ:
+
+def count(array, element):
+    counter = 0
+    for i in array:
+        if i == element:
+            counter += 1
+    if counter > 0:
+        return (f"Число {element} в массиве встречается {counter} раз")
+    else:
+        return (f"Число {element} отсутствует в массиве")
+
+print(count(array,element))
+
+#########################################################################
+# Двоичный поиск
+#########################################################################
+
+# Алгоритм двоичного поиска является более совершенным, чем линейный поиск,
+# однако он накладывает на структуру сильное ограничение —
+# она должна быть отсортирована.
+#
+# Допустим, что у нас стоит такая же задача — найти индекс определённого
+# элемента в массиве. В связи с тем, что алгоритм может искать только в
+# отсортированном массиве, используем генератор последовательных чисел
+# range. Суть двоичного поиска сводится к тому, что на каждой итерации
+# размер исследуемого массива уменьшается в 2 раза.
+
+def binary_search(array, element, left, right):
+    if left > right:  # если левая граница превысила правую,
+        return False  # значит, элемент отсутствует
+
+    middle = (right + left) // 2  # находим середину
+    if array[middle] == element:  # если элемент в середине
+        return middle  # возвращаем этот индекс
+    elif element < array[middle]:  # если элемент меньше элемента в середине
+        # рекурсивно ищем в левой половине
+        return binary_search(array, element, left, middle - 1)
+    else:  # иначе в правой
+        return binary_search(array, element, middle + 1, right)
+
+
+element = int(input())
+array = [i for i in range(1, 100)]  # 1,2,3,4,...
+
+# запускаем алгоритм на левой и правой границе
+# print(binary_search(array, element, 0, 99))
+print(f"Индекс элемента {element} в массиве = ", binary_search(array, element, 0, 99))
+
+# Математически доказывается, что сложность такого алгоритма O(log(n)), а как
+# вы должны помнить из начала этого модуля — логарифмическая сложность намного
+# лучше, чем линейная. Ура! Мы получили очень эффективный алгоритм поиска.
+# Только вот сортировать нужно… Но и с этим мы познакомимся чуть позже.
+#
+# Несколько более сложный алгоритм, но в чём-то схожий с двоичным поиском
+# — это использование двоичных деревьев поиска. Этот алгоритм концентрирует
+# свойства бинарных деревьев для оптимизации задачи поиска. С ним можно
+# ознакомиться в дополнительных материалах к теме.
+# https://lms.skillfactory.ru/asset-v1:Skillfactory+FPW-1+25JUNE2020+type@asset+block@%D0%94%D0%BE%D0%BF._%D0%BC%D0%B0%D1%82%D0%B5%D1%80%D0%B8%D0%B0%D0%BB%D1%8B._%D0%94%D0%B2%D0%BE%D0%B8%D1%87%D0%BD%D0%BE%D0%B5_%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE_%D0%BF%D0%BE%D0%B8%D1%81%D0%BA%D0%B0.pdf
+
+#########################################################################
+#########################################################################
\ No newline at end of file
Index: INTPY/C4_Algorythms_Data_structures/algorythm_Deikstra_mod.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/INTPY/C4_Algorythms_Data_structures/algorythm_Deikstra_mod.py b/INTPY/C4_Algorythms_Data_structures/algorythm_Deikstra_mod.py
new file mode 100644
--- /dev/null	(date 1662286753853)
+++ b/INTPY/C4_Algorythms_Data_structures/algorythm_Deikstra_mod.py	(date 1662286753853)
@@ -0,0 +1,70 @@
+
+# Алгоритм Дейкстры можно модифицировать таким образом, что можно определить
+# не только величину пути, но ещё и сами вершины минимального пути.
+#
+# Для этого определим ещё один словарь P, в котором будем для каждой вершины
+# хранить вершину-предок с минимальным расстоянием.
+#
+# P = {k : None for k in G.keys()}
+
+# Задание 4.5.3
+# Модифицируйте алгоритм Дейкстры таким образом, что в массив P по
+# соответствующему ключу будет записываться предок с минимальным
+# расстоянием, если это необходимо.
+
+
+G = {
+    "Адмиралтейская": {
+        "Садовая": 4},
+    "Садовая": {
+        "Сенная площадь": 4,
+        "Спасская": 3,
+        "Адмиралтейская": 4,
+        "Звенигородская": 5},
+    "Сенная площадь": {
+        "Садовая": 4,
+        "Спасская": 4},
+    "Спасская": {
+        "Садовая": 3,
+        "Сенная площадь": 4,
+        "Достоевская": 6},
+    "Звенигородская": {
+        "Пушкинская": 3,
+        "Садовая": 5},
+    "Пушкинская": {
+        "Звенигородская": 3,
+        "Владимирская": 4},
+    "Владимирская": {
+        "Достоевская": 3,
+        "Пушкинская": 4},
+    "Достоевская": {
+        "Владимирская": 3,
+        "Спасская": 6}
+}
+
+D = {k : 100 for k in G.keys()}  # расстояния
+start_k = 'Адмиралтейская'  # стартовая вершина
+D[start_k] = 0  # расстояние от неё до самой себя равно нулю
+U = {k : False for k in G.keys()}  # флаги просмотра вершин
+P = {k : None for k in G.keys()}  # предки
+
+for _ in range(len(D)):
+    # выбираем среди непросмотренных наименьшее по расстоянию
+    min_k = min([k for k in U.keys() if not U[k]], key = lambda x: D[x])
+
+    for v in G[min_k].keys():  # проходимся по всем смежным вершинам
+         if D[v] > D[min_k] + G[min_k][v]:  # если расстояние от текущей вершины меньше
+            D[v] = D[min_k] + G[min_k][v]  # то фиксируем его
+            P[v] = min_k  # и записываем как предок
+    U[min_k] = True  # просмотренную вершину помечаем
+
+pointer = "Владимирская" # куда должны прийти
+path = [] # список с вершинами пути
+while pointer is not None: # перемещаемся, пока не придём в стартовую точку
+    path.append(pointer)
+    pointer = P[pointer]
+
+path.reverse() # разворачиваем путь
+for v in path:
+    print(v, ',', end=' ')
+
Index: INTPY/C4_Algorythms_Data_structures/C4_8_sorting_algorythms.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/INTPY/C4_Algorythms_Data_structures/C4_8_sorting_algorythms.py b/INTPY/C4_Algorythms_Data_structures/C4_8_sorting_algorythms.py
new file mode 100644
--- /dev/null	(date 1662388292116)
+++ b/INTPY/C4_Algorythms_Data_structures/C4_8_sorting_algorythms.py	(date 1662388292116)
@@ -0,0 +1,410 @@
+#########################################################################
+# C4.8. Алгоритмы сортировки
+#########################################################################
+
+# За плечами огромный опыт работы со структурами данных и уже с некоторыми
+# алгоритмами. Напоследок рассмотрим последнюю тему, имеющую огромное значение
+# при работе с линейными структурами данных — сортировка.
+#
+# Данные, которые приходят в программу из внешней среды, чаще всего являются
+# несортированными — их порядок ничем не определяется. Однако согласитесь, что
+# это далеко не всегда удобно. А если мы говорим про алгоритмы, то это ещё и
+# сильно снижает эффективность.
+#
+# В заключительной части модуля мы рассмотрим некоторые алгоритмы сортировки:
+#
+#     1. Наивная сортировка (чтобы показать, как делать не стоит).
+#     2. Сортировка выбором (чуть менее наивный, но далёк от идеала).
+#     3. Сортировка пузырьком (пожалуй, самый понятный в реализации,
+#           но далеко не самый эффективный).
+#     4. Сортировка вставками (неплохо).
+#     5. Сортировка слиянием (заметно лучше).
+#     6. Быстрая сортировка (почти идеально!).
+
+#########################################################################
+# Наивная сортировка
+#########################################################################
+
+# Мы показываем наивную сортировку, чтобы показать, как делать не нужно
+# ни в коем случае!
+#
+# Её основная суть заключается в том, чтобы постоянно перемешивать массив,
+# пока не получим подходящую последовательность… Звучит очень долго с точки
+# зрения времени выполнения. И это правда так, ведь для массива из n элементов
+# нам нужно сделать n! (факториал) перестановок и проверить каждую из них.
+# Помните, в начале модуля мы говорили про алгоритмы сложности O(n!).
+# Сейчас в первый и в последний раз мы с вами реализуем такой алгоритм.
+
+import random  # модуль, с помощью которого перемешиваем массив
+
+
+# пусть имеем массив всего лишь из 9 элементов
+array = [2, 3, 1, 7, 9, 4, 6, 5, 8]
+
+def factorial_sort(array):
+    is_sort = False  # станет True, если отсортирован
+    count = 0  # счётчик количества перестановок
+
+    while not is_sort:  # пока не отсортирован
+        count += 1  # прибавляем 1 к счётчику
+
+        random.shuffle(array)  # перемешиваем массив
+
+        # проверяем отсортирован ли
+        is_sort = True
+        for i in range(len(array) - 1):
+            if array[i] > array[i + 1]:
+                is_sort = False
+                break
+
+# print(factorial_sort(array))
+# # [1, 2, 3, 4, 5, 6, 7, 8, 9]
+# print(count)
+# 290698
+
+# Уже для 9 элементов получили какое-то нереальное число. Невозможно представить,
+# что будет, если в массиве будет хотя бы 100 элементов.
+
+# ----------------------------------------------------------------------
+#  Задание 4.8.1
+# Найдите количество цифр в записи числа 100! (факториал от 100).
+
+# import math
+#
+# print(str(math.factorial(100)))
+# print(len(str(math.factorial(100))))
+# -----------------------------------------------------------------------
+
+# Надеюсь, теперь понятно, почему так делать не стоит.
+
+#########################################################################
+# Сортировка выбором
+#########################################################################
+
+# Допустим, намотали на ус, что перестановками нам ничего хорошего не добиться.
+#
+# Следующее решение «в лоб» — каждый раз искать минимальный элемент и ставить
+# его в начало. Звучит уже интереснее.
+
+array = [2, 3, 1, 4, 6, 5, 9, 8, 7] # выше он уже есть, повторять не обязательно
+
+for i in range(len(array)):  # проходим по всему массиву
+    idx_min = i  # сохраняем индекс предположительно минимального элемента
+    for j in range(i + 1, len(array)):
+        if array[j] < array[idx_min]:
+            idx_min = j
+    if i != idx_min:  # если индекс не совпадает с минимальным, меняем
+        array[i], array[idx_min] = array[idx_min], array[i]
+
+print(array) # [1, 2, 3, 4, 5, 6, 7, 8, 9]
+
+# На каждом шаге мы имеем отсортированную (слева) и неотсортированную часть
+# (справа). Ищется минимальный элемент в неотсортированной части и меняется
+# местами с элементом в начале неотсортированной части. И так продолжается,
+# пока не закончится внешний цикл.
+
+# -----------------------------------------------------------------------
+#  Задание 4.8.2
+# Посчитайте количество сравнений элементов списка, которые производятся
+# в алгоритме выбором из примера.
+
+print(8+7+6+5+4+3+2+1) # 36
+
+# -----------------------------------------------------------------------
+# Задание 4.8.3
+# Модифицируйте описанный алгоритм для сортировки по убыванию.
+# -----------------------------------------------------------------------
+for i in range(len(array)):  # проходим по всему массиву
+    count = 0
+    idx_max = i  # сохраняем индекс предположительно максимального элемента
+    for j in range(i + 1, len(array)):
+        if array[j] > array[idx_max]:
+            idx_max = j
+            count += 1
+    if i != idx_max:  # если индекс не совпадает с минимальным, меняем
+        array[i], array[idx_max] = array[idx_max], array[i]
+
+print(array) # [9, 8, 7, 6, 5, 4, 3, 2, 1]
+
+#########################################################################
+# Сортировка пузырьком
+#########################################################################
+
+# Сортировка пузырьком — самый любимый студентами вид сортировки. Его суть
+# сводится к тому, что максимальные элементы шаг за шагом «всплывают» вправо
+# — в отсортированную часть массива. И по ходу совершаются ещё перестановки,
+# если это необходимо, ведь каждый раз мы сравниваем только соседние элементы!
+
+A = [2, 3, 1, 4, 6, 5, 9, 8, 7]
+
+def bubble_sort(array):
+    for i in range(len(array)):
+        for j in range(len(array) - i - 1):
+            if array[j] > array[j + 1]:
+                array[j], array[j + 1] = array[j + 1], array[j]
+
+    print("Сортировка пузырьком: ", A)
+
+bubble_sort(A)
+
+# Алгоритм сортировки как пузырьком, так и выбором, имеет среднюю сложность O(n**2),
+# потому что мы имеем два вложенных цикла, каждый из которых, в среднем, проходится
+# по половине всего количества элементов. На первой итерации проверяется N-1 условие,
+# на второй N-2 и т. д., пока на последней итерации не останется только 1 условие
+# (сравнить первый и второй элементы). Можно убедиться, что среднее количество будет
+# равно ~N/2 на каждой итерации, которых N. Это и приводит нас к квадратичной сложности
+# обоих алгоритмов. Однако пузырёк всё-таки побеждает, потому что на каждую итерацию
+# тратится чуть-чуть меньше времени.
+#
+# Пузырёк удобен, когда структура имеет не очень большой размер и очень важна скорость
+# написания кода. В таком случае пузырёк идеален — два цикла, одно условие и один swap
+# (перестановка двух элементов). Однако на более крупных массивах пузырёк сильно
+# проигрывает другим алгоритмам.
+
+#########################################################################
+# Сортировка вставками
+#########################################################################
+#
+# ( gif-анимация )
+#
+# Готовы сами написать сортировку? Никаких сомнений — готовы! Что должен сделать алгоритм?
+#     1. В начале итерации устанавливается ведущий элемент. На первой итерации — самый
+#           первый элемент и по умолчанию он считается уже отсортированным.
+#     2. Сохраняем ведущий элемент в дополнительную переменную (красный квадрат в анимации).
+#     3. Далее происходит поиск места, куда должен встать ведущий элемент в уже
+#           отсортированной (левой) части массива. Можно, например, использовать цикл while
+#           с условием достижения границы и/или успешным нахождением элемента. Пока условие
+#           цикла выполняется, происходит сдвиг каждого элемента вправо.
+#     4. По завершении цикла сохранённое значение переменной помещается на освободившееся
+#           место. Алгоритм завершается.
+
+def insert_sort(array):
+    for i in range(1, len(array)):
+        x = array[i]
+        idx = i
+        while idx > 0 and array[idx-1] > x:
+            array[idx] = array[idx-1]
+            idx -= 1
+        array[idx] = x
+
+#  Задание 4.8.5
+# Чему равно количество сравнений элементов списка, которые производятся
+# в алгоритме сортировки вставками? Проверьте на том же массиве, как и
+# в предыдущем аналогичном задании.
+# Ответ: 13
+
+#
+
+# Сравните результаты. Алгоритм сортировки вставками хоть и является также
+# квадратичным по времени (в среднем), но имеет меньшие множители (в силу
+# уменьшенного количества тяжёлых операций). И к тому же очень хорошо
+# работает на почти отсортированных массивах.
+
+#########################################################################
+# Сортировка слиянием
+#########################################################################
+
+# Сортировка слиянием основана на принципе «разделяй и властвуй». Без шуток.
+# Сначала делим массив пополам (или почти пополам, если в массиве нечётное
+# количество элементов). И снова пополам. И снова. Ещё раз. Пока не устанете.
+# Ладно, на самом деле программа сама это сделает, если использовать рекурсию.
+# А выход из рекурсии случится тогда, когда отделённый кусок массива станет
+# размером 1, т. е. сократится до одного элемента. А один элемент уж точно
+# можно считать отсортированным относительно себя.
+# Полпути сортировки можно считать пройденной.
+#
+# Дальше — интереснее.
+#
+# Нам нужно склеивать обратно расщепленные части массива, потому она и называется
+# сортировкой слиянием. Итак, имеем два одиночных элемента — сравниваем их и
+# возвращаем на предыдущий уровень рекурсии в нужном порядке.
+#
+# Когда имеем больше элементов в каждой из частей, подлежащих слиянию,
+# нужно быть предельно аккуратным:
+#
+#     1. Сравниваем первые элементы.
+#     2. В результирующий массив записываем наименьший.
+#     3. Сравниваем первый элемент в нетронутом и второй элемент из другой части.
+#     4. Сравниваем — склеиваем в результат.
+#     5. И так продолжается, пока не будет достигнут конец одной из частей.
+#     6. Последний штрих — в результирующий массив записать все элементы из ещё пока непустой части.
+#     7. Вернуть результат на предыдущий уровень рекурсии.
+
+# Задание 4.8.6
+# Реализуйте алгоритм сортировки слиянием.
+
+def merge_sort(L):  # «разделяй»
+    if len(L) < 2:  # если кусок массива равен 2,
+        return L[:]  # выходим из рекурсии
+    else:
+        middle = len(L) // 2  # ищем середину
+        left = merge_sort(L[:middle])  # рекурсивно делим левую часть
+        right = merge_sort(L[middle:])  # и правую
+        return merge(left, right)  # выполняем слияние
+
+
+def merge(left, right):  # «властвуй»
+    result = []  # результирующий массив
+    i, j = 0, 0  # указатели на элементы
+
+    # пока указатели не вышли за границы
+    while i < len(left) and j < len(right):
+        if left[i] < right[j]:
+            result.append(left[i])
+            i += 1
+        else:
+            result.append(right[j])
+            j += 1
+
+    # добавляем хвосты
+    while i < len(left):
+        result.append(left[i])
+        i += 1
+
+    while j < len(right):
+        result.append(right[j])
+        j += 1
+
+    return result
+
+# Это один из вариантов сортировки слиянием. Давайте подумаем, какая у него
+# будет сложность. При слиянии мы сравниваем элементы друг с другом, но
+# количество сравнений будет не очень большим, ведь мы склеиваем уже
+# сортированные части массива. А вот операция деления схожа с тем, что
+# мы делали с деревьями. Если каждый раз делим пополам, то для структуры
+# из n элементов имеем сложность ~O(log(n)). Умножая сложности друг на друга,
+# имеем общую сложность O(n * log(n)).И это круто!
+#
+# Однако написанный нами алгоритм требует много дополнительной памяти, чтобы
+# хранить промежуточные части массива. Решению этой проблемы посвящено много исследований.
+#
+# В частности можно ознакомиться со следующей статьёй, которая на простых
+# словах объясняет различные нюансы, связанные с выделением памяти.
+# https://vporoshok.me/post/2018/10/merge-sort/
+
+#########################################################################
+# Быстрая сортировка
+#########################################################################
+
+# Быстрая сортировка так же, как и сортировка слиянием, является одной из
+# самых быстрых. Она так же основана на принципе «разделяй и властвуй».
+# Однако вместо разделения массивов на части и дальнейшего слияния здесь
+# используется другой подход.
+#
+# Алгоритм выполняется рекурсивно следующим образом:
+#
+#     1. Выбирается ведущий элемент (есть несколько вариантов,
+#           о которых поговорим чуть позже).
+#     2. Две части массива сортируются только на основе этого ведущего элемента.
+#     3. Происходит последовательный обмен значениями элементов. Вопрос в том,
+#           какие элементы обменивать. Сначала происходит поиск слева направо
+#           до первого элемента, который превосходит по своему значению ведущий
+#           элемент. Затем массив просматривается справа налево в поисках элемента,
+#           который меньше ведущего. Когда такие элементы найдены, происходит их обмен.
+#     4. Таким образом, в левой части массива имеются элементы только меньше
+#           ведущего, а в правой — только больше.
+#     5. Функция рекурсивно применяется к получившимся частям массива, если их
+#           размеры превосходят один элемент.
+
+def qsort(array, left, right):
+    middle = (left + right) // 2
+
+    p = array[middle]
+    i, j = left, right
+    while i <= j:
+        while array[i] < p:
+            i += 1
+        while array[j] > p:
+            j -= 1
+        if i <= j:
+            array[i], array[j] = array[j], array[i]
+            i += 1
+            j -= 1
+
+    if j > left:
+        qsort(array, left, j)
+    if right > i:
+        qsort(array, i, right)
+
+# Быстрая сортировка хоть и быстрая, но не всегда. В среднем она работает,
+# как и сортировка слиянием, за O(n*log(n)). Однако существуют некоторые
+# экстремальные случаи, на которых быстрая сортировка начинает работать
+# намного хуже. Такое происходит, если на каждой итерации выбирается
+# минимальный (максимальный) элемент структуры. И тогда размер одной из
+# частей массива всегда равен 1, а размер другой — N-1. И тогда по сложности
+# быстрая сортировка становится не лучше, чем сортировка пузырьком.
+# И это не то, что мы ожидали.
+#
+# Для того чтобы обойти это ограничение, пользуются некоторыми хитростями.
+# Стоит сказать, что вообще-то ведущий элемент сам по себе не обязан
+# принадлежать массиву. Главное, что от него требуется — разделить массив
+# на как можно более близкие по размеру части.
+#
+# Поэтому существует несколько способов улучшить работу быстрой сортировки,
+# чтобы даже в худшем случае не доводить затраты по времени до :
+#
+    # 1. Нахождение среднего между первым и последним элементом массива.
+    # 2. Нахождение медианы между первым, средним и последним элементами.
+    # 3. Наиболее оптимально находить медиану всей последовательности,
+    #       но это может быть слишком затратно.
+    # 4. Рандомный элемент.
+#
+# Как правило, на практике в качестве ведущего элемента выбирается случайно
+# выбранный из всей последовательности. Благодаря такому выбору вероятность
+# попасть на минимальный (максимальный) элемент достаточно быстро стремится
+# к нулю, что особенно справедливо на очень больших массивах.
+
+# ----------------------------------------------------------------------
+# Задание 4.8.7
+# Модифицируйте алгоритм быстрой сортировки таким образом, чтобы ведущий
+# элемент выбирался как случайный среди подмассива, который сортируется
+# на данном этапе. Воспользуйтесь функцией из пакета random.
+
+# Ответ:
+
+def qsort_random(array, left, right):
+    p = random.choice(array[left:right + 1])
+    i, j = left, right
+    count = 0 # полагаю, это должно быть здесь
+    while i <= j:
+        while array[i] < p:
+            i += 1
+        while array[j] > p:
+            j -= 1
+        if i <= j:
+            count += 1
+            array[i], array[j] = array[j], array[i]
+            i += 1
+            j -= 1
+
+    if j > left:
+        qsort_random(array, left, j)
+    if right > i:
+        qsort_random(array, i, right)
+
+
+#########################################################################
+# Итоги
+#########################################################################
+# Подведём итоги рассмотрения алгоритмов сортировок.
+#
+# Естественно, это далеко не все существующие алгоритмы сортировки.
+# Нами остались не затронуты:
+#
+#     Сортировка кучей. Эта сортировка основана на построении двоичного дерева,
+#           обладающего некоторыми свойствами.
+#           https://habr.com/ru/company/otus/blog/460087/
+#     Сортировка Шелла.
+#           http://aliev.me/runestone/SortSearch/TheShellSort.html
+#     Плавная сортировка. Интересная сортировка, основанная на числах Леонардо,
+#           которые похожи на числа Фибоначчи.
+#           https://habr.com/ru/company/edison/blog/496852/
+#     Timsort. Обратите на неё особое внимание, потому что именно эта сортировка
+#           используется во встроенных сортировках языка Python. Она заслуживает
+#           рассмотрения, поскольку учитывает ещё и эмпирические факты.
+#           https://habr.com/ru/company/infopulse/blog/133303/
+
+
+
+
+#########################################################################
Index: INTPY/C5_Requests_JSON_Redis_etc/3_telebot.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/INTPY/C5_Requests_JSON_Redis_etc/3_telebot.py b/INTPY/C5_Requests_JSON_Redis_etc/3_telebot.py
new file mode 100644
--- /dev/null	(date 1662543191106)
+++ b/INTPY/C5_Requests_JSON_Redis_etc/3_telebot.py	(date 1662543191106)
@@ -0,0 +1,31 @@
+"""
+Content types:
+text, audio, document, photo, sticker, video, video_note, voice, location, contact,
+new_chat_members, left_chat_member, new_chat_title, new_chat_photo, delete_chat_photo,
+group_chat_created, supergroup_chat_created,
+channel_chat_created, migrate_to_chat_id, migrate_from_chat_id, pinned_message.
+"""
+# C помощью content-types можно научить бота реагировать на самые разные события:
+
+import telebot
+
+bot = telebot.TeleBot("5386412319:AAGoNUgj71uclssOgkm6dsBF3BSOlTJsus8")
+
+
+@bot.message_handler(content_types=['voice', ])
+def repeat(message: telebot.types.Message):
+    bot.send_message(message.chat.id, f'У тебя очень красивый голос, {message.chat.username})))')
+
+
+@bot.message_handler(content_types=['text', 'document', 'audio'])
+def handle_docs_audio(message: telebot.types.Message):
+    bot.send_message(message.chat.id, f'{message.chat.username}, принято!')
+
+# Напишите обработчик, который на сообщения с фотографией будет отвечать сообщением
+# «Nice meme XDD». Бот должен отвечать не отдельным сообщением, а с привязкой к картинке.
+
+@bot.message_handler(content_types=['photo', ])
+def say_lmao(message: telebot.types.Message):
+    bot.reply_to(message, 'Nice meme XDD') # reply_to
+
+bot.polling(non_stop=True)
Index: INTPY/C5_Requests_JSON_Redis_etc/C5_4_site_parsing_lxml.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/INTPY/C5_Requests_JSON_Redis_etc/C5_4_site_parsing_lxml.py b/INTPY/C5_Requests_JSON_Redis_etc/C5_4_site_parsing_lxml.py
new file mode 100644
--- /dev/null	(date 1662566733576)
+++ b/INTPY/C5_Requests_JSON_Redis_etc/C5_4_site_parsing_lxml.py	(date 1662566733576)
@@ -0,0 +1,216 @@
+##############################################################################
+# C5.4. Парсинг данных с сайтов с помощью lxml
+##############################################################################
+# ====================================
+# Парсинг сайтов на примере Python.org
+# ====================================
+
+# В сегодняшнем юните научимся писать простенькие парсеры.
+
+# ==========================================================================
+# Парсеры — это специальные программы, которые позволяют собирать информацию
+# с веб-сайтов, не заходя на них через браузер.
+# ==========================================================================
+
+# То есть, например, если вы захотели составить базу данных товара какого-либо
+# интернет-магазина, то вам не обязательно перемещаться по нему и вручную отбирать
+# все названия, фото товара и ссылки на сам товар. Для этого достаточно написать
+# парсер, который по определённым отличительным признакам в HTML-коде (как правило,
+# это классы или id) будет находить вам нужную информацию.
+#
+# Конкретно в этом туториале мы будем пользоваться библиотекой lxml для парсинга
+# данных. Но перед тем как писать парсеры, предлагаем вам посмотреть небольшое
+# вступление для лучшего понимания того, с чем мы будем иметь дело.
+
+# (видео. Хороший совет из него: можно исследовать веб-страницу по F12, но можно
+# и навести курсор на нужный элемент, нажать правую кнопку и выбрать "Исследовать
+# элемент")
+
+# Теперь давайте для начала установим саму библиотеку:
+#
+# pip3 install lxml
+
+# Теперь перейдём в редактор и напишем следующий код:
+
+import requests  # импортируем наш знакомый модуль
+import lxml.html
+from lxml import etree
+
+html = requests.get('https://www.python.org/').content  # получим html
+# главной странички официального сайта python
+
+tree = lxml.html.document_fromstring(html)
+title = tree.xpath(
+    '/html/head/title/text()')  # забираем текст тега <title> из тега <head>,
+# который лежит в свою очередь внутри тега <html> (в этом невидимом теге <head>
+# у нас хранится основная информация о страничке, её название и инструкции
+# по отображению в браузере)
+
+print(title)  # выводим полученный заголовок страницы
+# В результате в консоль у нас выведется:
+# ['Welcome to Python.org']
+
+# Обратили внимание, что это за тип данных? Да-да, это список. Потому как lxml
+# находит и возвращает все элементы, удовлетворяющие заданным условиям, даже,
+# если такой элемент всего один, он также будет являться частью списка.
+#
+# Возможно, вас напугала строчка, переданная в  функцию xpath. Если вам лень
+# вдумываться и писать параметр в xpath вручную, можно воспользоваться функцией
+# браузера и просто скопировать xpath до нужного вам элемента.
+#
+# Давайте теперь попробуем собрать заголовки всех новостей с Python.org. Но для
+# этого сейчас мы рассмотрим немного другой подход парсинга. Сохраним HTML-страничку
+# и поместим её в папку со скриптом, так как метод, который мы рассмотрим дальше,
+# будет работать с HTML-файлом.
+
+# Сначала скопируем путь до заголовка, чтобы не писать его вручную.
+# Это делается следующим образом:
+
+# В консоли надо выбрать нужный вам элемент (нажимаем правой кнопкой мыши по
+# заголовку, далее нажимаем «Исследовать элемент», после чего нужный элемент
+# в HTML выберется в консоли автоматически), и нажимаем по нему правой кнопкой
+# мыши. Переходим в пункт копирования.
+#
+# Выбрать «Копировать XPath».
+#
+# Ну и вот! Всё готово! Нужный путь скопирован у нас в буфер обмена!
+
+import requests  # импортируем наш знакомый модуль
+import lxml.html
+from lxml import etree
+
+# создадим объект ElementTree. Он возвращается функцией parse()
+tree = etree.parse('Welcome to Python.org.htm',
+                   lxml.html.HTMLParser())  # попытаемся спарсить наш файл
+# с помощью html-парсера. Сам html - это то, что мы скачали и поместили в папку из браузера.
+
+ul = tree.findall(
+    '/body/div/div[3]/div/section/div[2]/div[1]/div/ul/li')  # помещаем в аргумент
+# метода findall скопированный xpath. Здесь мы получим все элементы списка новостей.
+# (Все заголовки и их даты)
+
+# создаём цикл, в котором мы будем выводить название каждого элемента из списка
+for li in ul:
+    a = li.find('a')  # в каждом элементе находим, где хранится заголовок новости.
+# У нас это тег <a>. Т. е. гиперссылка, на которую нужно нажать, чтобы перейти на
+# страницу с новостью. (Гиперссылки в html это всегда тег <a>)
+    print(a.text)  # из этого тега забираем текст, это и будет нашим названием
+
+# Обратите внимание, что в скопированном из браузера xpath надо внести изменения.
+# А конкретно: мы удалили начальный тег /HTML из поиска. В основном методы find и
+# findall работают так же, как и функция xpath, но всё же есть отличия. Как вы
+# догадались, findall возвращает список многих подходящих элементов, в то время
+# как метод find возвращает только первый подходящий элемент. Также второй аргумент
+# в функции .parse() обязательный. Без него мы парсить не сможем, потому как для
+# восприятия парсером переданного в IDE HTML-текста, а не какого-либо ещё, нужно
+# передать объект класса HTMLParser.
+#
+# Теперь взглянем в консоль:
+# Python 3.11.0rc1 is now available
+# Python 3.10.6 is available
+# Python 3.11.0b5 is now available
+# Distinguished Service Award Granted to Naomi Ceder
+# Python 3.11.0b4 is now available
+#
+# Вывелись все наши заголовки! Как мы и хотели.
+#
+# Ознакомившись с кратким гайдом, ответьте на следующие вопросы.
+# https://www.tutorialspoint.com/html/html_quick_guide.htm
+
+#  Задание 5.4.1
+# Представлена строка: <a href="/add">. Тегом в ней является...
+# a
+
+#  Задание 5.4.2
+# Представлена строка: <a href="/add">. Атрибутом в ней является...
+# href
+
+#  Задание 5.4.3
+# Напишите xpath для нахождения текста элемента tag2. Помните, что мы идём
+# от самого верхнего тега к самому нижнему, разделяя их через /.
+#
+# <HTML><body><tag1> some text
+#      <tag2> MY TEXT </tag2>
+#    </tag1>
+#  </body>
+# </HTML>
+
+# /html/body/tag1/tag2/text()
+
+# Задание 5.4.4
+# Напишите программу, которая будет с помощью парсера lxml доставать
+# текст из тега tag2 следующего HTML:
+#
+# <html>
+#  <head> <title> Some title </title> </head>
+#  <body>
+#   <tag1> some text
+#      <tag2> MY TEXT </tag2>
+#    </tag1>
+#  </body>
+# </html>
+
+import lxml.html
+
+html = ''' <html>
+ <head> <title> Some title </title> </head>
+ <body>
+  <tag1> some text
+     <tag2> MY TEXT </tag2>
+   </tag1>
+ </body>
+</html>
+'''
+
+tree = lxml.html.document_fromstring(html)
+
+text = tree.xpath('/html/body/tag1/tag2/text()')
+
+print(text)
+
+# Задание 5.4.5
+# Используя полученные знания, допишите сделанный в начале юнита скрипт
+# (где мы доставали заголовки новостей о Python с Python.org) так, чтобы
+# он показывал ещё и дату добавления новости.
+# Примечание: для получения атрибутов тега (т. е. его дополнительных
+# параметров) используется метод .get(<имя атрибута>).
+
+import requests  # импортируем наш знакомый модуль
+import lxml.html
+from lxml import etree
+
+html = requests.get('https://www.python.org/').content  # получим html главной странички официального сайта python
+
+# создадим объект ElementTree. Он возвращается функцией parse()
+tree = etree.parse('Welcome to Python.org.html',
+                   lxml.html.HTMLParser())  # попытаемся спарсить наш файл с помощью html парсера
+
+ul = tree.findall(
+    'body/div/div[3]/div/section/div[3]/div[1]/div/ul/li')  # помещаем в аргумент методу findall скопированный xpath
+
+# создаём цикл в котором мы будем выводить название каждого элемента из списка
+for li in ul:
+    a = li.find('a')  # в каждом элементе находим где хранится название. У нас это тег <a>
+    time = li.find('time')
+    print(time.get('datetime'), a.text)  # из этого тега забираем текст - это и будет нашим названием
+
+
+##############################################################################
+
+# Если вас заинтересовала тема парсинга, то вы можете найти ещё немного информации
+# о ней в дополнительных материалах. Там мы разбираем библиотеку Beautiful Soup и
+# её использование для парсинга. Делает она почти то же самое, просто с ней работать
+# немножечко легче. Материал полностью опциональный,
+# но всё же рекомендуется к ознакомлению. :)
+# https://lms.skillfactory.ru/assets/courseware/v1/0c31db09ad1b1391991975f89698f368/asset-v1:SkillFactory+INTPY+2022+type@asset+block/%D0%94%D0%BE%D0%BF%D0%BE%D0%BB%D0%BD%D0%B8%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9_%D0%BC%D0%B0%D1%82%D0%B5%D1%80%D0%B8%D0%B0%D0%BB_Beautiful_Soup.pdf
+
+
+##############################################################################
+##############################################################################
+##############################################################################
+##############################################################################
+##############################################################################
+##############################################################################
+##############################################################################
+##############################################################################
+##############################################################################
Index: INTPY/C4_Algorythms_Data_structures/C4_3_Basic_data_structures.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/INTPY/C4_Algorythms_Data_structures/C4_3_Basic_data_structures.py b/INTPY/C4_Algorythms_Data_structures/C4_3_Basic_data_structures.py
new file mode 100644
--- /dev/null	(date 1662055628230)
+++ b/INTPY/C4_Algorythms_Data_structures/C4_3_Basic_data_structures.py	(date 1662055628230)
@@ -0,0 +1,222 @@
+#########################################################################
+# C4.3. Основные структуры данных
+#########################################################################
+
+# На протяжении предыдущих модулей вы научились создавать множество самых
+# разнообразных объектов со своей спецификой и областью применения. Мы
+# разобрали огромный пласт — от объектов базовых типов (числа, строки,
+# булевы переменные) до объектов собственных типов, созданных с помощью
+# классов. И вы могли заметить, что, используя различные комбинации примитивов
+# (объектов базовых типов), можно конструировать объекты, имеющие в свою
+# очередь внутреннюю структуру: списки, словари и даже экземпляры классов.
+# Всё это и не только называется структурами данных.
+
+# Структура данных — это программная единица, позволяющая хранить и
+# обрабатывать множество логически связанных объектов.
+
+# В этой части модуля мы начнём рассмотрение с основных и уже знакомых нам
+# (под другими именами) структур данных:
+#
+#         массивы: статические и динамические;
+#         хеш-таблицы.
+#
+# Каждую структуру данных в этом юните и в следующих мы будем рассматривать
+# с точки зрения её хранения в памяти, и в зависимости от этого,
+# как реализуются основные функции работы с ними:
+#
+#         доступ к элементу по индексу,
+#         вставка элемента,
+#         удаление элемента,
+#         получение размера структуры.
+#
+# А также для каждой структуры, возможно, будут определяться специфичные для неё функции.
+
+#########################################################################
+# Массивы
+#########################################################################
+
+# Массив — это упорядоченный набор данных.
+
+# Под упорядоченностью стоит понимать, что хранение этой структуры в памяти
+# каким-то образом организовано.
+#
+# Важно не путать упорядоченные структуры и отсортированные, с которыми мы
+# познакомимся ближе к концу этого модуля.
+#
+# Массивы бывают:
+#
+#         одномерные,
+#         двумерные,
+#         трёхмерные и т. д.
+#
+# Их отличительной особенностью является хранение элементов в последовательных
+# ячейках памяти. И это становится одним из ограничений массива: при его
+# создании мы всегда должны указывать, какое количество физической памяти
+# нужно для него «забронировать».
+
+# Массивы, для которых заранее резервируется фиксированная область памяти,
+# называют статическими.
+#
+# В отличие от них существуют динамические массивы, которые с помощью буферного
+# механизма, могут изменять свой размер.
+#
+# Важно различать:
+#
+#         логический размер массива (logical size) — фактическая заполненность массива;
+#         зарезервированный размер памяти (capacity) — вместимость памяти для этого массива.
+
+# Наиболее выгодное использование массивов возникает в тех ситуациях, когда
+# происходит частое обращение к элементам массива по индексам, и в меньшей
+# степени возникает необходимость добавлять и удалять элементы на произвольное
+# место. Для понимания того, почему это так, необходимо несколько глубже
+# погрузиться в особенности хранения массивов. Дополнительные сведения по этому
+# аспекту можно найти в дополнительных материалах ( https://lms.skillfactory.ru/assets/courseware/v1/8acff75a9bd167feb5ee4b4c6753ac94/asset-v1:SkillFactory+INTPY+2022+type@asset+block/%D0%94%D0%BE%D0%BF._%D0%BC%D0%B0%D1%82%D0%B5%D1%80%D0%B8%D0%B0%D0%BB._%D0%9E%D1%81%D0%BE%D0%B1%D0%B5%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D0%B8_%D1%85%D1%80%D0%B0%D0%BD%D0%B5%D0%BD%D0%B8%D1%8F_%D0%BC%D0%B0%D1%81%D1%81%D0%B8%D0%B2%D0%BE%D0%B2_%D0%B2_%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D0%B8.pdf ).
+
+# Пример
+
+# Массивы можно сравнить, например, со списком легкоатлетов, которые добежали до финиша.
+# Мы всегда знаем их общее количество. По таблице результатов (здесь как раз наши индексы)
+# можно всегда найти спортсмена, который пришёл на эту позицию. Пока идёт забег, спортсмены
+# приходят к финишной черте один за другим. Тем самым массив пополняется «с конца» — это
+# сделать очень просто. А вот если легкоатлет допустил какое-то серьёзное нарушение,
+# то он может быть исключён из таблицы результатов. Тогда придётся каждого спортсмена,
+# пришедшего после него, сдвигать на строчку вверх (к их общей радости). И это сделать
+# уже тяжелее. Ведь, если дисквалифицируем победителя, то придётся абсолютно каждого так
+# сдвинуть. Здесь, как можете предположить, уже потребуется много операций.
+#
+# Такой «бытовой» пример объясняет асимптотическую сложность некоторых операций с массивами,
+# затронутой более подробно в дополнительных материалах по ссылке выше.
+#------------------------------------------------------------------------
+#   Операция: 	                                              Сложность
+#------------------------------------------------------------------------
+# Получение размера 	                                        O(1)
+# Получение элемента массива по индексу                         O(1)
+# Вставка элемента в конец / удаление с конца                   O(1)
+# Вставка элемента на произвольное место
+#   / удаление элемента из произвольного места                  O(n)
+# Расширение памяти при выходе за пределы массива               O(n)
+#------------------------------------------------------------------------
+
+# -----------------------------------------------------------------------
+#  Задание 4.3.1
+# Какую верхнюю оценку сложности будет иметь операция добавления к массиву
+# размера n элементов массива размера m, предполагая, что размер
+# результирующего массива n + m выйдет за пределы исходного.
+# Ответ: O(n+m)
+
+#     Подсказка (1 из 1):
+#     Если массив размера N + M не «влезает» в исходную вместимость, то каждый элемент
+#     первого массива придётся переместить в новую область памяти. После перемещения
+#     первого массива, мы должны «дописать» элементы второго массива — их M штук.
+#     И для добавления в конец мы должны совершить ещё операций. Тогда общее количество
+#     операций будет равно N + M. Как записать алгоритмическую сложность
+#     такого процесса с помощью О-нотации?
+# -----------------------------------------------------------------------
+# Разработчики Python, предпочитая удобство и эффективность, внедряют в язык структуры
+# не совсем так строго, как они описаны в теории. В связи с этим объект типа список
+# (list) является на самом деле не списком, с которым мы познакомимся далее, а именно
+# динамическим массивом. Поэтому всё, что было описано выше, относится к уже знакомому
+# нам типу данных. За некоторыми исключениями на уровне реализации хранения массивов
+# в памяти, list хорошо поддерживает сложность операций, которые мы описали.
+
+# ----------------------------------------------------------------------
+#  Задание 4.3.2
+# Укажите название функции, вставляющей элемент в конец списка. Необходимо
+# вписать только название метода без круглых скобок.
+#  Ответ: append
+
+#  Задание 4.3.3
+# Укажите название функции, вставляющей элемент x на произвольное место
+# с индексом idx списка array.
+#
+# array.func_name(idx, x)
+#
+# Замените func_name на название функции.
+# Ответ: insert
+# ----------------------------------------------------------------------
+
+# В дополнительных материалах https://lms.skillfactory.ru/assets/courseware/v1/ccb347419a62fdba19bfc1b0d7f00c36/asset-v1:SkillFactory+INTPY+2022+type@asset+block/%D0%94%D0%BE%D0%BF._%D0%BC%D0%B0%D1%82%D0%B5%D1%80%D0%B8%D0%B0%D0%BB._%D0%AD%D0%BA%D1%81%D0%BF%D0%B5%D1%80%D0%B8%D0%BC%D0%B5%D0%BD%D1%82%D1%8B_%D1%81_%D0%BC%D0%B0%D1%81%D1%81%D0%B8%D0%B2%D0%B0%D0%BC%D0%B8.pdf
+# к теме можно найти эксперименты с массивами, которые с помощью измерения времени
+# могут помочь убедиться в справедливости наших рассуждений.
+
+#########################################################################
+# Хеш-таблицы
+#########################################################################
+
+# Массив с индексацией целыми числами удобен, если среди объектов можно задать
+# порядок — пронумеровать их. Но как поступить, если возникает необходимость
+# хранить объекты, нумерация которых не имеет смысла? Например, телефоны и
+# имена владельцев в адресной книге. Сами телефоны, хоть и представляют собой
+# числа, но в качестве индексов мало подходят: как правило, они начинаются
+# с некоторого номера (и он далёк от нуля), а также могут содержать пропуски
+# (не являются непрерывной последовательностью). В массиве же предполагается,
+# что массив является достаточно «плотным» с самого начала. Владельцы,
+# очевидно, также не подходят для этих целей.
+#
+# Тогда вместо целочисленных индексов хотелось бы иметь некоторую структуру данных,
+# которая хранила бы два значения, одно из которых уникально — ключ. С такой
+# структурой данных мы знакомились в самых первых модулях.
+#
+# -----------------------------------------------------------------------
+# Задание 4.3.4
+# Как в Python называется тип данных, хранящий пары объектов (ключ, значение)?
+# Введите имя типа, которое возвращает функция type().
+# Ответ: dict
+# -----------------------------------------------------------------------
+
+# Словарный тип данных, с которым мы уже хорошо знакомы, реализует принцип
+# структурирования данных, называющийся хеш-таблицы.
+#
+# Его суть заключается в том, что каждое значение обладает ключом доступа к нему.
+# Тогда имеем, что все значения хранятся в обычном массиве (скрытом от нас),
+# а в качестве индекса используется результат хеширования ключа.
+# В данном случае под хешированием понимается преобразование объекта,
+# выступающего ключом, в целое число — индекс, используемый для доступа к значению.
+
+# Исходя из этого, на ключи накладываются некоторые условия, которые уже обсуждались
+# нами ранее — ключ должен быть уникальным, а также неизменяемым. Только обладая
+# этими двумя условиями, хеш-таблица сможет корректно восстановить данные по ключу.
+#
+# Давайте вспомним операции, которые производились со словарями и посмотрим,
+# какая у них асимптотическая сложность.
+
+#########################################################################
+# Операция 	                    Метод 	                    Сложность   #
+#-----------------------------------------------------------------------#
+# Вставка пары 	                dict_[new_key] = value      O(1)        #
+# Удаление пары 	            dict_.pop(key)              O(1)        #
+# Получение значения по ключу 	dict_[key]                  O(1)        #
+#                               или                                     #
+#                               dict_.get(key)                          #
+# Получение размера 	        len(dict)                   O(n)        #
+#########################################################################
+
+# Вставка пары происходит за константное время, потому что порядок элемента
+# во внутреннем массиве не принципиален для словаря. Главное, чтобы по
+# хеш-таблице его однозначно можно было воспроизвести,
+# а сама операция хеширования стоит O(1).
+#
+# Удаление пары и получение значения по ключу также будет стоить константное
+# время. Всё, что необходимо сделать — получить хеш ключа (и именно он стоит
+# константное время), который является индексом массива. А мы уже знаем, что
+# индексирование также требует O(1) времени.
+#
+# Для получения размера словаря необходимо пересчитать все ключи. В связи с тем,
+# что хранение размера такой структуры данных не подразумевается, а внутренний
+# массив может быть разреженным (иметь пропуски), придётся циклом перебрать
+# список ключей, посчитав их количество. Раз имеем цикл по всем элементам,
+# значит сложность операции — O(n).
+#
+# Казалось бы, все основные операции: доступ, вставка, удаление — занимают
+# константное время. Почему словари (ассоциативные массивы или хеш-таблицы)
+# не используют везде?! Дело в том, что хоть они и занимают константное время
+# асимптотически, но сами операции более тяжеловесны как по памяти, так и по
+# времени, нежели аналогичные в других структурах данных. Помимо этого, для
+# реализации такой структуры данных требуется дополнительная память и, как
+# правило, гораздо больше, чем для других структур. Здесь, как и в других
+# случаях, нужно искать оптимум между производительностью и памятью.
+# Несмотря на это хеш-таблицы действительно имеют огромную область применения.
+# С некоторыми возможностями мы уже знакомились, но особо полезны такие
+# структуры в работе с базами данных.
+
+
Index: INTPY/C4_Algorythms_Data_structures/C4_6_making_own_structures.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/INTPY/C4_Algorythms_Data_structures/C4_6_making_own_structures.py b/INTPY/C4_Algorythms_Data_structures/C4_6_making_own_structures.py
new file mode 100644
--- /dev/null	(date 1662310116603)
+++ b/INTPY/C4_Algorythms_Data_structures/C4_6_making_own_structures.py	(date 1662310116603)
@@ -0,0 +1,211 @@
+#########################################################################
+# C4.6. Создание собственных структур
+#########################################################################
+
+# Ранее нами были рассмотрены следующие структуры данных:
+#
+# 1. массив,
+# 2. список,
+# 3. стек,
+# 4. очередь,
+# 5. хеш-таблица (словарь),
+# 6. граф,
+# 7. дерево.
+#
+# Для их конкретной реализации мы пользовались встроенными в Python типами данных
+# — списками, реализующими динамический массив, и словарями, реализующими хеш-таблицы.
+# Используя эти два базовых типа данных и принципы объектно-ориентированного
+# программирования, мы создали конкретные реализации других типов данных.
+# И, если честно, мы сделали костыли.
+#
+# Да, конечно, в среднем мы достигали теоретической сложности определённых структур
+# данных, оптимизируя встроенные типы данных. Однако интуиция должна подсказывать,
+# что должен существовать способ создания собственных структур данных.
+#
+# И если она вам это подсказывает, то вы не ошиблись! В прошлых модулях мы
+# познакомились с такими объектами как итераторы.
+#
+# Итератор — это пользовательский класс, в обязательном порядке реализующий
+# два «магических» метода — iter и next.
+#
+# Первый метод должен возвращать объект на итератор, а благодаря второму методу
+# мы можем совершать обход по структуре.
+
+# -----------------
+# Связанный список
+# -----------------
+
+# Чтобы не углубляться дальше в теорию, давайте посмотрим, как можно
+# создать собственную структуру данных, реализующую связанный список.
+# В самом списке мы будем хранить указатель на первый элемент и на
+# последний элемент. В таком случае давайте вспомним, какие операции
+# можно делать со списком и их среднюю оценку сложности.
+
+# Сейчас мы попробуем создать класс LinkedList, реализующий список.
+# Элементы списка будут представлять собой экземпляры класса Node.
+
+class Node:  # класс элемента
+    def __init__(self, value=None, next_=None):  # инициализируем
+        self.value = value  # значением
+        self.next = next_  # и ссылкой на следующий элемент
+
+    def __str__(self):
+        return "Node value = " + str(self.value)
+
+
+class LinkedList:  # класс списка
+    def __init__(self):  # инициализируем пустым
+        self.first = None
+        self.last = None
+
+    def clear(self):  # очищаем список
+        self.__init__()
+
+    def __str__(self):  # функция печати
+        R = ''
+
+        pointer = self.first  # берём первый указатель
+        while pointer is not None:  # пока указатель не станет None
+            R += str(pointer.value)  # добавляем значение в строку
+            pointer = pointer.next  # идём дальше по указателю
+            if pointer is not None:  # если он существует, добавляем пробел
+                R += ' '
+        return R
+
+    def pushleft(self, value):
+        if self.first is None:
+            self.first = Node(value)
+            self.last = self.first
+        else:
+            new_node = Node(value, self.first)
+            self.first = new_node
+
+    def pushright(self, value):
+        if self.first is None:
+            self.first = Node(value)
+            self.last = self.first
+        else:
+            new_node = Node(value)
+            self.last.next = new_node
+            self.last = new_node
+
+    def popleft(self):
+        if self.first is None:  # если список пустой, возвращаем None
+            return None
+        elif self.first == self.last:  # если список содержит только один элемент
+            node = self.first  # сохраняем его
+            self.__init__()  # очищаем
+            return node  # и возвращаем сохранённый элемент
+        else:
+            node = self.first  # сохраняем первый элемент
+            self.first = self.first.next  # меняем указатель на первый элемент
+            return node  # возвращаем сохранённый
+
+    def popright(self):
+        if self.first is None:  # если список пустой, возвращаем None
+            return None
+        elif self.first == self.last:  # если список содержит только один элемент
+            node = self.first  # сохраняем его
+            self.__init__()  # очищаем
+            return node  # и возвращаем сохраненный элемент
+        else:
+            node = self.last  # сохраняем последний
+            pointer = self.first  # создаём указатель
+            while pointer.next is not node:  # пока не найдём предпоследний
+                pointer = pointer.next
+            pointer.next = None  # обнуляем указатели, чтобы
+            self.last = pointer  # предпоследний стал последним
+            return node  # возвращаем сохранённый
+
+    def __iter__(self):  # объявляем класс как итератор
+        self.current = self.first  # в текущий элемент помещаем первый
+        return self  # возвращаем итератор
+
+    def __next__(self):  # метод перехода
+        if self.current is None:  # если текущий стал последним
+            raise StopIteration  # вызываем исключение
+        else:
+            node = self.current  # сохраняем текущий элемент
+            self.current = self.current.next  # совершаем переход
+            return node  # и возвращаем сохранённый
+
+    def __len__(self):
+        count = 0
+        pointer = self.first
+        while pointer is not None:
+            count += 1
+            pointer = pointer.next
+        return count
+
+
+# Мы определили класс Node. Конструктор этого класса принимает значение элемента
+# и ссылку на следующий элемент. По умолчанию они оба None. Также был определён
+# метод __str__, который используется для строкового представления объекта.
+#
+# Также был определён основной класс LinkedList. Конструктор метода инициализирует
+# ссылки на первый и на последний элемент, а также определяется метод clear,
+# который очищает список.
+#
+# Сейчас шаг за шагом добавим методы, которые мы вспомнили в предыдущем задании.
+# На первом шаге добавим метод pushleft, который вставляет новый элемент
+# в начало списка.
+# ( см. метод pushleft класса LinkedList )
+# -----------------------------------------------------------------------
+# Задание 4.6.2
+# Напишите функцию pushright, которая добавляет элемент в правую часть списка.
+# ( см. метод pushright класса LinkedList )
+# -----------------------------------------------------------------------
+
+# С удалением элементов несколько интереснее. Удалить элемент из начала
+# можно без особого труда: достаточно изменить указатель на первый элемент.
+# Удалить элемент из конца более затруднительно, потому что, удалив последний
+# элемент, мы потеряем ссылку на него. В таком случае время выполнения
+# операции будет равно O(n).
+#
+# Существуют способы улучшить и этот аспект. Одно из решений — создание
+# двусвязного списка, в котором помимо указателя на следующий элемент будет
+# храниться указатель и на предыдущий элемент. Или можно модифицировать
+# односвязный список, сохраняя ещё и указатель на предпоследний элемент.
+# Оба способа требуют дополнительной памяти, но в данном случае мы пожертвуем
+# производительностью ради памяти и скорости разработки (что тоже важно, кстати).
+
+# ( см. метод popleft класса LinkedList )
+
+# И немного более сложная процедура удаления последнего элемента:
+
+# ( см. метод popright класса LinkedList )
+
+# -----------------------------------------------------------------------
+# Задание 4.6.3
+# Как будет выглядеть список после выполнения последовательности операций?
+
+if __name__ == '__main__':
+    LL = LinkedList()
+    LL.pushright(1)
+    LL.pushleft(2)
+    LL.pushright(3)
+    LL.popright()
+    LL.pushleft(4)
+    LL.pushright(5)
+    LL.popleft()
+
+    print(LL)
+
+# Ответ: 2 1 5
+# -----------------------------------------------------------------------
+
+# Теперь, наконец, напишем функционал этого класса, чтобы он стал полноценным итератором.
+# ( см. методы iter и next класса LinkedList )
+
+# И в заключение напишем «магический» метод, возвращающий размер структуры данных.
+# ( см. метод __len__ класса LinkedList )
+
+#  Задание 4.6.4
+# Найдите размер списка из предыдущего задания.
+
+    print(len(LL))
+
+#########################################################################
+#########################################################################
+#########################################################################
+#########################################################################
Index: INTPY/C3_modules_import_files_data/C3_5_context_managers__with_.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/INTPY/C3_modules_import_files_data/C3_5_context_managers__with_.py b/INTPY/C3_modules_import_files_data/C3_5_context_managers__with_.py
new file mode 100644
--- /dev/null	(date 1661958713201)
+++ b/INTPY/C3_modules_import_files_data/C3_5_context_managers__with_.py	(date 1661958713201)
@@ -0,0 +1,191 @@
+######################################################################
+# C3.5. Контекстные менеджеры. Ключевое слово with,
+# принципы создания собственных контекстных менеджеров
+######################################################################
+
+# В этом юните поговорим про контекстные менеджеры и ключевое слово with.
+#
+# Для чего это всё нужно?
+#
+# И тут лучше всего начать с уже знакомого вам примера. Допустим, вам надо
+# открыть файл и записать в него секретную или не очень информацию. Как бы
+# вы это сделали, зная о принципах работы с файлами и про встроенную функцию open?
+#
+# Да примерно вот так:
+"""
+f = open("file.bin", "wt")
+f.write("MYSECRETINFO")
+f.close()
+"""
+
+# И это действительно будет работать. А теперь давайте представим, что вы забыли
+# закрыть файл и потеряли всю информацию в нём. Это не очень приятно. Особенно,
+# если вы писали, например, свою базу данных, и потеряли информацию в ней.
+# Но дело даже не в том, что вы могли забыть закрыть файл, даже если вы
+# человек-пунктуальность, я бы советовал вам не испытывать судьбу. Вы же
+# не станете чинить проводку самостоятельно, даже зная закон Ома и налету
+# определяя где «+», а где «-»? Вот и здесь так же. Для работы с ресурсами
+# лучше обратиться к специальным возможностям языка. Так вы точно
+# не выстрелите себе в ногу, при этом добившись такого же результата.
+#
+# Давайте договоримся о понятии «контекстный менеджер».
+#
+# Открытие происходит при входе в блок с помощью ключевого слова with.
+# Закрытие происходит, когда блок заканчивается. Например,
+# на входе — открывается файл, на выходе — закрывается.
+#
+# Ну и самый простой пример использования контекстного менеджера
+# с использованием ключевого слова with с файлами:
+
+with open("file.bin", "wt") as f: # открываем файл с помощью with
+    f.write("abcdefg")
+
+# В этом примере мы открываем файл с помощью контекстного менеджера,
+# который автоматически закроет его за нас. Почему бы просто не закрыть
+# файл методом .close(). Дело в том, что на выходе из контекстного менеджера
+# может понадобится выполнить не один десяток операций, в том числе обращений
+# к стороннему API или базе данных. Не станете же вы каждый раз писать один
+# и тот же код? И даже если вы напишите функцию или метод, делающий это за вас,
+# его опять надо не забыть вызвать, иначе всё будет напрасно. Конечно же в этом
+# случае нам легче просто написать контекстный менеджер и вызывать его каждый раз,
+# когда мы хотим, чтобы он выполнил всю грязную работу за нас.
+#
+# Пишутся контекстные менеджеры очень легко. Ведь, по сути, это всего-то по-особенному устроенные классы.
+
+##################################################################################
+# Чтобы написать контекстный менеджер нужно всего лишь помнить о нескольких вещах:
+##################################################################################
+
+#  1.   Нужно создать класс и написать в нём метод __enter__.
+#           Код в этом методе будет выполняться при входе в контекстный менеджер
+#           (при создании объекта с ключевым словом with).
+#  2.   Написать метод __exit__.
+#           Этот метод будет выполнять код, помещённый в него, на выходе.
+#  3.   Добавить в этот метод три дополнительных аргумента помимо self —
+#           exc_type, exc_val, exc_tb. Зачем они нужны, расскажу чуть позже.
+#
+# Ну а сейчас давайте попробуем написать простенький измеритель времени исполнения нашего кода:
+
+from datetime import datetime
+import time # проверять действие измерителя будем с помощью библиотеки time
+
+# вся суть этого измерителя заключается в том, что мы считаем разницу в секундах
+# между открытием и закрытием контекстного менеджера
+class Timer:
+    def __init__(self):
+        pass
+    def __enter__(self): # этот метод вызывается при запуске с помощью with.
+        # Если вы хотите вернуть какой-то объект, чтобы потом работать с ним в контекстном
+        # менеджере, как в примере с файлом, то просто верните этот объект через return
+        self.start = datetime.utcnow()
+        return None
+    def __exit__(self, exc_type, exc_val, exc_tb): # этот метод
+        # срабатывает при выходе из контекстного менеджера
+        print(f"Time passed: {(datetime.utcnow() - self.start).total_seconds()}")
+
+with Timer():
+    time.sleep(2) # засыпаем на 2 секунды
+
+# В консоль должно вывестись примерно следующее:
+# Time passed: 2.00099
+
+##################################################################################
+# В дополнение к комментариям в коде ещё хотелось бы сказать
+# пару слов об аргументах метода __exit__.
+#
+# О каждом из них по порядку:
+#
+#   1.  exc_type — это тип исключения, из-за которого вылетел контекстный менеджер.
+#           Если всё прошло успешно, то значение этого аргумента будет None.
+#   2.  exc_val — сообщение в исключении.
+#           Аналогично: если всё прошло успешно, этот аргумент будет None.
+#   3.  exc_tb — объект сообщения от интерпретатора.
+#           Лучше его вообще не трогать, если вы не разработчик языка, но, тем не менее,
+#           он всегда ждёт вас здесь. Возможно, когда-то, после нашего курса вы…
+#
+##################################################################################
+# Как можно было догадаться, Python был бы не Python, если бы у него не было
+# библиотек на любой крайний случай. В далёкой версии Python 2.6 появилась
+# возможность создания контекстных менеджеров через генераторы.
+##################################################################################
+# Давайте взглянем, как это можно сделать.
+#
+# Но перед этим хотелось бы разъяснить разницу в реализации. По сути, здесь разница
+# только в том, что контекстный менеджер на генераторах — это функция (для особо
+# привередливых — генератор). В ней до yield выполняется код, который мы могли бы
+# записать в __enter__, если бы делали контекстный менеджер в виде класса, а после
+# yield пишем код, который выполнился бы в __exit__. То есть до yield — всё, что
+# произойдёт при входе, после — всё, что на выходе.
+# Вот и вся разница. Как видите, она не велика.
+#
+# Давайте же теперь посмотрим код:
+
+# from datetime import datetime # разумеется
+# import time   # и это тоже, а вот дальше:
+
+from contextlib import contextmanager # импортируем нужный нам декоратор
+
+@contextmanager # оборачиваем функцию в декоратор contextmanager
+def timer():
+    start = datetime.utcnow()
+    yield
+    print(f"Прошло времени, сек: {(datetime.utcnow() - start).total_seconds()}")
+
+with timer():
+    time.sleep(2)
+
+# Результат работы такого контекстного менеджера на основе генераторов абсолютно такой же:
+# Time passed: 2.001097
+
+#
+##################################################################################
+# Теперь давайте подведём итоги данного юнита:
+##################################################################################
+# 1.  Мы узнали, зачем нужен контекстный менеджер и на практике
+#           познакомились с тем, какой он удобный.
+# 2.  Контекстный менеджер вызывается с помощью ключевого слова with.
+#           Он может возвращать или не возвращать объект для работы. Например,
+#           если контекстный менеджер подразумевает работу с каким-либо объектом,
+#           то надо добавить в запись: as *var*, где var — имя переменной в данном контексте.
+# 3.  Мы научились строить собственные контекстные менеджеры на основе классов. Для этого
+#           мы пишем класс со специальными методами def __enter__(self, …) и __exit__(self,
+#           exc_type, exc_val, exc_tb). __enter__ вызывается при входе в контекстный менеджер,
+#           __exit__ — при выходе (не забудьте добавить необходимые аргументы).
+# 4.  Научились строить контекстные менеджеры на основе генераторов и
+#           декоратора contextmanager из библиотеки contextlib.
+##################################################################################
+# Если вам осталось что-то не понятно, посмотрите видеоматериал по теме в начале юнита.
+# Надеюсь, после него вопросов не останется!
+
+# Ну и на этом всё о контекстных менеджерах. Не бойтесь применять их в работе, экспериментируйте!
+
+##################################################################################
+# Задание 3.5.6
+# Напишите контекстный менеджер, который умеет безопасно работать с файлами.
+# В конструктор объекта контекстного менеджера передаются два аргумента:
+# первый — путь к файлу, который надо открыть, второй — тип открываемого файла
+# (для записи, для чтения и т. д.).
+#
+# При входе в контекстный менеджер должен открываться файл, и возвращаться
+# объект для работы с этим файлом.
+#
+# При выходе из контекстного менеджера файл должен закрываться.
+# (Эталоном работы можно считать контекстный менеджер open).
+
+
+class OpenFile:
+    def __init__(self, path, type):
+        self.file = open(path, type, encoding="utf8")
+
+    def __enter__(self):
+        return self.file
+
+    def __exit__(self, exc_type, exc_val, exc_tb):
+        self.file.close()
+
+with OpenFile('test2.txt', 'wt') as f:
+    f.write("Пишу сие чрез такую занимательнейшую и \n"
+            "прелюбопытственнейшую штучку, коей является \n"
+            "презабавнейший скрипт под титлом \n"
+            "контекстный мэнэжэрр")
+    print(f.read())
Index: INTPY/C4_Algorythms_Data_structures/test445_par_chercker_modfied.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/INTPY/C4_Algorythms_Data_structures/test445_par_chercker_modfied.py b/INTPY/C4_Algorythms_Data_structures/test445_par_chercker_modfied.py
new file mode 100644
--- /dev/null	(date 1662135889343)
+++ b/INTPY/C4_Algorythms_Data_structures/test445_par_chercker_modfied.py	(date 1662135889343)
@@ -0,0 +1,25 @@
+# Задание 4.4.5
+# Модифицируйте функцию проверки баланса скобок для двух видов скобок: круглых и квадратных.
+#
+# Для реализации такого алгоритма может быть полезным создание словаря, в котором
+# закрывающая скобка — ключ, открывающая — значение.
+
+pairs = {")": "(", "]": "["}
+
+
+def par_checker_mod(string):
+    stack = []
+
+    for s in string:
+        if s in pairs.values():
+            stack.append(s)
+        elif s in pairs.keys():
+            if len(stack) > 0 and stack[-1] == pairs[s]:
+                stack.pop()
+            else:
+                return False
+    return len(stack) == 0
+
+
+str_ = "(попробуем) испытать [систему] с (разными) [(скобками)]"
+print(par_checker_mod(str_))
Index: INTPY/C4_Algorythms_Data_structures/C4_4_Main_data_structures_list_stack_queue.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/INTPY/C4_Algorythms_Data_structures/C4_4_Main_data_structures_list_stack_queue.py b/INTPY/C4_Algorythms_Data_structures/C4_4_Main_data_structures_list_stack_queue.py
new file mode 100644
--- /dev/null	(date 1662215918082)
+++ b/INTPY/C4_Algorythms_Data_structures/C4_4_Main_data_structures_list_stack_queue.py	(date 1662215918082)
@@ -0,0 +1,414 @@
+#########################################################################
+# C4.4. Основные структуры данных: список, стек, очередь
+#########################################################################
+
+#########################################################################
+# Списки: односвязные и двусвязные
+#########################################################################
+
+# После очень тесного знакомства с массивами другие структуры данных будут
+# восприниматься заметно легче, потому что во многом принципы их работы очень схожи.
+#
+# Сейчас мы перейдём к структуре данных «список». Как уже отмечалось, список
+# как структуру данных стоит отличать от одноименного типа данных в Python.
+# Что называется list (список) в Python — является динамическим массивом.
+# Далее под списком будет пониматься именно «список как структура данных».
+#
+# Внешне список схож с массивом.
+#
+# Список — это также упорядоченный набор элементов. Однако, в отличие от массива,
+# который хранится последовательно в одной области памяти, и каждой ячейке линейно
+# соответствует определённый индекс, список может быть хаотично распределён в памяти.
+# Порядок в этой структуре данных задаётся наличием указателей на следующий
+# (и/или предыдущий) элемент в списке.
+
+# Если в каждой ячейке памяти хранится указатель только на следующий элемент,
+# то список называется односвязным. Если указатель и на предыдущий и на следующий
+# — имеем двусвязный список. Помимо прочего в ячейке может храниться «индекс»
+# — некоторый порядковый номер объекта в списке. Однако доступ к элементу списка
+# по индексу сильно отличается от аналогичной операции в массиве из-за особенностей
+# хранения. Часто используется хранение в первой ячейке указателя на последний элемент.
+
+# --------------------------------------------------------------------------------
+# Способ хранения списков имеет свои плюсы и минусы.
+# --------------------------------------------------------------------------------
+#   1. Вставка элемента в конец списка происходит за константное время, если
+#       в первой ячейке хранится указатель на последний элемент. Иначе требуется
+#       проход по всем элементам до последнего, что потребует O(n) операций.
+#       Действительно, мы можем вставить элемент на последнее место, изменив
+#       указатель в первой ячейке, чтобы он указывал на новый элемент.
+#
+#   2. Вставка элемента в начало также может быть произведена за константное время,
+#       ведь достаточно в новом элементе вставить указатель на тот, что был первым,
+#       и дописать указатель на последний элемент.
+#   3. В списке также можно вставить элемент на произвольное место. В отличие от
+#       массива, в списках нет необходимости перемещать элементы, однако здесь эту
+#       операцию всё равно можно сделать асимптотически за O(n) в худшем случае.
+#       Дело в том, что для поиска нужного положения нового элемента придётся
+#       пройтись от первого указателя до необходимого положения в списке.
+#       И, например, для вставки элемента n-1 на индекс нужно будет пройти все элементы
+#       от 0-го до n-1-го и только после этого производить вставку.
+#   4. Удаление элемента из начала так же, как и вставка, производится за константное время.
+#       Как и в первых двух случаях, нужно всего лишь изменить положение нужных указателей.
+#   5. А вот удаление элемента из произвольного места может занять линейное время. Ответ
+#       кроется в том, что нужный элемент требуется найти (по «индексу» или значению)
+#       проходом от 0-го до искомого элемента. И даже в случае удаления последнего элемента
+#       мы вынуждены пройти весь список, чтобы в первую ячейку записать обновлённый указатель
+#       на последний элемент.
+#  Такой проблемы в двусвязных списках, очевидно, нет.
+#   6. Расширение списка. Благодаря такому способу хранения не требует переносов всей
+#       структуры в другую область памяти, как это было в случае динамических массивов,
+#       поэтому добавление к первому списку размера n элементов списка размера m
+#       потребует только O(m) времени.
+#   7. Общий размер списка может храниться в самой структуре, и тогда его можно узнать
+#       за константное время, но это требует дополнительной памяти. Если в конкретной
+#       реализации списка не предусмотрено хранение размера, то пересчет элементов
+#       займет O(n) операций.
+# --------------------------------------------------------------------------------
+# Таким образом, можно сказать, что список наиболее удобен, когда нужно обрабатывать
+# элементы в определённом порядке без использования индексации.
+##################################################################################
+#
+#
+##################################################################################
+# Стек (stack)
+##################################################################################
+
+# Рассмотренные нами структуры данных имеют огромные области применения, и благодаря
+# этому появилось несколько надстроек над ними как наиболее частые способы применения.
+#
+# Сначала приведём «бытовую» аналогию, постепенно приближаясь к абстрактному понятию
+# стека как одной из таких надстроек.
+
+# Пример 1
+#
+# Вспомним нашу аналогию с ужином. Ужин закончился, тарелки постепенно перемещаются
+# в раковину — одна на другую. Тем самым определяется порядок, в котором эти тарелки
+# будут вымыты, если у вас, конечно, нет желания каждый раз доставать тарелки из
+# середины. Сначала берётся верхняя, потом следующая за ней и так дальше, пока тарелки
+# не кончатся. И точно также при подготовке к ужину мы берём стопку чистых тарелок
+# и выставляем их друг за другом. Каждый раз удобнее брать сверху. Принцип схож —
+# есть упорядоченный набор элементов (прямо как массив или список), но производится
+# всегда две операции — взять сверху или положить сверху.
+# Как вы уже наверное догадались — это стек.
+
+# Пример 2
+#
+# Рассмотрим другой пример, более приближенный к computer science. Вспомним рекурсию
+# (она нам ещё не раз пригодится в этом модуле).
+#
+# Пусть у нас есть рекурсивная функция p(n). Мы вызываем её с аргументом p(5),
+# она вызывает p(4), та, в свою очередь, снова уменьшает аргумент и так до нуля.
+# Однако вычисления будут происходить наоборот! Сначала вычисляется p(0), затем p(1)
+# доходя до самого первого вызова функции.
+
+##################################################################################
+# Задание 4.4.1
+# --------------------------------------------------------------------------------
+# Убедитесь в этом самостоятельно, написав функцию p(n), вызывающую эту же самую
+# функцию с аргументом, уменьшенным на единицу, и после чего печатающей значение
+# аргумента. Обратите внимание на описанный порядок действий и наличие условие
+# выхода из рекурсии.
+# Ответ:
+
+def f(n):
+    if n == 0:
+        return  # взять на заметку! Не встречал такого варианта: return без аргументов
+    else:
+        f(n - 1)
+        print(n)  # до этого шага функция доходит, только когда уже опускаться некуда.
+
+
+f(5)
+
+
+# Здесь мы видим, что сначала выполнились действия последней функции в порядке вызовов,
+# затем предпоследней и т. д., пока не дойдём до первого.
+#
+# Такой принцип имеет общепринятое название — LIFO — Last In First Out (последний вошел
+# — первый вышел). И именно этот принцип реализует стек.
+#
+# Иными словами, стек — это структура данных, реализующая LIFO.
+
+##################################################################################
+# Операции над стеком
+##################################################################################
+
+# Стек может быть реализован как через динамические массивы, так и через списки.
+# Но прежде, чем перейдём к обсуждению конкретной реализации стека, попробуем понять
+# механизмы его работы, а также сложность операций со стеком (куда без них).
+#
+#   1. Вставка элемента в стек (push).
+#           Работает за O(1), если стек реализован через список и, в среднем,
+#           также O(1), если реализован через динамический массив.
+#   2. Удаление верхнего элемента из стека (pop).
+#           Так же, как и вставка, удаление верхнего элемента происходит за O91).
+#           Действительно, в массиве удаление последнего элемента происходит за
+#           константное время, как и в списке, если он двусвязный.
+#   3. Получение значения последнего элемента без удаления (top).
+#           Аналогично предыдущим операциям получение значения последнего элемента
+#           происходит за O(1).
+#   4. Общий размер стека (size).
+#           Здесь уже всё зависит от реализации. В случае односвязного списка O(1),
+#           если это значение хранится в самой структуре, или O(n), если нужен
+#           проход по всем элементам для их пересчёта. В массиве операция
+#           получения размера занимает константное время.
+
+# --------------------------------------------------------------------------------
+#  Задание 4.4.2
+# Какую верхнюю границу сложности (худший случай) будет иметь вставка элемента в стек,
+# если он реализован через динамический массив. Необходимо вспомнить особенности
+# расширения массивов.
+# Подсказака: В худшем случае размера выделенной памяти (capacity) для динамического
+# массива может не хватить, поэтому придётся перемещать все элементы стека-массива в
+# другую область памяти. Сколько операций для этого потребуется?
+# Ответ: O(n)
+# --------------------------------------------------------------------------------
+
+# Как видно из описания операций, все операции со стеком (как минимум, в среднем)
+# можно сделать за константное время. Этим объясняется столь широкое распространение
+# стека. Его можно эффективно реализовать с помощью типа данных list языка Python.
+# Проведём параллели между операциями над стеком и методами списков.
+
+# Стек является удобным способом представления различных данных, но сейчас мы рассмотрим
+# один пример, который является важным при анализе математических выражений или при анализе кода.
+#
+# Наверняка вы не раз сталкивались с предупреждением от среды разработки или ошибкой
+# от компилятора, связанной с неправильной расстановкой скобок. Сейчас мы посмотрим,
+# как можно реализовать проверку строки на корректную расстановку скобок с помощью стека.
+#
+# Примем за корректную расстановку скобок такую, что для каждой открывающей существует
+# закрывающая скобка — такая, что находится на одном «уровне» с ней. Примеры:
+#
+# ()
+# (()())
+# (()(()(()())))
+
+# Наличие любой открытой, но не закрытой скобки является ошибкой. Ровно как и наличие
+# закрывающей скобки без открывающей.
+#
+# Напишем функцию par_checker(string), которая проверяет строку string на корректность
+# расстановки скобок.
+
+def par_checker(string):
+    stack = []  # инициализируем стек
+
+    for s in string:  # читаем строку посимвольно
+        if s == "(":  # если открывающая скобка,
+            stack.append(s)  # добавляем её в стек
+        elif s == ")":
+            # если встретилась закрывающая скобка, то проверяем,
+            # пуст ли стек и является ли верхний элемент открывающей скобкой
+            if len(stack) > 0 and stack[-1] == "(":
+                stack.pop()  # удаляем из стека
+            else:  # иначе завершаем функцию с False
+                return False
+    # если стек пустой, то незакрытых скобок не осталось
+    # значит возвращаем True, иначе - False
+    return len(stack) == 0
+
+
+# Так как функция проверяет вхождение только скобок, то наличие других символов
+# эту функцию не затронет. Убедитесь в этом самостоятельно.
+if __name__ == '__main__':
+    a = "Мы (тоже (когда-то)) (были) молодыми ((и для) (нас) пели (соловьи))"
+    print("Все скобки закрыты: ", par_checker(a))
+
+#  Задание 4.4.4
+# Что будет являться результатом работы функции при следующей входной строке? (5+6)*(7+8)/(4+3)
+# Ответ: True
+
+# --------------------------------------------------------------------------------
+# С помощью стека проверять баланс только круглых скобок может показаться слишком
+# затратным. И это действительно так. Однако написанную нами функцию можно расширить
+# для проверки баланса скобок разного рода: круглых, квадратных и фигурных, например.
+
+# --------------------------------------------------------------------------------
+# Задание 4.4.5
+# Модифицируйте функцию проверки баланса скобок для двух видов скобок: круглых и квадратных.
+#
+# Для реализации такого алгоритма может быть полезным создание словаря, в котором
+# закрывающая скобка — ключ, открывающая — значение.
+
+pairs = {")": "(", "]": "["}
+str_ = "(попробуем) испытать [систему] с (разными) [(скобками)]"
+
+
+def par_checker_mod(string):
+    stack = []
+
+    for s in string:
+        if s in pairs.values():
+            stack.append(s)
+        elif s in pairs.keys():
+            if len(stack) > 0 and stack[-1] == pairs[s]:
+                stack.pop()
+            else:
+                return False
+    return len(stack) == 0
+
+
+if __name__ == '__main__':
+    print(par_checker_mod(str_))
+
+
+##################################################################################
+# Очередь
+##################################################################################
+#
+# Другой вид последовательности, который скорее всего более привычен
+# в бытовом смысле — это очередь.
+#
+# В отличие от стека он работает по принципу FIFO — First In First Out
+# (первый вошёл — первый вышел). Прямо как в любимой всеми очереди к врачу, например.
+#
+# Очередь может быть реализована как на массивах, так и на списках. В связи
+# с наличием динамического массива в Python (list) попробуем построить очередь,
+# используя эту структуру данных. Она имеет своё ограничение из-за того, что
+# удаление из конца или вставка элемента в начало имеют сложность .
+#
+# Чтобы обойти это ограничение, зафиксируем несколько свойств очереди:
+#
+#    1.     Определим максимальную длину очереди — N_max.
+#    2.     При переполнении будем запрещать добавление элементов в очередь.
+#    3.     Зафиксируем два указателя:  head (начало) и tail (хвост) очереди.
+#    4.     Закольцуем очередь таким образом, что если указатель tail >= n_max,
+#               то мы перемещаем его в начало.
+
+# По такой схеме может получиться так, что начало очереди в конце списка,
+# а хвост — в его начале.
+
+# -------------------------------------------------------
+#       Для очереди можно определить несколько операций:
+# -------------------------------------------------------
+#   1. Вставка элемента в хвост очереди (push).
+#   2. Получение элемента из начала очереди (top).
+#   3. Удаление элемента из начала очереди (pop).
+#   4. Проверка наличия элементов в очереди (is_empty).
+#   5. Получение размера очереди (size).
+#
+# Все они выполняются за . И это то, что нужно!
+#
+# Попробуем создать обработчик задач на бесконечном цикле с использованием очереди:
+
+# Создадим класс Queue — нужная нам очередь
+class Queue:
+    # Конструктор нашего класса, в нём происходит нужная инициализация объекта
+    def __init__(self, max_size):
+        self.max_size = max_size  # размер очереди
+        self.task_num = 0  # будем хранить сквозной номер задачи
+
+        self.tasks = [0 for _ in range(self.max_size)]  # инициализируем список с нулевыми элементами
+        self.head = 0  # указатель на начало очереди
+        self.tail = 0  # указатель на элемент следующий за концом очереди
+
+    # !!! Класс далее нужно дополнить методами !!!
+    def is_empty(self):  # очередь пуста?
+        # да, если указатели совпадают и в них содержится ноль
+        return self.head == self.tail and self.tasks[self.head] == 0
+
+    def size(self):  # получаем размер очереди
+        if self.is_empty():  # если она пуста
+            return 0  # возвращаем ноль
+        elif self.head == self.tail:  # иначе, если очередь не пуста, но указатели совпадают
+            return self.max_size  # значит, очередь заполнена
+        elif self.head > self.tail:  # если хвост очереди сместился в начало списка
+            return self.max_size - self.head + self.tail
+        else:  # или если хвост стоит правее начала
+            return self.tail - self.head
+
+    def add(self):
+        self.task_num += 1  # увеличиваем порядковый номер задачи
+        self.tasks[self.tail] = self.task_num  # добавляем его в очередь
+        print(f"Задача №{self.tasks[self.tail]} добавлена")
+
+        # увеличиваем указатель на 1 по модулю максимального числа элементов
+        # для зацикливания очереди в списке
+        self.tail = (self.tail + 1) % self.max_size
+
+    def show(self):  # выводим приоритетную задачу
+        print(f"Задача №{self.tasks[self.head]} в приоритете")
+
+    def do(self):  # выполняем приоритетную задачу
+        print(f"Задача №{self.tasks[self.head]} выполнена")
+        # после выполнения зануляем элемент по указателю
+        self.tasks[self.head] = 0
+        # и циклично перемещаем указатель
+        self.head = (self.head + 1) % self.max_size
+
+
+# Используем класс
+size = int(input("Определите размер очереди: "))
+q = Queue(size)
+
+while True:
+    cmd = input("Введите команду:")
+    if cmd == "empty":
+        if q.is_empty():
+            print("Очередь пустая")
+        else:
+            print("В очереди есть задачи")
+    elif cmd == "size":
+        print("Количество задач в очереди:", q.size())
+    elif cmd == "add":
+        if q.size() != q.max_size:
+            q.add()
+        else:
+            print("Очередь переполнена")
+    elif cmd == "show":
+        if q.is_empty():
+            print("Очередь пустая")
+        else:
+            q.show()
+    elif cmd == "do":
+        if q.is_empty():
+            print("Очередь пустая")
+        else:
+            q.do()
+    elif cmd == "exit":
+        for _ in range(q.size()):
+            q.do()
+        print("Очередь пустая. Завершение работы")
+        break
+    else:
+        print("Введена неверная команда")
+
+# Итак, первым делом реализуем проверку наличия элементов в очереди.
+#
+# Задание 4.4.6
+# Добавьте в класс Queue метод is_empty, который проверяет наличие элементов
+# в очереди, используя указатели head и tail. Запрещается использование
+# функции len(list_), так как её сложность O(n).
+
+# Задание 4.4.7
+# Добавьте в класс Queue метод size, который возвращает текущий размер очереди.
+# Учтите, что необходимо рассмотреть несколько случаев: когда очередь пустая,
+# когда очередь полная (какому условию соответствует?), а также отдельное
+# внимание стоит обратить на тот случай, когда хвост очереди переместился
+# в начало списка (закольцевался).
+
+# Задание 4.4.8
+# Добавьте в класс Queue метод add, который добавляет задачу в конец очереди.
+# Также учтите, что размер массива ограничен и при достижении этого предела,
+# необходимо перенести указатель в положение 0. После добавления задачи в очередь,
+# она должна вывести уведомление об этом в формате:
+#
+# "Задача №1 добавлена"
+
+# Задание 4.4.9
+# Добавьте в класс Queue метод show, печатающий информацию о приоритетной
+# задаче в формате
+#
+# "Задача №1 в приоритете"
+
+# Задание 4.4.10
+# Добавьте в класс Queue метод do, который печатает в консоль задачу
+# (=выполняет её) и, соответственно, удаляет её из очереди, присваивая
+# ей значение 0. Формат вывода:
+#
+# "Задача №1 выполнена"
+
+#  Задание 4.4.11
+# Укажите номера задач, которые выполнятся при завершении работы алгоритма,
+# через запятую, соблюдая порядок выполнения. Команды очереди записываются
+# в следующем порядке:
Index: INTPY/C4_Algorythms_Data_structures/C4_5_Nonlinear_data_structures__graphs_n_trees.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/INTPY/C4_Algorythms_Data_structures/C4_5_Nonlinear_data_structures__graphs_n_trees.py b/INTPY/C4_Algorythms_Data_structures/C4_5_Nonlinear_data_structures__graphs_n_trees.py
new file mode 100644
--- /dev/null	(date 1662298468385)
+++ b/INTPY/C4_Algorythms_Data_structures/C4_5_Nonlinear_data_structures__graphs_n_trees.py	(date 1662298468385)
@@ -0,0 +1,481 @@
+#########################################################################
+# C4.5. Нелинейные структуры данных: графы и деревья
+#########################################################################
+#
+# Графы
+# -----------------------------------------------------------------------
+# Совершенно другой тип структур данных представляют собой графы.
+# -------------------------------------------------------------------------------
+# Граф — это структура, имеющая узлы (вершины графа) и связи между ними (рёбра).
+# -------------------------------------------------------------------------------
+# На этой картинке можно увидеть несколько примеров графов: (рисунок)
+
+# Как вы видите, графы бывают самых разных видов и могут подлежать классификации
+# по разным критериям. О том, какие бывают виды графов, можно прочитать в этой статье.
+# https://function-x.ru/graphs2_definitions_classes.html
+
+# Нам более важно сейчас понимать, как могут быть представлены графы в памяти компьютера.
+
+# Первый способ представления называется матрица смежности.
+
+# В матрице смежности (двумерном массиве) каждая строка и каждый столбец
+# соответствуют вершине. На пересечении столбца x и строки y стоит 1, если
+# эти две вершины x и y соединены ребром, иначе стоит ноль. Такой способ
+# представления является эффективным, если граф является плотным — в нём
+# много рёбер. Однако он сильно теряет в эффективности, если в нём
+# присутствует большое количество вершин, но мало рёбер.
+
+# Второй способ представления — список смежности. (рисунок)
+#
+# Существует много реализаций графов списком смежности. Основная суть сводится
+# к тому, чтобы хранить массив (список, словарь) связанных списков. Каждый
+# внутренний список, в свою очередь, хранит вершины, с которыми имеет связь
+# вершина, образующая список.
+
+# Список смежности легко реализуется с помощью двух встроенных типов Python
+# — словарь (dict) и список (list).
+#
+# Например, граф из картинки выше можно было бы представить следующим образом:
+
+G = {0: [1, 2, 3],
+     1: [0, 2],
+     2: [0, 1],
+     3: [0]}
+
+# Большинство необходимых операций с этими структурами имеют невысокую сложность
+# по сравнению с двумерным массивом. Давайте посмотрим на них в сравнении:
+
+# ---------------------------------------------------------------------
+# Задание 4.5.1
+# Представьте эту часть схемы в виде графа и создайте список смежности,
+# используя словарь. (рисунок фрагмента метро Питера)
+
+G = {"Адмиралтейская":
+         ["Садовая"],
+     "Садовая":
+         ["Спасская",
+          "Сенная площадь",
+          "Адмиралтейская",
+          "Звенигородская"],
+     "Сенная площадь":
+         ["Садовая",
+          "Спасская"],
+     "Спасская":
+         ["Садовая",
+          "Сенная площадь",
+          "Достоевская"],
+     "Звенигородская":
+         ["Пушкинская",
+          "Садовая"],
+     "Пушкинская":
+         ["Звенигородская",
+          "Владимирская"],
+     "Достоевская":
+         ["Владимирская",
+          "Пушкинская"],
+     "Владимирская":
+         ["Достоевская",
+          "Пушкинская"]}
+
+# print(G)
+# --------------------------------------------------------------------
+
+# Граф, помимо прочего, может быть взвешенным — каждое ребро может
+# иметь свой вес в графе. (рисунок)
+
+# Такой граф можно представить в виде словаря словарей, где значение
+# ключа представляет собой вес ребра.
+#
+# Любой невзвешенный граф имеет одинаковый вес рёбер, поэтому можем
+# представить один из примеров выше в виде «словаря словарей», несмотря
+# на то, что все «веса» рёбер одинаковы.
+
+G = {0: {1: 1,
+         2: 1,
+         3: 1},
+     1: {0: 1,
+         2: 1},
+     2: {0: 1,
+         1: 1},
+     3: {0: 1}}
+
+# print(G)
+# --------------------------------------------------------------------
+# Задание 4.5.2
+# Возьмите граф из предыдущего задания (с картой метро) и постройте из него
+# взвешенный граф. В качестве весов используйте время, необходимое для того,
+# чтобы доехать (или перейти) с одной станции на другую. Для этого можно
+# воспользоваться сервисом Яндекс.Метро.
+
+G = {
+    "Адмиралтейская": {
+        "Садовая": 4},
+    "Садовая": {
+        "Сенная площадь": 4,
+        "Спасская": 3,
+        "Адмиралтейская": 4,
+        "Звенигородская": 5},
+    "Сенная площадь": {
+        "Садовая": 4,
+        "Спасская": 4},
+    "Спасская": {
+        "Садовая": 3,
+        "Сенная площадь": 4,
+        "Достоевская": 6},
+    "Звенигородская": {
+        "Пушкинская": 3,
+        "Садовая": 5},
+    "Пушкинская": {
+        "Звенигородская": 3,
+        "Владимирская": 4},
+    "Владимирская": {
+        "Достоевская": 3,
+        "Пушкинская": 4},
+    "Достоевская": {
+        "Владимирская": 3,
+        "Спасская": 6}
+}
+
+# print(G)
+# ----------------------------------------------------------------------
+
+# При работе с графами одна из наиболее частых задач — поиск кратчайшего пути
+# от одной вершины к другой. Сейчас мы с вами попытаемся реализовать алгоритм,
+# позволяющий найти его.
+# -------------------------------------
+# Он носит название «алгоритм Дейкстры».
+# -------------------------------------
+# Его суть заключается в том, чтобы последовательно перебирать вершины одну за
+# другой в поисках кратчайшего пути до этой вершины. Вершину будем называть
+# предком для другой, если она идёт раньше по пути перемещения по рёбрам в
+# графе. Ближайший предок — это предок, имеющий прямую связь (ребро) с
+# рассматриваемой. Рассмотрим этот алгоритм также на примере взвешенного
+# графа станций метро из последней задачи.
+#
+# Для начала нам потребуется дополнительная структура данных для хранения
+# расстояний. Если вершины пронумерованы числами, то можно использовать массив,
+# но т. к. мы имеем проименованные узлы, то удобнее пользоваться словарём.
+#
+# D = {k : 100 for k in G.keys()}
+
+# Проинициализируем словарь расстояний числами, которые заведомо больше
+# максимального расстояния в графе. Значения 100 в данной задаче нам будет
+# более чем достаточно. Одну из вершин мы должны выбрать как стартовую.
+# Поэтому стартовая вершина будет предком для всех остальных. Расстояние для
+# неё (от неё же самой) будет равно нулю. Пусть это будет «Адмиралтейская».
+
+# D["Адмиралтейская"] = 0
+
+# Также нам потребуется хранить словарь с булевыми значениями, в котором
+# True — если вершина просмотрена, иначе — False.
+#
+# U = {k : False for k in G.keys()}
+
+# Далее мы должны пройти циклом из n итераций, выбирая вершину с наименьшим
+# D среди непросмотренных. Очевидно, что на первой итерации будет выбрана
+# стартовая вершина. Из неё мы должны проверить все вершины, в которые можем
+# перейти, и в D записать наименьшее расстояние до них. Пока что мы можем идти
+# только из стартовой вершины, поэтому запишутся именно эти расстояния.
+# Стартовая вершина станет помеченной как уже просмотренная. После чего начнётся
+# поиск вершины с минимальным D из уже просмотренных (куда можно добраться из
+# стартовой). От неё также будут строиться возможные ребра и проверяться минимум
+# расстояний. И так далее, пока процесс не завершится. Утверждается, что
+# достаточно числа итераций равного количеству вершин. При достижении этого
+# алгоритм завершится корректно.
+
+D = {k: 100 for k in G.keys()}  # расстояния
+start_k = 'Адмиралтейская'  # стартовая вершина
+D[start_k] = 0  # расстояние от неё до самой себя равно нулю
+U = {k: False for k in G.keys()}  # флаги просмотра вершин
+
+for _ in range(len(D)):
+    # выбираем среди непросмотренных наименьшее по расстоянию
+    min_k = min([k for k in U.keys() if not U[k]], key=lambda x: D[x])
+
+    for v in G[min_k].keys():  # проходимся по всем смежным вершинам
+        D[v] = min(D[v], D[min_k] + G[min_k][v])  # минимум
+    U[min_k] = True  # просмотренную вершину помечаем
+
+# Результат работы программы можно увидеть в словаре D.
+if __name__ == '__main__':
+    for k, v in D.items():
+        print(k, ':', v)
+
+# В нём отражено кратчайшее расстояние от «Адмиралтейской» до станции,
+# которая задаёт ключ.
+#
+# Таким образом мы реализовали тот же самый алгоритм, который использует
+# Яндекс для поиска кратчайшего пути между станциями!
+#########################################################################
+# Алгоритм Дейкстры можно модифицировать таким образом, что можно определить
+# не только величину пути, но ещё и сами вершины минимального пути.
+#
+# Для этого определим ещё один словарь P, в котором будем для каждой вершины
+# хранить вершину-предок с минимальным расстоянием.
+#
+# P = {k : None for k in G.keys()}
+
+# Задание 4.5.3
+# Модифицируйте алгоритм Дейкстры таким образом, что в массив P по
+# соответствующему ключу будет записываться предок с минимальным
+# расстоянием, если это необходимо.
+
+
+G = {
+    "Адмиралтейская": {
+        "Садовая": 4},
+    "Садовая": {
+        "Сенная площадь": 4,
+        "Спасская": 3,
+        "Адмиралтейская": 4,
+        "Звенигородская": 5},
+    "Сенная площадь": {
+        "Садовая": 4,
+        "Спасская": 4},
+    "Спасская": {
+        "Садовая": 3,
+        "Сенная площадь": 4,
+        "Достоевская": 6},
+    "Звенигородская": {
+        "Пушкинская": 3,
+        "Садовая": 5},
+    "Пушкинская": {
+        "Звенигородская": 3,
+        "Владимирская": 4},
+    "Владимирская": {
+        "Достоевская": 3,
+        "Пушкинская": 4},
+    "Достоевская": {
+        "Владимирская": 3,
+        "Спасская": 6}
+}
+
+D = {k: 100 for k in G.keys()}  # расстояния
+start_k = 'Адмиралтейская'  # стартовая вершина
+D[start_k] = 0  # расстояние от неё до самой себя равно нулю
+U = {k: False for k in G.keys()}  # флаги просмотра вершин
+P = {k: None for k in G.keys()}  # предки
+
+for _ in range(len(D)):
+    # выбираем среди непросмотренных наименьшее по расстоянию
+    min_k = min([k for k in U.keys() if not U[k]], key=lambda x: D[x])
+
+    for v in G[min_k].keys():  # проходимся по всем смежным вершинам
+        if D[v] > D[min_k] + G[min_k][v]:  # если расстояние от текущей вершины меньше
+            D[v] = D[min_k] + G[min_k][v]  # то фиксируем его
+            P[v] = min_k  # и записываем как предок
+    U[min_k] = True  # просмотренную вершину помечаем
+
+pointer = "Достоевская"  # куда должны прийти
+path = []  # список с вершинами пути
+while pointer is not None:  # перемещаемся, пока не придём в стартовую точку
+    path.append(pointer)
+    pointer = P[pointer]
+
+path.reverse()  # разворачиваем путь
+for v in path:
+    print(v)
+
+
+# ---------------------------------------------------------------------
+#  Задание 4.5.4
+# Запишите станции в порядке вывода через запятую и пробел (в именительном
+# падеже с заглавной буквы), если нужно найти кратчайший путь
+# от Адмиралтейской до Владимирской.
+# Ответ: Адмиралтейская, Садовая, Звенигородская, Пушкинская, Владимирская
+
+#########################################################################
+# Деревья
+#########################################################################
+
+# Один из наиболее часто используемых подвидов графов — это деревья.
+#
+# Чтобы граф считался деревом, необходимо выполнение нескольких условий:
+#
+#    1.     Граф должен быть связным — не должно отсутствовать вершин без рёбер.
+#    2.     Должны отсутствовать циклы.
+#    3.     Часто под деревьями подразумеваются только неориентированные и невзвешенные графы.
+#
+# При соблюдении этих условий граф можно визуально представить в виде структуры,
+# напоминающей обычное дерево. Только, как правило, оно «растёт» вниз.
+#
+# В дереве можно выделить:
+#
+#    -  корневой узел;
+#    -  потомков;
+#    -  лист или терминальный узел — узел, не имеющий потомков;
+#    -  внутренние узлы — некорневые узлы, имеющие хотя бы одного потомка.
+#
+# Древовидные структуры мы видим повсеместно: фамильное древо, структура
+# организаций, которая тоже чаще всего иерархическая. Или же, например,
+# объектная модель документов (DOM) в языке HTML, с которой мы
+# познакомимся в следующих модулях.
+#
+# В зависимости от максимального количества потомков в одной вершине различают:
+#
+#    -  бинарные;
+#    -  тернарные деревья;
+#    -  n-арные деревья (с максимальным количеством потомков n);
+#    -  2-3 деревья, 2-3-4, в которых помимо увеличенного количества потомков
+#           в самом узле может храниться больше данных.
+#
+# О таких деревьях в курсе мы говорить не будем, но после знакомства с основной
+# информацией о бинарных деревьях, можно обратиться к статье (https://habr.com/ru/post/273687/)
+#
+# Итак, рассмотрим бинарное дерево. Основное его свойство заключается в том, что
+# у каждого узла может быть не более 2 потомков — соответственно, левый и/или правый.
+# ( рисунок )
+# Линейные структуры данных (массивы, списки, очереди, стеки) более понятны интуитивно.
+# Но как же хранить в памяти деревья? Здесь нам поможет знание объектно-ориентированного
+# программирования, а воспользуемся мы принципом, по которому хранятся списки в памяти.
+# Напомним, что каждый элемент списка хранит собственное значение и указатель
+# на следующий элемент.
+#
+# В нашей структуре данных, в каждом узле бинарного дерева мы будем хранить
+# указатель на левого и правого потомка.
+
+class BinaryTree:
+    def __init__(self, value):
+        self.value = value
+        self.left_child = None
+        self.right_child = None
+
+    # Мы создали класс узла, в конструкторе которого записали значение, оно
+    # должно храниться в нём. Также инициализировали левого и правого потомка.
+    # Пока что в них ничего не хранится — нужно иметь процедуру вставки новых
+    # элементов. Напишем разные методы для вставки на место левого потомка и
+    # на место правого потомка.
+    def insert_left(self, next_value):
+        if self.left_child is None:
+            self.left_child = BinaryTree(next_value)
+        else:
+            new_child = BinaryTree(next_value)
+            new_child.left_child = self.left_child
+            self.left_child = new_child
+        return self
+
+    # Поясним, что здесь произошло. Если в текущем узле нет левого потомка, то
+    # новый узел вставляем на его место, если левый потомок уже существует — он
+    # становится таким же левым потомком, но уже нового узла. Иными словами, он
+    # остаётся левым, но его глубина увеличивается. Аналогично поступим с правым.
+    def insert_right(self, next_value):
+        if self.right_child is None:
+            self.right_child = BinaryTree(next_value)
+        else:
+            new_child = BinaryTree(next_value)
+            new_child.right_child = self.right_child
+            self.right_child = new_child
+        return self
+
+    def pre_order(self):
+        print(self.value, end=' ')  # процедура обработки
+
+        if self.left_child is not None:  # если левый потомок существует
+            self.left_child.pre_order()  # рекурсивно вызываем функцию
+
+        if self.right_child is not None:  # если правый потомок существует
+            self.right_child.pre_order()  # рекурсивно вызываем функцию
+
+    def post_order(self):
+        if self.left_child is not None:  # если левый потомок существует
+            self.left_child.post_order()  # рекурсивно вызываем функцию
+
+        if self.right_child is not None:  # если правый потомок существует
+            self.right_child.post_order()  # рекурсивно вызываем функцию
+
+        print(self.value)  # процедура обработки
+
+    def in_order(self):
+        if self.left_child is not None:  # если левый потомок существует
+            self.left_child.in_order()  # рекурсивно вызываем функцию
+
+        print(self.value)  # процедура обработки
+
+        if self.right_child is not None:  # если правый потомок существует
+            self.right_child.in_order()  # рекурсивно вызываем функцию
+
+
+
+# В обоих случаях мы возвращаем ссылку на текущий узел. Это нам необходимо,
+# чтобы создавать цепочки действий. Рассмотрим на примере:
+
+A_node = BinaryTree('A').insert_left('B').insert_right('C')
+
+# -----------------------------------------------------------------------
+# Задание 4.5.5
+# Реализуйте структуру дерева при помощи класса BinaryTree. (рис.)
+# Ответ:
+
+# создаём корень и его потомков /7|2|5\
+node_root = BinaryTree(2).insert_left(7).insert_right(5)
+# левое поддерево корня /2|7|6\
+node_7 = node_root.left_child.insert_left(2).insert_right(6)
+# правое поддерево предыдущего узла /5|6|11\
+node_6 = node_7.right_child.insert_left(5).insert_right(11)
+# правое поддерево корня /|5|9\
+node_5 = node_root.right_child.insert_right(9)
+# левое поддерево предыдущего узла корня /4|9|\
+node_9 = node_5.right_child.insert_left(4)
+
+
+#########################################################################
+# Обход дерева
+#########################################################################
+
+# В случае линейных структур данных итерация по элементам происходила достаточно
+# интуитивно — в массивах мы делали это по индексам, в списках — по указателям.
+# В стеках и очередях, как правило, нет необходимости в итерации, потому что мы
+# всегда смотрим на крайние элементы структуры. В случае дерева нелинейная
+# структура требует развития особых подходов в обходе по нему.
+#
+# Различают два основных способа обхода:
+#
+#    1.    Поиск в глубину (depth-first search, DFS). Его основная суть заключается
+#               в том, что проходя по каждому узлу мы сначала идём в его потомка, а
+#               потом возвращаемся обратно — это обход с возвратом. Такой поиск
+#               бывает трёх видов:
+#             префиксный (pre-order);
+#             постфиксный (post-order);
+#             инфиксный (in-order).
+#    2.    Поиск в ширину (breadth-first search, BFS). Такой обход осуществляется
+#               в обходе уровня за уровнем.
+#
+# ---------------------------------------
+# Начнём с рассмотрения поиска в глубину.
+# ---------------------------------------
+# В обходе в глубину мы всегда используем рекурсивный подход: префиксный, постфиксный
+# или инфиксный, подходы отличаются лишь порядком выполнения процедуры обработки узла
+# и вызовов этой же функции на потомках.
+#
+# Рассмотрим префиксный подход. Сначала мы должны обработать значение самого узла
+# (поэтому он и префиксный), а затем рекурсивно проделать то же самое с левым потомком
+# и затем с правым. В качестве процедуры обработки узла возьмём самое простое —
+# печать его значения.
+# ( см. метод pre_order класса BinaryTree )
+
+# Давайте посмотрим в каком порядке будет производиться префиксный обход дерева
+# в глубину на примере созданного нами дерева.
+
+node_root.pre_order()
+
+# Сначала мы записали значение корневого узла (2), после чего — его левого потомка
+# (7). У него также есть левый потомок (2), который является листом, поэтому происходит
+# возврат на предыдущий уровень — печатается значение правого потомка (6). Дальше
+# просматриваются его потомки, и происходит возврат до того уровня, который не
+# просмотрен — правое поддерево корневого узла (/|2|5\).
+#
+# Постфиксный обход дерева отличается
+# порядком вызова для обоих потомков и процедуры обработки узла.
+
+# Задание 4.5.6
+# Напишите метод постфиксного обхода в глубину.
+# ( см. метод post_order класса BinaryTree )
+
+# # Инфиксный подход заключается в том, что порядок обработки узла и его потомков
+# # смешивается: сначала шагаем в левое поддерево, потом обрабатываем сам узел, затем
+# # правое поддерево. В итоге получается, что мы как будто «читаем» дерево слева направо.
+# #
+# # Метод инфиксного обхода в глубину:
+# # ( см. метод in_order класса BinaryTree )
+
+#########################################################################
Index: INTPY/B3_Conditions/tests.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># Задание 3.2.1\r\n# Дано n-значное целое число N. Определите, входят ли в него цифры 3 и 7.\r\nN = input(\"Введите целое число: \")\r\nch3 = '3' in str(N)\r\nch7 = '7' in str(N)\r\nprint(ch3 and ch7)\r\n# или вот так:\r\nprint('3' in str(N) and '7' in str(N))\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/INTPY/B3_Conditions/tests.py b/INTPY/B3_Conditions/tests.py
--- a/INTPY/B3_Conditions/tests.py	(revision aceb5b78e04eb6a1b997e1467f1364daa24c3211)
+++ b/INTPY/B3_Conditions/tests.py	(date 1662462058489)
@@ -1,9 +1,12 @@
 # Задание 3.2.1
 # Дано n-значное целое число N. Определите, входят ли в него цифры 3 и 7.
 N = input("Введите целое число: ")
-ch3 = '3' in str(N)
-ch7 = '7' in str(N)
-print(ch3 and ch7)
-# или вот так:
-print('3' in str(N) and '7' in str(N))
 
+if '3' and '7' in str(N):
+    print(f"Цифры 3 и 7 входят в число {N}")
+if '3' in str(N):
+    print(f"Цифра 3 входит в число {N}")
+if '7' in str(N):
+    print(f"Цифра 7 входит в число {N}")
+else:
+    print(f"Цифры 3 и 7 не входят в число {N}")
Index: INTPY/C5_Requests_JSON_Redis_etc/C5_3_Making_telegram_bot.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/INTPY/C5_Requests_JSON_Redis_etc/C5_3_Making_telegram_bot.py b/INTPY/C5_Requests_JSON_Redis_etc/C5_3_Making_telegram_bot.py
new file mode 100644
--- /dev/null	(date 1662543191114)
+++ b/INTPY/C5_Requests_JSON_Redis_etc/C5_3_Making_telegram_bot.py	(date 1662543191114)
@@ -0,0 +1,308 @@
+##############################################################################
+# C5.3. Создание Telegram-бота
+##############################################################################
+
+# Что такое боты Telegram?
+# ---------------------------------------------------------------------
+# Боты — это сторонние приложения, которые запускаются внутри Telegram.
+# ---------------------------------------------------------------------
+
+# Приложения могут быть написаны на любом языке программирования, универсальность
+# взаимодействия обеспечивается благодаря протоколу HTTP (по сути, то, что мы делали
+# с вами в прошлом юните через библиотеку Requests). Пользователи могут взаимодействовать
+# с ботами, отправляя им сообщения, команды и встроенные запросы.
+#
+# Приведём краткий список того, что умеют делать боты:
+#
+    # 1.    Получение индивидуальных уведомлений и новостей. Бот может работать как умная
+#                   газета, которая будет отправлять интересующий вас контент, как только
+#                   он будет опубликован.
+    # 2.    Интеграция с другими сервисам. Бот может дополнять чаты Telegram возможностями
+#                   из внешних сервисов, например: Gmail Bot, GIF bot, IMDB bot, Wiki bot,
+#                   Music bot, Youtube bot, GitHub bot.
+    # 3.    Создание собственных инструментов. Бот может предоставлять вам оповещения о
+#                   различных действиях, прогнозы погоды, переводы, форматирование или
+#                   другие услуги. Например: Markdown bot, Sticker bot, Vote bot, Like bot.
+
+#############################################################################
+# Как работают боты?
+#############################################################################
+
+# По сути, боты Telegram — это особые учётные записи, для которых не требуется
+# дополнительный номер телефона.
+#
+# Пользователи могут взаимодействовать с ботами двумя способами:
+    # 1. Отправлять сообщения и команды ботам, открывая с ними чат или добавляя их в группы.
+    #         Предлагаемые команды. Команды начинаются с символа «/».
+    # 2. Отправлять запросы прямо из поля ввода, вводя @username бота и запрос. Это позволяет
+    #         отправлять контент от встроенных ботов прямо в любой чат, группу или канал.
+    #         Пользователи могут ввести имя пользователя бота в любом чате, а затем ввести
+    #         запрос, не отправляя никаких сообщений.
+
+# Сообщения, команды и запросы, отправленные пользователями, передаются программному
+# обеспечению, работающему на вашем сервере. Сервер — это компьютер, поэтому сервером
+# может выступать и ваш домашний компьютер. Сервер Telegram отвечает за шифрование и
+# пересылку сообщений. Вы общаетесь с сервером Telegram через интерфейс по протоколу
+# HTTP, и этот интерфейс называется Bot API.
+#
+# В части Bot API есть набор определённых методов, позволяющих получить от Telegram
+# сообщение, которое пользователь прислал боту, и отправить ответ обратно. С этими
+# функциями мы познакомимся чуть позже. То есть API представляет собой промежуточное
+# звено между клиентом Telegram и вашим скриптом.
+
+#############################################################################
+# Как создать бота?
+#############################################################################
+
+# Для того чтобы создать бота, есть … бот. :) Вам необходимо написать @BotFather
+# и выполнить несколько простых шагов.
+#
+# Используйте команду /newbot, чтобы создать нового бота.
+#
+# Затем необходимо:
+#
+#    1.     Установить имя (name) вашего бота.
+#               Имя вашего бота отображается в контактной информации и в других местах.
+#    2.     Установить имя пользователя (username) вашего бота.
+#               Имя пользователя — это короткое имя, которое будет использоваться для
+#               идентификации вашего бота и обращения к нему. Имена пользователей
+#               состоят из 5–32 символов и нечувствительны к регистру, могут включать
+#               только латинские символы, числа и символы подчёркивания. Имя пользователя
+#               вашего бота должно заканчиваться на «bot», например, «tetris_bot» или «TetrisBot».
+#    3.     Получить токен (token).
+#               Токен представляет собой строку вида 110201543:AAHdqTcvCH1vGWJxfSeofSAs0K5PALDsaw.
+#               Он необходим для авторизации (подтверждения, что именно вы владелец этого бота,
+#               чтобы в программе было понятно, к какому именно боту привязываются все
+#               обработчики) вашей программы, в которой реализована логика бота. Токен —
+#               это пароль от вашего бота, поэтому храните свой токен в безопасности.
+#
+# С более подробной информацией о возможностях @BotFather можно ознакомиться в официальной документации.
+
+#############################################################################
+# Создание Python Telegram-бота
+#############################################################################
+
+# Для того чтобы создать бота, есть … бот. :) Вам необходимо написать @BotFather
+# и выполнить несколько простых шагов.
+#
+# Используйте команду /newbot, чтобы создать нового бота.
+#
+# Затем необходимо:
+#
+    # 1. Установить имя (name) вашего бота.
+    #         Имя вашего бота отображается в контактной информации и в других местах.
+    # 2. Установить имя пользователя (username) вашего бота.
+    #         Имя пользователя — это короткое имя, которое будет использоваться для
+    #         идентификации вашего бота и обращения к нему. Имена пользователей состоят
+    #         из 5–32 символов и нечувствительны к регистру, могут включать только
+    #         латинские символы, числа и символы подчёркивания. Имя пользователя вашего
+    #         бота должно заканчиваться на «bot», например, «tetris_bot» или «TetrisBot».
+    # 3. Получить токен (token).
+    #         Токен представляет собой строку вида 110201543:AAHdqTcvCH1vGWJxfSeofSAs0K5PALDsaw.
+    #         Он необходим для авторизации (подтверждения, что именно вы владелец этого бота,
+    #         чтобы в программе было понятно, к какому именно боту привязываются все обработчики)
+    #         вашей программы, в которой реализована логика бота. Токен — это пароль от вашего бота,
+    #         поэтому храните свой токен в безопасности.
+#
+# С более подробной информацией о возможностях @BotFather можно ознакомиться в официальной документации.
+# https://core.telegram.org/bots#6-botfather
+
+#############################################################################
+# Создание Python Telegram-бота
+#############################################################################
+
+# После того как мы получили токен для доступа к боту, можно приступать к созданию
+# скрипта, который будет реализовывать всю логику Телеграм-бота. Но перед этим необходимо
+# изучить некоторые типы данных, которыми API Bot позволяет оперировать.
+# https://core.telegram.org/bots/api
+
+# Первое, с чем нам необходимо познакомиться, это доступная информация о чатах. API Bot
+# даёт доступ к множеству объектов, с которыми он работает.
+# https://core.telegram.org/bots/api#chat
+
+# Мы разберём два основных:
+#
+#         чат,
+#         сообщение.
+#
+# Каждый из них обладает определённым набором информации.
+#
+# Например, часть полей, доступных для объекта «Чат»:
+
+# ---------------------------------------------------------------------------------
+# Поле 	                Описание
+# ---------------------------------------------------------------------------------
+# id 	        Уникальный идентификатор данного чата.
+# ---------------------------------------------------------------------------------
+# type 	        Тип чата может быть «private», «group», «supergroup» или «channel».
+# ---------------------------------------------------------------------------------
+# username 	    Необязательное поле. Имя пользователя для приватных чатов,
+#               супергрупп и каналов, если доступно.
+# ---------------------------------------------------------------------------------
+
+# Все сообщения в Telegram приходят в какой-либо чат. Чтобы его идентифицировать,
+# например, для того, чтобы отправить ответное сообщение, необходимо знать его id.
+# Также можно определить тип чата и реализовать различную логику для моментов, когда
+# бот будет использоваться в личных сообщениях или групповых чатах. Username может
+# использоваться для приветствия и обращения к пользователю.
+#
+# Поля, доступные для объекта «Сообщение»:
+
+# ---------------------------------------------------------------------------------
+#   Поле 	                    Описание
+# ---------------------------------------------------------------------------------
+# message_id 	        Уникальный идентификатор сообщения в данном чате.
+# ---------------------------------------------------------------------------------
+# from 	                Необязательное поле. Отправитель сообщения. Если сообщение
+#                       отправлено каналом, то поле будет пустым.
+# ---------------------------------------------------------------------------------
+# date 	                Дата отправки сообщения в Unix-формате.
+# ---------------------------------------------------------------------------------
+# chat 	                Чат, куда было отправлено сообщение.
+# ---------------------------------------------------------------------------------
+# text 	                Необязательное поле. Текст сообщения.
+# ---------------------------------------------------------------------------------
+
+# Зная id сообщения, можно отправить ответ именно на это сообщение. Отправителя можно
+# использовать для персонализированного ответа. Чат нужен, чтобы понять, куда нужно
+# отправить ответ. Поле с текстом позволяет анализировать и обрабатывать сообщения
+# и команды, отправленные пользователем.
+#
+# Сообщения могут содержать контент следующих типов:
+#
+#         audio — аудиозапись;
+#         photo — фотография, картинка;
+#         voice — голосовое сообщение;
+#         video — видеозапись;
+#         document — документ;
+#         text — текстовое сообщение;
+#         location — геолокация;
+#         contact — контакт;
+#         sticker — стикер.
+#
+# Можно реализовать различную обработку сообщений с соответствующим контентом.
+#
+# Чтобы взаимодействовать с этими объектами, в Python есть специальная библиотека
+# pyTelegramBotAPI. Установить её вы можете с помощью команды:
+
+# pip3 install pyTelegramBotAPI     # что такое pip3 ?
+
+# После установки необходимо создать новый файл, импортировать туда модуль telebot
+# и создать объект bot, используя токен, полученный при регистрации.
+
+import telebot
+
+# TOKEN = "Токен, полученный при регистрации"
+TOKEN = "5386412319:AAGoNUgj71uclssOgkm6dsBF3BSOlTJsus8" # @integromatYS_bot - мой бот
+
+bot = telebot.TeleBot(TOKEN)
+
+# Чтобы запустить бота, нужно воспользоваться методом polling.
+
+bot.polling(none_stop=True)
+
+# Параметр none_stop=True говорит, что бот должен стараться не прекращать работу
+# при возникновении каких-либо ошибок.
+#
+
+#############################################################################
+# Обработчики сообщений
+#############################################################################
+# -------------------------------------------------------------
+# Обработчик сообщений — это функция, которая будет выполняться
+# при получении определённого сообщения.
+# -------------------------------------------------------------
+# Для того чтобы из обычной функции сделать обработчик сообщений для бота, надо
+# воспользоваться декоратором @bot.message_handler. Обработчики сообщений состоят
+# из одного или нескольких фильтров.
+#
+# Обработчик сообщений объявляется следующим образом (при условии, что bot —
+# это экземпляр класса TeleBot):
+
+import telebot
+
+TOKEN = "5386412319:AAGoNUgj71uclssOgkm6dsBF3BSOlTJsus8" # @integromatYS_bot - мой бот
+
+bot = telebot.TeleBot(TOKEN)
+
+@bot.message_handler(filters)
+def function_name(message):
+    bot.reply_to(message, "This is a message handler")
+
+# Давайте разберёмся, что мы с вами написали.
+#
+# Начнём с filters в аргументах к обработчику.
+#
+# filters — фильтры, определяющие, следует ли вызывать декорированную функцию
+# для соответствующего сообщения или нет. У одного обработчика может быть несколько фильтров.
+#
+# Мы с вами разберём два основных фильтра:
+#
+#         тип контента;
+#         команды.
+
+# ===========================================================================================
+# Название фильтра  Аргумент                Условие выполнения функции
+# -------------------------------------------------------------------------------------------
+# content_types     Список строк,           Если тип контента, содержащегося в сообщении,
+#                   по умолчанию ['text']   совпадает с типом указанным в качестве аргумента.
+#                                           То есть обработчик по умолчанию реагирует на все
+#                                           текстовые сообщения.
+# -------------------------------------------------------------------------------------------
+# commands 	        Список строк 	        Если сообщение начинается с команды,
+#                                           указанной в списке.
+# ==========================================================================================
+#
+# Для обработчиков сообщений разрешено любое имя функции, поэтому function_name может принимать
+# любое значение. Функция должна принимать не более одного аргумента, он будет сообщением,
+# которое функция должна обработать. Аргумент message имеет все поля перечисленные здесь.
+# https://core.telegram.org/bots/api#message
+
+import telebot
+
+bot = telebot.TeleBot("TOKEN")
+
+# Обрабатываются все сообщения, содержащие команды '/start' or '/help'.
+# @bot.message_handler(commands=['start', 'help'])
+# def handle_start_help(message):
+#     pass
+
+@bot.message_handler(commands=['start', 'help'])
+def send_welcome(message):
+    bot.send_message(message.chat.id, f"Welcome, {message.chat.username}")
+
+# Обрабатывается все документы и аудиозаписи
+@bot.message_handler(content_types=['document', 'audio'])
+def handle_docs_audio(message):
+    pass
+
+@bot.message_handler(content_types=['photo', ])
+def say_lmao(message: telebot.types.Message):
+    bot.reply_to(message, 'Nice meme XDD')
+
+
+# Задание 5.3.1
+# Допишите обработчик так, чтобы он из сообщения брал username и выдавал
+# приветственное сообщение с привязкой к пользователю.
+# Ответ: см. ниже или выше
+# @bot.message_handler(commands=['start', 'help'])
+# def send_welcome(message):
+#     bot.send_message(message.chat.id, f"Welcome, {message.chat.username}")
+
+# Задание 5.3.2
+# Напишите обработчик, который на сообщения с фотографией будет отвечать сообщением
+# «Nice meme XDD». Бот должен отвечать не отдельным сообщением, а с привязкой к картинке.
+# Ответ:
+
+# @bot.message_handler(content_types=['photo', ])
+# def say_lmao(message: telebot.types.Message):
+#     bot.reply_to(message, 'Nice meme XDD')
+
+
+
+
+#############################################################################
+
+
+
+
Index: INTPY/C3_modules_import_files_data/function.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>def hello():\r\n    print(\"Hello, World!\")
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/INTPY/C3_modules_import_files_data/function.py b/INTPY/C3_modules_import_files_data/function.py
--- a/INTPY/C3_modules_import_files_data/function.py	(revision aceb5b78e04eb6a1b997e1467f1364daa24c3211)
+++ b/INTPY/C3_modules_import_files_data/function.py	(date 1662460535422)
@@ -1,2 +1,5 @@
 def hello():
-    print("Hello, World!")
\ No newline at end of file
+    print("Hello, World!")
+
+if __name__ == '__main__':
+    hello()
Index: .idea/misc.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"ProjectRootManager\" version=\"2\" project-jdk-name=\"Python 3.10 (PycharmProjects)\" project-jdk-type=\"Python SDK\" />\r\n  <component name=\"PyCharmProfessionalAdvertiser\">\r\n    <option name=\"shown\" value=\"true\" />\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/misc.xml b/.idea/misc.xml
--- a/.idea/misc.xml	(revision aceb5b78e04eb6a1b997e1467f1364daa24c3211)
+++ b/.idea/misc.xml	(date 1662461033699)
@@ -1,6 +1,6 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <project version="4">
-  <component name="ProjectRootManager" version="2" project-jdk-name="Python 3.10 (PycharmProjects)" project-jdk-type="Python SDK" />
+  <component name="ProjectRootManager" version="2" project-jdk-name="Python 3.10 (PycharmProjects) (2)" project-jdk-type="Python SDK" />
   <component name="PyCharmProfessionalAdvertiser">
     <option name="shown" value="true" />
   </component>
Index: INTPY/C2_sea_battle/main.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from random import randint\r\n\r\n\r\nclass Dot:  # Объекты класса Точка будут возвращать кортежи с координатами вида Dot(x, y)\r\n    def __init__(self, x, y):\r\n        self.x = x\r\n        self.y = y\r\n\r\n    def __eq__(self, other):  # проверка точек на равенство\r\n        return self.x == other.x and self.y == other.y\r\n\r\n    def __repr__(self):  # возвращает кортеж из координат\r\n        return f\"Dot({self.x}, {self.y})\"\r\n\r\n\r\n# классы исключений:\r\nclass BoardException(Exception):\r\n    pass\r\n\r\n\r\nclass BoardOutException(BoardException):\r\n    def __str__(self):\r\n        return \"Вы стреляете за пределы поля!\"\r\n\r\n\r\nclass BoardUsedException(BoardException):\r\n    def __str__(self):\r\n        return \"Уже стреляли по этой клетке!\"\r\n\r\n\r\nclass BoardWrongShipException(BoardException):\r\n    pass\r\n\r\n\r\nclass Ship:  # класс Корабль:\r\n    def __init__(self, bow, l, o):\r\n        self.bow = bow  # координаты носа корабля: кортеж типа Dot(x,y)\r\n        self.l = l  # длина\r\n        self.o = o  # направление, boolean: 0 - горизонтально, 1 - вертик (или наоборот, неважно)\r\n        self.lives = l  # количество жизней, совпадает с длиной\r\n\r\n    @property\r\n    def dots(self):\r\n        ship_dots = []  # список точек-координат корабля\r\n        for i in range(self.l):  # перебор значений в зависим. от длины корабля\r\n            cur_x = self.bow.x  # устанавливается точка x\r\n            cur_y = self.bow.y  # y\r\n            if self.o == 0:  # направление, по которому будут приращиваться значения:\r\n                cur_x += i  # либо по горизонтали\r\n            elif self.o == 1:\r\n                cur_y += i  # либо по вертикали\r\n            ship_dots.append(Dot(cur_x, cur_y))  # добавляем пару точек в список\r\n\r\n        return ship_dots  # передаем список кому нужно\r\n\r\n    def shooten(self, shot):  # проверка, попал ли выстрел по координатам корабля\r\n        return shot in self.dots  # ответ: True - False\r\n\r\n\r\nclass Board:  # класс для игрового поля:\r\n    def __init__(self, hid=False, size=6):\r\n        self.hid = hid  # видимость/скрытость поля\r\n        self.size = size  # размер\r\n\r\n        self.count = 0  # счетчик пораженных кораблей\r\n        # матрица игр.поля size*size (6*6), заполненная нулями:\r\n        self.field = [[\"0\"] * size for _ in range(size)]\r\n\r\n        self.busy = []  # занятые точки (либо корабль, либо куда стреляли)\r\n        self.ships = []  # список кораблей на поле\r\n\r\n    def __str__(self):  # возвращает многострочную переменную\r\n        res = ''  # с \"картинкой\" ситуации на поле\r\n        res += '  | 1 | 2 | 3 | 4 | 5 | 6 |'  # добавляем первую строку\r\n        for i, row in enumerate(self.field):  # добавляем следующие строки\r\n            # со скорректир.номерами, разделителями и инфо из строк матрицы field:\r\n            res += f\"\\n{i + 1} | \" + \" | \".join(row) + \" | \"\r\n\r\n        if self.hid:  # если параметр hid=True, то символы корабля будут заменены\r\n            res = res.replace(\"■\", \"O\")  # на нолики (на вражеской доске)\r\n\r\n        return res  # готовая \"картинка\" с ситуацией\r\n\r\n    def out(self, d):  # True - если точка вне пределов игр.поля\r\n        return not ((0 <= d.x < self.size) and (0 <= d.y < self.size))\r\n\r\n    def contour(self, ship, verb=False):  # определить точки вокруг корабля\r\n        near = [  # список точек со сдвигом, окружающих точку (0,0)\r\n            (-1, -1), (-1, 0), (-1, 1),\r\n            (0, -1), (0, 0), (0, 1),\r\n            (1, -1), (1, 0), (1, 1)\r\n        ]\r\n        for d in ship.dots:  # подсчет точек, куда нельзя будет ставить др.корабль\r\n            for dx, dy in near:\r\n                cur = Dot(d.x + dx, d.y + dy)\r\n                # если точка не выходит за границы поля и не занята:\r\n                if not (self.out(cur)) and cur not in self.busy:\r\n                    if verb:\r\n                        self.field[cur.x][cur.y] = \".\"  # помечаем ее на поле\r\n                    self.busy.append(cur)  # и добавляем в список занятых\r\n\r\n    def add_ship(self, ship):  # добавление корабля на поле\r\n        for d in ship.dots:\r\n            # если точка за полем или занята:\r\n            if self.out(d) or d in self.busy:\r\n                raise BoardWrongShipException  # выбрасывается исключение\r\n        for d in ship.dots:  # если все ОК:\r\n            self.field[d.x][d.y] = \"■\"  # точка помечается\r\n            self.busy.append(d)  # и заносится в список занятых\r\n\r\n        self.ships.append(ship)\r\n        self.contour(ship)\r\n\r\n    def shot(self, d):  # выстрел\r\n        if self.out(d):  # не выходит ли точка за границы поля?\r\n            raise BoardOutException\r\n        if d in self.busy:  # не использована ли уже эта точка?\r\n            raise BoardUsedException\r\n        self.busy.append(d)  # если ОК, добавить точку\r\n        for ship in self.ships:  # проходимся по списку кораблей\r\n            if ship.shooten(d):  # вычисляем точку попадания и последствия для корабля\r\n                ship.lives -= 1  # уменьшаем количество \"жизней\"\r\n                self.field[d.x][d.y] = \"X\"  # помечаем подбитую точку\r\n                if ship.lives == 0:  # если количество жизней корабля 0\r\n                    self.count += 1  # увеличиваем счетчик уничтоженных кораблей\r\n                    self.contour(ship, verb=True)\r\n                    print(\"Корабль уничтожен!\")\r\n                    return False\r\n                else:  # если корабль ранен\r\n                    print(\"Корабль подбит!\")\r\n                    return True\r\n        self.field[d.x][d.y] = \".\"\r\n        print(\"Мимо!\")\r\n        return False\r\n\r\n    def begin(self):  # обнуляем список busy. До начала игры он использовался\r\n        self.busy = []  # для расстановки кораблей, а сейчас понадобится для\r\n        # записи точек, куда производились выстрелы. Можно была завести еще один список,\r\n        # но метод contour получился универсальным: и для расстановки, и для самой игры\r\n\r\n    def defeat(self):\r\n        return self.count == len(self.ships)\r\n\r\n\r\nclass Player:  # класс Игрок:\r\n    def __init__(self, board, enemy):  # аргументы - две доски\r\n        self.board = board\r\n        self.enemy = enemy\r\n\r\n    def ask(self):\r\n        raise NotImplementedError\r\n\r\n    def move(self):\r\n        while True:\r\n            try:\r\n                target = self.ask()\r\n                repeat = self.enemy.shot(target)\r\n                return repeat\r\n            except BoardException as e:\r\n                print(e)\r\n\r\n\r\nclass AI(Player):  # класс игрока ИИ:\r\n    def ask(self):  # ход ПК\r\n        d = Dot(randint(0, 5), randint(0, 5))  # получает два случайных числа между 0 и 5\r\n        print(f\"Ход компьютера: {d.x + 1} {d.y + 1}\")  # показывает ход с коррекцией цифр\r\n        return d  # передает программе свой ход\r\n\r\n\r\nclass User(Player):  # класс игрока-человека:\r\n    def ask(self):  # ход человека\r\n        while True:\r\n            cords = input(\"Ваш ход: \").split()\r\n\r\n            if len(cords) != 2:  # проверка, что введено 2 значения координат\r\n                print(\"Введите 2 координаты...\")\r\n                continue\r\n\r\n            x, y = cords  # передача этих значений в переменные x и y\r\n\r\n            if not (x.isdigit()) or not (y.isdigit()):  # проверка, что\r\n                print(\"Введите числа...\")  # x и y - числа\r\n                continue\r\n\r\n            x, y = int(x), int(y)  # приведение к типу integer\r\n\r\n            return Dot(x - 1, y - 1)  # кортеж со скорректированными координатами\r\n\r\n\r\nclass Game:  # класс Игра:\r\n    def __init__(self, size=6):  # конструктор игры\r\n        self.size = size  # задаем размер поля\r\n        pl = self.random_board()  # создаем доску для игрока\r\n        pc = self.random_board()  # создаем доску для компьютера\r\n        pc.hid = True  # скрываем корабли с доски для компьютера\r\n\r\n        self.ai = AI(pc, pl)  # объект класса AI(свое поле, поле противника)\r\n        self.us = User(pl, pc)  # объект класса User(свое поле, поле противника)\r\n\r\n    def try_board(self):  # генерирование игрового поля\r\n        lens = [3, 2, 2, 1, 1, 1, 1]  # список длин кораблей\r\n        board = Board(size=self.size)  # создание игрового поля\r\n        attempts = 0  # количество попыток\r\n        for l in lens:  # создание кораблей и расстановка их по полю\r\n            while True:\r\n                attempts += 1\r\n                if attempts > 2000:  # максимальное количество попыток\r\n                    return None  # если не получится - сброс и сначала\r\n                # создание корабля cо случайными координатами и ориентацией:\r\n                ship = Ship(Dot(randint(0, self.size), randint(0, self.size)), l, randint(0, 1))\r\n                try:\r\n                    board.add_ship(ship)  # попытка добавить корабль на поле\r\n                    break  # если все ОК, то бесконечый цикл закончится\r\n                except BoardWrongShipException:  # если не получилось\r\n                    pass\r\n\r\n        board.begin()  # активизация созданного поля с кораблями\r\n        return board  # передача объекта в игру\r\n\r\n    def random_board(self):  # создание случайного поля с кораблями\r\n        board = None  # иозначально поле отсутствует\r\n        while board is None:  # бесконечные попытки создания поля\r\n            board = self.try_board()\r\n            return board  # пока не завершится успехом\r\n\r\n    def greeting(self):  # приветствие перед началом игры\r\n        print(\"--------------------------\")\r\n        print(\"    Классическая игра     \")\r\n        print(\"       МОРСКОЙ БОЙ        \")\r\n        print(\"--------------------------\")\r\n        print(\" Формат ввода: x y Enter  \")\r\n        print(\"  где  x - номер строки   \")\r\n        print(\"       y - номер столбца  \")\r\n\r\n    def loop(self):  # игровой цикл\r\n        num = 0\r\n        while True:\r\n            print(\"-\" * 20)\r\n            print(\"Доска игрока: \")\r\n            print(self.us.board)\r\n            print(\"Доска компьютера: \")\r\n            print(self.ai.board)\r\n            print(\"-\" * 20)\r\n\r\n            if num % 2 == 0:\r\n                print(\"-\" * 20)\r\n                print(\"Ваш ход!\")\r\n                repeat = self.us.move()\r\n            else:\r\n                print(\"-\" * 20)\r\n                print(\"Ходит компьютер!\")\r\n                repeat = self.ai.move()\r\n\r\n            if repeat:  # при попадании можно повторить ход, для чего\r\n                num -= 1  # num просто уменьшается на единицу\r\n            # проверка, что количество пораженных кораблей равно количеству кораблей на доске:\r\n            # if self.ai.count == len(self.ai.board.ships):\r\n            if self.ai.board.defeat(): # другой вариант\r\n                print(\"-\" * 20)\r\n                print(\"ВЫ ВЫИГРАЛИ!\")\r\n                break\r\n            # либо проще - количество пораженных кораблей равно 7:\r\n            # if self.us.count == 7:\r\n            if self.us.board.defeat():\r\n                print(\"-\" * 20)\r\n                print(\"ВЫИГРАЛ КОМПЬЮТЕР!\")\r\n                break\r\n\r\n            num += 1\r\n    def start(self):\r\n        self.greeting()\r\n        self.loop()\r\n\r\n\r\nif __name__ == '__main__':\r\n    # ship1 = Ship(Dot(3, 4), 3, 0)\r\n    # print(ship1.dots)\r\n    # shoot = ship1.shooten(Dot(5, 4))\r\n    # print(shoot)\r\n    # b = Board()\r\n    # b.add_ship(Ship(Dot(1, 2), 4, 0))\r\n    # b.add_ship(Ship(Dot(0, 0), 2, 0))\r\n    # print(b)\r\n    # print(b.busy)\r\n    g = Game()\r\n    # g.size = 6\r\n    # # print(g.try_board())\r\n    # print(g.random_board())\r\n    g.start()\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/INTPY/C2_sea_battle/main.py b/INTPY/C2_sea_battle/main.py
--- a/INTPY/C2_sea_battle/main.py	(revision 017ba5306cdb8259da9dfbc4df472bd5b9c370c5)
+++ b/INTPY/C2_sea_battle/main.py	(date 1662462805878)
@@ -4,7 +4,7 @@
 class Dot:  # Объекты класса Точка будут возвращать кортежи с координатами вида Dot(x, y)
     def __init__(self, x, y):
         self.x = x
-        self.y = y
+        self.y = y2
 
     def __eq__(self, other):  # проверка точек на равенство
         return self.x == other.x and self.y == other.y
Index: .idea/encodings.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/encodings.xml b/.idea/encodings.xml
new file mode 100644
--- /dev/null	(date 1661958423437)
+++ b/.idea/encodings.xml	(date 1661958423437)
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="Encoding">
+    <file url="file://$PROJECT_DIR$/INTPY/C3_modules_import_files_data/test2.txt" charset="UTF-8" />
+  </component>
+</project>
\ No newline at end of file
Index: .idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"ChangeListManager\">\r\n    <list default=\"true\" id=\"69b1561c-f546-4fc1-917f-b89eceb341cf\" name=\"Changes\" comment=\"Мои учебно-тренировочные файлы по курсу Интенсив Python\">\r\n      <change afterPath=\"$PROJECT_DIR$/INTPY/C3_modules_import_files_data/C3_2_exceptions.py\" afterDir=\"false\" />\r\n      <change afterPath=\"$PROJECT_DIR$/INTPY/C3_modules_import_files_data/C3_3_import.py\" afterDir=\"false\" />\r\n      <change afterPath=\"$PROJECT_DIR$/INTPY/C3_modules_import_files_data/C3_4_working_with_files.py\" afterDir=\"false\" />\r\n      <change afterPath=\"$PROJECT_DIR$/INTPY/C3_modules_import_files_data/file_open_write.py\" afterDir=\"false\" />\r\n      <change afterPath=\"$PROJECT_DIR$/INTPY/C3_modules_import_files_data/function.py\" afterDir=\"false\" />\r\n      <change afterPath=\"$PROJECT_DIR$/INTPY/C3_modules_import_files_data/main.py\" afterDir=\"false\" />\r\n      <change afterPath=\"$PROJECT_DIR$/INTPY/C3_modules_import_files_data/module_pattern.py\" afterDir=\"false\" />\r\n      <change afterPath=\"$PROJECT_DIR$/INTPY/C3_modules_import_files_data/test325.py\" afterDir=\"false\" />\r\n      <change afterPath=\"$PROJECT_DIR$/INTPY/C3_modules_import_files_data/test336.py\" afterDir=\"false\" />\r\n      <change afterPath=\"$PROJECT_DIR$/INTPY/C3_modules_import_files_data/test343.py\" afterDir=\"false\" />\r\n      <change afterPath=\"$PROJECT_DIR$/INTPY/C3_modules_import_files_data/time.py\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/.idea/workspace.xml\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/.idea/workspace.xml\" afterDir=\"false\" />\r\n    </list>\r\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\r\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\r\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\r\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\r\n  </component>\r\n  <component name=\"FileTemplateManagerImpl\">\r\n    <option name=\"RECENT_TEMPLATES\">\r\n      <list>\r\n        <option value=\"HTML File\" />\r\n        <option value=\"Python Script\" />\r\n      </list>\r\n    </option>\r\n  </component>\r\n  <component name=\"Git.Settings\">\r\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$\" />\r\n  </component>\r\n  <component name=\"MarkdownSettingsMigration\">\r\n    <option name=\"stateVersion\" value=\"1\" />\r\n  </component>\r\n  <component name=\"ProjectId\" id=\"2BGNkkuXq9t75yGKfYL89BaHfFh\" />\r\n  <component name=\"ProjectLevelVcsManager\" settingsEditedManually=\"true\" />\r\n  <component name=\"ProjectViewState\">\r\n    <option name=\"hideEmptyMiddlePackages\" value=\"true\" />\r\n    <option name=\"showLibraryContents\" value=\"true\" />\r\n  </component>\r\n  <component name=\"PropertiesComponent\"><![CDATA[{\r\n  \"keyToString\": {\r\n    \"DefaultHtmlFileTemplate\": \"HTML File\",\r\n    \"RunOnceActivity.OpenProjectViewOnStart\": \"true\",\r\n    \"RunOnceActivity.ShowReadmeOnStart\": \"true\",\r\n    \"last_opened_file_path\": \"D:/Git/PycharmProjects/INTPY/C2_sea_battle\",\r\n    \"settings.editor.selected.configurable\": \"editing.templates\"\r\n  },\r\n  \"keyToStringList\": {\r\n    \"GitStage.ChangesTree.GroupingKeys\": [\r\n      \"directory\",\r\n      \"module\",\r\n      \"repository\"\r\n    ]\r\n  }\r\n}]]></component>\r\n  <component name=\"RecentsManager\">\r\n    <key name=\"CopyFile.RECENT_KEYS\">\r\n      <recent name=\"D:\\Git\\PycharmProjects\\INTPY\\Git.GitHub\" />\r\n      <recent name=\"D:\\Git\\PycharmProjects\\INTPY\\B5_exercises\" />\r\n      <recent name=\"D:\\Git\\PycharmProjects\\INTPY\\B4_Functions\" />\r\n      <recent name=\"D:\\Git\\PycharmProjects\\INTPY\\C1_Intro_to_OOP\" />\r\n      <recent name=\"D:\\Git\\PycharmProjects\\INTPY\" />\r\n    </key>\r\n    <key name=\"MoveFile.RECENT_KEYS\">\r\n      <recent name=\"D:\\Git\\PycharmProjects\\INTPY\\C2_OOP_continue\" />\r\n      <recent name=\"D:\\Git\\PycharmProjects\\INTPY\\B5_crosses_n_zeros\" />\r\n      <recent name=\"D:\\Git\\PycharmProjects\\INTPY\\B2_Data_types\" />\r\n      <recent name=\"D:\\Git\\PycharmProjects\\INTPY\\C1_Intro_to_OOP\" />\r\n    </key>\r\n  </component>\r\n  <component name=\"RunManager\" selected=\"Python.test336\">\r\n    <configuration name=\"C3_4_working_with_files\" type=\"PythonConfigurationType\" factoryName=\"Python\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <module name=\"PycharmProjects\" />\r\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\r\n      <option name=\"PARENT_ENVS\" value=\"true\" />\r\n      <envs>\r\n        <env name=\"PYTHONUNBUFFERED\" value=\"1\" />\r\n      </envs>\r\n      <option name=\"SDK_HOME\" value=\"\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$/INTPY/C3_modules_import_files_data\" />\r\n      <option name=\"IS_MODULE_SDK\" value=\"true\" />\r\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\r\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\r\n      <option name=\"SCRIPT_NAME\" value=\"$PROJECT_DIR$/INTPY/C3_modules_import_files_data/C3_4_working_with_files.py\" />\r\n      <option name=\"PARAMETERS\" value=\"\" />\r\n      <option name=\"SHOW_COMMAND_LINE\" value=\"false\" />\r\n      <option name=\"EMULATE_TERMINAL\" value=\"false\" />\r\n      <option name=\"MODULE_MODE\" value=\"false\" />\r\n      <option name=\"REDIRECT_INPUT\" value=\"false\" />\r\n      <option name=\"INPUT_FILE\" value=\"\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <configuration name=\"file_open_write\" type=\"PythonConfigurationType\" factoryName=\"Python\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <module name=\"PycharmProjects\" />\r\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\r\n      <option name=\"PARENT_ENVS\" value=\"true\" />\r\n      <envs>\r\n        <env name=\"PYTHONUNBUFFERED\" value=\"1\" />\r\n      </envs>\r\n      <option name=\"SDK_HOME\" value=\"\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$/INTPY/C3_modules_import_files_data\" />\r\n      <option name=\"IS_MODULE_SDK\" value=\"true\" />\r\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\r\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\r\n      <option name=\"SCRIPT_NAME\" value=\"$PROJECT_DIR$/INTPY/C3_modules_import_files_data/file_open_write.py\" />\r\n      <option name=\"PARAMETERS\" value=\"\" />\r\n      <option name=\"SHOW_COMMAND_LINE\" value=\"false\" />\r\n      <option name=\"EMULATE_TERMINAL\" value=\"false\" />\r\n      <option name=\"MODULE_MODE\" value=\"false\" />\r\n      <option name=\"REDIRECT_INPUT\" value=\"false\" />\r\n      <option name=\"INPUT_FILE\" value=\"\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <configuration name=\"test336\" type=\"PythonConfigurationType\" factoryName=\"Python\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <module name=\"PycharmProjects\" />\r\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\r\n      <option name=\"PARENT_ENVS\" value=\"true\" />\r\n      <envs>\r\n        <env name=\"PYTHONUNBUFFERED\" value=\"1\" />\r\n      </envs>\r\n      <option name=\"SDK_HOME\" value=\"\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$/INTPY/C3_modules_import_files_data\" />\r\n      <option name=\"IS_MODULE_SDK\" value=\"true\" />\r\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\r\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\r\n      <option name=\"SCRIPT_NAME\" value=\"$PROJECT_DIR$/INTPY/C3_modules_import_files_data/test336.py\" />\r\n      <option name=\"PARAMETERS\" value=\"\" />\r\n      <option name=\"SHOW_COMMAND_LINE\" value=\"false\" />\r\n      <option name=\"EMULATE_TERMINAL\" value=\"false\" />\r\n      <option name=\"MODULE_MODE\" value=\"false\" />\r\n      <option name=\"REDIRECT_INPUT\" value=\"false\" />\r\n      <option name=\"INPUT_FILE\" value=\"\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <configuration name=\"test343\" type=\"PythonConfigurationType\" factoryName=\"Python\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <module name=\"PycharmProjects\" />\r\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\r\n      <option name=\"PARENT_ENVS\" value=\"true\" />\r\n      <envs>\r\n        <env name=\"PYTHONUNBUFFERED\" value=\"1\" />\r\n      </envs>\r\n      <option name=\"SDK_HOME\" value=\"\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$/INTPY/C3_modules_import_files_data\" />\r\n      <option name=\"IS_MODULE_SDK\" value=\"true\" />\r\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\r\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\r\n      <option name=\"SCRIPT_NAME\" value=\"$PROJECT_DIR$/INTPY/C3_modules_import_files_data/test343.py\" />\r\n      <option name=\"PARAMETERS\" value=\"\" />\r\n      <option name=\"SHOW_COMMAND_LINE\" value=\"false\" />\r\n      <option name=\"EMULATE_TERMINAL\" value=\"false\" />\r\n      <option name=\"MODULE_MODE\" value=\"false\" />\r\n      <option name=\"REDIRECT_INPUT\" value=\"false\" />\r\n      <option name=\"INPUT_FILE\" value=\"\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <configuration name=\"time\" type=\"PythonConfigurationType\" factoryName=\"Python\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <module name=\"PycharmProjects\" />\r\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\r\n      <option name=\"PARENT_ENVS\" value=\"true\" />\r\n      <envs>\r\n        <env name=\"PYTHONUNBUFFERED\" value=\"1\" />\r\n      </envs>\r\n      <option name=\"SDK_HOME\" value=\"\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$/INTPY/C3_modules_import_files_data\" />\r\n      <option name=\"IS_MODULE_SDK\" value=\"true\" />\r\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\r\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\r\n      <option name=\"SCRIPT_NAME\" value=\"$PROJECT_DIR$/INTPY/C3_modules_import_files_data/time.py\" />\r\n      <option name=\"PARAMETERS\" value=\"\" />\r\n      <option name=\"SHOW_COMMAND_LINE\" value=\"false\" />\r\n      <option name=\"EMULATE_TERMINAL\" value=\"false\" />\r\n      <option name=\"MODULE_MODE\" value=\"false\" />\r\n      <option name=\"REDIRECT_INPUT\" value=\"false\" />\r\n      <option name=\"INPUT_FILE\" value=\"\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <recent_temporary>\r\n      <list>\r\n        <item itemvalue=\"Python.test336\" />\r\n        <item itemvalue=\"Python.C3_4_working_with_files\" />\r\n        <item itemvalue=\"Python.file_open_write\" />\r\n        <item itemvalue=\"Python.test343\" />\r\n        <item itemvalue=\"Python.time\" />\r\n      </list>\r\n    </recent_temporary>\r\n  </component>\r\n  <component name=\"SpellCheckerSettings\" RuntimeDictionaries=\"0\" Folders=\"0\" CustomDictionaries=\"0\" DefaultDictionary=\"application-level\" UseSingleDictionary=\"true\" transferred=\"true\" />\r\n  <component name=\"TaskManager\">\r\n    <task active=\"true\" id=\"Default\" summary=\"Default task\">\r\n      <changelist id=\"69b1561c-f546-4fc1-917f-b89eceb341cf\" name=\"Changes\" comment=\"\" />\r\n      <created>1656528606091</created>\r\n      <option name=\"number\" value=\"Default\" />\r\n      <option name=\"presentableId\" value=\"Default\" />\r\n      <updated>1656528606091</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00001\" summary=\"Мои учебно-тренировочные файлы по курсу Интенсив Python\">\r\n      <created>1661855186546</created>\r\n      <option name=\"number\" value=\"00001\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00001\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1661855186546</updated>\r\n    </task>\r\n    <option name=\"localTasksCounter\" value=\"2\" />\r\n    <servers />\r\n  </component>\r\n  <component name=\"Vcs.Log.Tabs.Properties\">\r\n    <option name=\"TAB_STATES\">\r\n      <map>\r\n        <entry key=\"MAIN\">\r\n          <value>\r\n            <State>\r\n              <option name=\"CUSTOM_BOOLEAN_PROPERTIES\">\r\n                <map>\r\n                  <entry key=\"Show.Git.Branches\" value=\"false\" />\r\n                </map>\r\n              </option>\r\n            </State>\r\n          </value>\r\n        </entry>\r\n      </map>\r\n    </option>\r\n  </component>\r\n  <component name=\"VcsManagerConfiguration\">\r\n    <ignored-roots>\r\n      <path value=\"$PROJECT_DIR$\" />\r\n    </ignored-roots>\r\n    <MESSAGE value=\"Мои учебно-тренировочные файлы по курсу Интенсив Python\" />\r\n    <option name=\"LAST_COMMIT_MESSAGE\" value=\"Мои учебно-тренировочные файлы по курсу Интенсив Python\" />\r\n  </component>\r\n  <component name=\"XDebuggerManager\">\r\n    <breakpoint-manager>\r\n      <breakpoints>\r\n        <line-breakpoint suspend=\"THREAD\" type=\"python-line\">\r\n          <url>file://$PROJECT_DIR$/INTPY/B4_Functions/decorators.py</url>\r\n          <line>85</line>\r\n          <option name=\"timeStamp\" value=\"29\" />\r\n        </line-breakpoint>\r\n        <line-breakpoint suspend=\"THREAD\" type=\"python-line\">\r\n          <url>file://$PROJECT_DIR$/INTPY/B5_exercises/test5415_cont.py</url>\r\n          <line>9</line>\r\n          <option name=\"timeStamp\" value=\"30\" />\r\n        </line-breakpoint>\r\n      </breakpoints>\r\n    </breakpoint-manager>\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/workspace.xml b/.idea/workspace.xml
--- a/.idea/workspace.xml	(revision aceb5b78e04eb6a1b997e1467f1364daa24c3211)
+++ b/.idea/workspace.xml	(date 1662886277811)
@@ -2,18 +2,56 @@
 <project version="4">
   <component name="ChangeListManager">
     <list default="true" id="69b1561c-f546-4fc1-917f-b89eceb341cf" name="Changes" comment="Мои учебно-тренировочные файлы по курсу Интенсив Python">
-      <change afterPath="$PROJECT_DIR$/INTPY/C3_modules_import_files_data/C3_2_exceptions.py" afterDir="false" />
-      <change afterPath="$PROJECT_DIR$/INTPY/C3_modules_import_files_data/C3_3_import.py" afterDir="false" />
-      <change afterPath="$PROJECT_DIR$/INTPY/C3_modules_import_files_data/C3_4_working_with_files.py" afterDir="false" />
-      <change afterPath="$PROJECT_DIR$/INTPY/C3_modules_import_files_data/file_open_write.py" afterDir="false" />
-      <change afterPath="$PROJECT_DIR$/INTPY/C3_modules_import_files_data/function.py" afterDir="false" />
-      <change afterPath="$PROJECT_DIR$/INTPY/C3_modules_import_files_data/main.py" afterDir="false" />
-      <change afterPath="$PROJECT_DIR$/INTPY/C3_modules_import_files_data/module_pattern.py" afterDir="false" />
-      <change afterPath="$PROJECT_DIR$/INTPY/C3_modules_import_files_data/test325.py" afterDir="false" />
-      <change afterPath="$PROJECT_DIR$/INTPY/C3_modules_import_files_data/test336.py" afterDir="false" />
-      <change afterPath="$PROJECT_DIR$/INTPY/C3_modules_import_files_data/test343.py" afterDir="false" />
-      <change afterPath="$PROJECT_DIR$/INTPY/C3_modules_import_files_data/time.py" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/.idea/encodings.xml" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/INTPY/B2_Data_types/bkank000.py" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/INTPY/C3_modules_import_files_data/C3_5_context_managers__with_.py" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/INTPY/C3_modules_import_files_data/numbers.txt" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/INTPY/C3_modules_import_files_data/pupils.txt" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/INTPY/C3_modules_import_files_data/test344.py" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/INTPY/C3_modules_import_files_data/test345.py" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/INTPY/C3_modules_import_files_data/test346.py" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/INTPY/C3_modules_import_files_data/test347.py" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/INTPY/C3_modules_import_files_data/test356.py" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/INTPY/C4_Algorythms_Data_structures/C4_2_O-notation.py" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/INTPY/C4_Algorythms_Data_structures/C4_3_Basic_data_structures.py" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/INTPY/C4_Algorythms_Data_structures/C4_4_Main_data_structures_list_stack_queue.py" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/INTPY/C4_Algorythms_Data_structures/C4_5_Nonlinear_data_structures__graphs_n_trees.py" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/INTPY/C4_Algorythms_Data_structures/C4_6_making_own_structures.py" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/INTPY/C4_Algorythms_Data_structures/C4_7_search_algorythms.py" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/INTPY/C4_Algorythms_Data_structures/C4_8_sorting_algorythms.py" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/INTPY/C4_Algorythms_Data_structures/LinkedList.py" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/INTPY/C4_Algorythms_Data_structures/_queue_.py" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/INTPY/C4_Algorythms_Data_structures/algorythm_Deikstra.py" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/INTPY/C4_Algorythms_Data_structures/algorythm_Deikstra_mod.py" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/INTPY/C4_Algorythms_Data_structures/binary_tree.py" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/INTPY/C4_Algorythms_Data_structures/bubble_sort.py" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/INTPY/C4_Algorythms_Data_structures/choose_sort.py" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/INTPY/C4_Algorythms_Data_structures/insert_sort.py" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/INTPY/C4_Algorythms_Data_structures/merge_sort.py" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/INTPY/C4_Algorythms_Data_structures/naiv_sort.py" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/INTPY/C4_Algorythms_Data_structures/par_checker.py" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/INTPY/C4_Algorythms_Data_structures/quick_sort.py" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/INTPY/C4_Algorythms_Data_structures/test441.py" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/INTPY/C4_Algorythms_Data_structures/test445_par_chercker_modfied.py" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/INTPY/C4_Algorythms_Data_structures/tests_for_webinar.html" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/INTPY/C5_Requests_JSON_Redis_etc/3_telebot.py" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/INTPY/C5_Requests_JSON_Redis_etc/C5_1_Intro.py" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/INTPY/C5_Requests_JSON_Redis_etc/C5_2_Requests_JSON.py" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/INTPY/C5_Requests_JSON_Redis_etc/C5_3_Making_telegram_bot.py" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/INTPY/C5_Requests_JSON_Redis_etc/C5_4_site_parsing_lxml.py" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/INTPY/C5_Requests_JSON_Redis_etc/C5_5_Caching_with_Redis.py" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/INTPY/C5_Requests_JSON_Redis_etc/C5_6_Control_project.py" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/INTPY/C5_Requests_JSON_Redis_etc/CRYPTO_BOT/app.py" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/INTPY/C5_Requests_JSON_Redis_etc/test523_json.py" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/.idea/PycharmProjects.iml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/PycharmProjects.iml" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/.idea/misc.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/misc.xml" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/INTPY/B3_Conditions/tests.py" beforeDir="false" afterPath="$PROJECT_DIR$/INTPY/B3_Conditions/tests.py" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/INTPY/C2_sea_battle/main.py" beforeDir="false" afterPath="$PROJECT_DIR$/INTPY/C2_sea_battle/main.py" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/INTPY/C3_modules_import_files_data/C3_4_working_with_files.py" beforeDir="false" afterPath="$PROJECT_DIR$/INTPY/C3_modules_import_files_data/C3_4_working_with_files.py" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/INTPY/C3_modules_import_files_data/file_open_write.py" beforeDir="false" afterPath="$PROJECT_DIR$/INTPY/C3_modules_import_files_data/file_open_write.py" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/INTPY/C3_modules_import_files_data/function.py" beforeDir="false" afterPath="$PROJECT_DIR$/INTPY/C3_modules_import_files_data/function.py" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/INTPY/C3_modules_import_files_data/time.py" beforeDir="false" afterPath="$PROJECT_DIR$/INTPY/C3_modules_import_files_data/time.py" afterDir="false" />
     </list>
     <option name="SHOW_DIALOG" value="false" />
     <option name="HIGHLIGHT_CONFLICTS" value="true" />
@@ -40,22 +78,23 @@
     <option name="hideEmptyMiddlePackages" value="true" />
     <option name="showLibraryContents" value="true" />
   </component>
-  <component name="PropertiesComponent"><![CDATA[{
-  "keyToString": {
-    "DefaultHtmlFileTemplate": "HTML File",
-    "RunOnceActivity.OpenProjectViewOnStart": "true",
-    "RunOnceActivity.ShowReadmeOnStart": "true",
-    "last_opened_file_path": "D:/Git/PycharmProjects/INTPY/C2_sea_battle",
-    "settings.editor.selected.configurable": "editing.templates"
+  <component name="PropertiesComponent">{
+  &quot;keyToString&quot;: {
+    &quot;DefaultHtmlFileTemplate&quot;: &quot;HTML File&quot;,
+    &quot;RunOnceActivity.OpenProjectViewOnStart&quot;: &quot;true&quot;,
+    &quot;RunOnceActivity.ShowReadmeOnStart&quot;: &quot;true&quot;,
+    &quot;SHARE_PROJECT_CONFIGURATION_FILES&quot;: &quot;true&quot;,
+    &quot;last_opened_file_path&quot;: &quot;/media/yury/Data/Git/PycharmProjects&quot;,
+    &quot;settings.editor.selected.configurable&quot;: &quot;com.jetbrains.python.configuration.PyActiveSdkModuleConfigurable&quot;
   },
-  "keyToStringList": {
-    "GitStage.ChangesTree.GroupingKeys": [
-      "directory",
-      "module",
-      "repository"
+  &quot;keyToStringList&quot;: {
+    &quot;GitStage.ChangesTree.GroupingKeys&quot;: [
+      &quot;directory&quot;,
+      &quot;module&quot;,
+      &quot;repository&quot;
     ]
   }
-}]]></component>
+}</component>
   <component name="RecentsManager">
     <key name="CopyFile.RECENT_KEYS">
       <recent name="D:\Git\PycharmProjects\INTPY\Git.GitHub" />
@@ -71,8 +110,8 @@
       <recent name="D:\Git\PycharmProjects\INTPY\C1_Intro_to_OOP" />
     </key>
   </component>
-  <component name="RunManager" selected="Python.test336">
-    <configuration name="C3_4_working_with_files" type="PythonConfigurationType" factoryName="Python" temporary="true" nameIsGenerated="true">
+  <component name="RunManager" selected="Python.app">
+    <configuration name="app" type="PythonConfigurationType" factoryName="Python" temporary="true" nameIsGenerated="true">
       <module name="PycharmProjects" />
       <option name="INTERPRETER_OPTIONS" value="" />
       <option name="PARENT_ENVS" value="true" />
@@ -80,11 +119,11 @@
         <env name="PYTHONUNBUFFERED" value="1" />
       </envs>
       <option name="SDK_HOME" value="" />
-      <option name="WORKING_DIRECTORY" value="$PROJECT_DIR$/INTPY/C3_modules_import_files_data" />
+      <option name="WORKING_DIRECTORY" value="$PROJECT_DIR$/INTPY/C5_Requests_JSON_Redis_etc/CRYPTO_BOT" />
       <option name="IS_MODULE_SDK" value="true" />
       <option name="ADD_CONTENT_ROOTS" value="true" />
       <option name="ADD_SOURCE_ROOTS" value="true" />
-      <option name="SCRIPT_NAME" value="$PROJECT_DIR$/INTPY/C3_modules_import_files_data/C3_4_working_with_files.py" />
+      <option name="SCRIPT_NAME" value="$PROJECT_DIR$/INTPY/C5_Requests_JSON_Redis_etc/CRYPTO_BOT/app.py" />
       <option name="PARAMETERS" value="" />
       <option name="SHOW_COMMAND_LINE" value="false" />
       <option name="EMULATE_TERMINAL" value="false" />
@@ -93,7 +132,7 @@
       <option name="INPUT_FILE" value="" />
       <method v="2" />
     </configuration>
-    <configuration name="file_open_write" type="PythonConfigurationType" factoryName="Python" temporary="true" nameIsGenerated="true">
+    <configuration name="bkank000" type="PythonConfigurationType" factoryName="Python" temporary="true" nameIsGenerated="true">
       <module name="PycharmProjects" />
       <option name="INTERPRETER_OPTIONS" value="" />
       <option name="PARENT_ENVS" value="true" />
@@ -101,11 +140,11 @@
         <env name="PYTHONUNBUFFERED" value="1" />
       </envs>
       <option name="SDK_HOME" value="" />
-      <option name="WORKING_DIRECTORY" value="$PROJECT_DIR$/INTPY/C3_modules_import_files_data" />
+      <option name="WORKING_DIRECTORY" value="$PROJECT_DIR$/INTPY/B2_Data_types" />
       <option name="IS_MODULE_SDK" value="true" />
       <option name="ADD_CONTENT_ROOTS" value="true" />
       <option name="ADD_SOURCE_ROOTS" value="true" />
-      <option name="SCRIPT_NAME" value="$PROJECT_DIR$/INTPY/C3_modules_import_files_data/file_open_write.py" />
+      <option name="SCRIPT_NAME" value="$PROJECT_DIR$/INTPY/B2_Data_types/bkank000.py" />
       <option name="PARAMETERS" value="" />
       <option name="SHOW_COMMAND_LINE" value="false" />
       <option name="EMULATE_TERMINAL" value="false" />
@@ -114,7 +153,7 @@
       <option name="INPUT_FILE" value="" />
       <method v="2" />
     </configuration>
-    <configuration name="test336" type="PythonConfigurationType" factoryName="Python" temporary="true" nameIsGenerated="true">
+    <configuration name="blank" type="PythonConfigurationType" factoryName="Python" temporary="true" nameIsGenerated="true">
       <module name="PycharmProjects" />
       <option name="INTERPRETER_OPTIONS" value="" />
       <option name="PARENT_ENVS" value="true" />
@@ -122,11 +161,11 @@
         <env name="PYTHONUNBUFFERED" value="1" />
       </envs>
       <option name="SDK_HOME" value="" />
-      <option name="WORKING_DIRECTORY" value="$PROJECT_DIR$/INTPY/C3_modules_import_files_data" />
+      <option name="WORKING_DIRECTORY" value="$PROJECT_DIR$/INTPY/B2_Data_types" />
       <option name="IS_MODULE_SDK" value="true" />
       <option name="ADD_CONTENT_ROOTS" value="true" />
       <option name="ADD_SOURCE_ROOTS" value="true" />
-      <option name="SCRIPT_NAME" value="$PROJECT_DIR$/INTPY/C3_modules_import_files_data/test336.py" />
+      <option name="SCRIPT_NAME" value="$PROJECT_DIR$/INTPY/B2_Data_types/blank.py" />
       <option name="PARAMETERS" value="" />
       <option name="SHOW_COMMAND_LINE" value="false" />
       <option name="EMULATE_TERMINAL" value="false" />
@@ -135,7 +174,7 @@
       <option name="INPUT_FILE" value="" />
       <method v="2" />
     </configuration>
-    <configuration name="test343" type="PythonConfigurationType" factoryName="Python" temporary="true" nameIsGenerated="true">
+    <configuration name="test (1)" type="PythonConfigurationType" factoryName="Python" temporary="true" nameIsGenerated="true">
       <module name="PycharmProjects" />
       <option name="INTERPRETER_OPTIONS" value="" />
       <option name="PARENT_ENVS" value="true" />
@@ -143,11 +182,11 @@
         <env name="PYTHONUNBUFFERED" value="1" />
       </envs>
       <option name="SDK_HOME" value="" />
-      <option name="WORKING_DIRECTORY" value="$PROJECT_DIR$/INTPY/C3_modules_import_files_data" />
+      <option name="WORKING_DIRECTORY" value="$PROJECT_DIR$/INTPY/C5_Requests_JSON_Redis_etc/CRYPTO_BOT" />
       <option name="IS_MODULE_SDK" value="true" />
       <option name="ADD_CONTENT_ROOTS" value="true" />
       <option name="ADD_SOURCE_ROOTS" value="true" />
-      <option name="SCRIPT_NAME" value="$PROJECT_DIR$/INTPY/C3_modules_import_files_data/test343.py" />
+      <option name="SCRIPT_NAME" value="$PROJECT_DIR$/INTPY/C5_Requests_JSON_Redis_etc/CRYPTO_BOT/test.py" />
       <option name="PARAMETERS" value="" />
       <option name="SHOW_COMMAND_LINE" value="false" />
       <option name="EMULATE_TERMINAL" value="false" />
@@ -156,7 +195,7 @@
       <option name="INPUT_FILE" value="" />
       <method v="2" />
     </configuration>
-    <configuration name="time" type="PythonConfigurationType" factoryName="Python" temporary="true" nameIsGenerated="true">
+    <configuration name="test004" type="PythonConfigurationType" factoryName="Python" temporary="true" nameIsGenerated="true">
       <module name="PycharmProjects" />
       <option name="INTERPRETER_OPTIONS" value="" />
       <option name="PARENT_ENVS" value="true" />
@@ -164,11 +203,11 @@
         <env name="PYTHONUNBUFFERED" value="1" />
       </envs>
       <option name="SDK_HOME" value="" />
-      <option name="WORKING_DIRECTORY" value="$PROJECT_DIR$/INTPY/C3_modules_import_files_data" />
+      <option name="WORKING_DIRECTORY" value="$PROJECT_DIR$/INTPY/C5_Requests_JSON_Redis_etc" />
       <option name="IS_MODULE_SDK" value="true" />
       <option name="ADD_CONTENT_ROOTS" value="true" />
       <option name="ADD_SOURCE_ROOTS" value="true" />
-      <option name="SCRIPT_NAME" value="$PROJECT_DIR$/INTPY/C3_modules_import_files_data/time.py" />
+      <option name="SCRIPT_NAME" value="$PROJECT_DIR$/INTPY/C5_Requests_JSON_Redis_etc/test004.py" />
       <option name="PARAMETERS" value="" />
       <option name="SHOW_COMMAND_LINE" value="false" />
       <option name="EMULATE_TERMINAL" value="false" />
@@ -179,11 +218,11 @@
     </configuration>
     <recent_temporary>
       <list>
-        <item itemvalue="Python.test336" />
-        <item itemvalue="Python.C3_4_working_with_files" />
-        <item itemvalue="Python.file_open_write" />
-        <item itemvalue="Python.test343" />
-        <item itemvalue="Python.time" />
+        <item itemvalue="Python.app" />
+        <item itemvalue="Python.bkank000" />
+        <item itemvalue="Python.blank" />
+        <item itemvalue="Python.test (1)" />
+        <item itemvalue="Python.test004" />
       </list>
     </recent_temporary>
   </component>
@@ -203,7 +242,14 @@
       <option name="project" value="LOCAL" />
       <updated>1661855186546</updated>
     </task>
-    <option name="localTasksCounter" value="2" />
+    <task id="LOCAL-00002" summary="Мои учебно-тренировочные файлы по курсу Интенсив Python">
+      <created>1661937747195</created>
+      <option name="number" value="00002" />
+      <option name="presentableId" value="LOCAL-00002" />
+      <option name="project" value="LOCAL" />
+      <updated>1661937747195</updated>
+    </task>
+    <option name="localTasksCounter" value="3" />
     <servers />
   </component>
   <component name="Vcs.Log.Tabs.Properties">
@@ -232,18 +278,13 @@
   </component>
   <component name="XDebuggerManager">
     <breakpoint-manager>
-      <breakpoints>
-        <line-breakpoint suspend="THREAD" type="python-line">
-          <url>file://$PROJECT_DIR$/INTPY/B4_Functions/decorators.py</url>
-          <line>85</line>
-          <option name="timeStamp" value="29" />
-        </line-breakpoint>
-        <line-breakpoint suspend="THREAD" type="python-line">
-          <url>file://$PROJECT_DIR$/INTPY/B5_exercises/test5415_cont.py</url>
-          <line>9</line>
-          <option name="timeStamp" value="30" />
-        </line-breakpoint>
-      </breakpoints>
+      <default-breakpoints>
+        <breakpoint type="python-exception">
+          <properties notifyOnTerminate="true" exception="BaseException">
+            <option name="notifyOnTerminate" value="true" />
+          </properties>
+        </breakpoint>
+      </default-breakpoints>
     </breakpoint-manager>
   </component>
 </project>
\ No newline at end of file
Index: INTPY/C5_Requests_JSON_Redis_etc/test523_json.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/INTPY/C5_Requests_JSON_Redis_etc/test523_json.py b/INTPY/C5_Requests_JSON_Redis_etc/test523_json.py
new file mode 100644
--- /dev/null	(date 1662472755115)
+++ b/INTPY/C5_Requests_JSON_Redis_etc/test523_json.py	(date 1662472755115)
@@ -0,0 +1,8 @@
+import requests
+import json
+
+r = requests.get('https://baconipsum.com/api/?type=meat-and-filler')
+
+r = json.loads(r.content)
+
+print(r[0])
\ No newline at end of file
Index: .idea/PycharmProjects.iml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<module type=\"PYTHON_MODULE\" version=\"4\">\r\n  <component name=\"NewModuleRootManager\">\r\n    <content url=\"file://$MODULE_DIR$\">\r\n      <sourceFolder url=\"file://$MODULE_DIR$/venv\" isTestSource=\"false\" />\r\n    </content>\r\n    <orderEntry type=\"inheritedJdk\" />\r\n    <orderEntry type=\"sourceFolder\" forTests=\"false\" />\r\n  </component>\r\n</module>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/PycharmProjects.iml b/.idea/PycharmProjects.iml
--- a/.idea/PycharmProjects.iml	(revision aceb5b78e04eb6a1b997e1467f1364daa24c3211)
+++ b/.idea/PycharmProjects.iml	(date 1662461033648)
@@ -2,9 +2,11 @@
 <module type="PYTHON_MODULE" version="4">
   <component name="NewModuleRootManager">
     <content url="file://$MODULE_DIR$">
+      <sourceFolder url="file://$MODULE_DIR$" isTestSource="false" />
       <sourceFolder url="file://$MODULE_DIR$/venv" isTestSource="false" />
+      <excludeFolder url="file://$MODULE_DIR$/venv" />
     </content>
-    <orderEntry type="inheritedJdk" />
+    <orderEntry type="jdk" jdkName="Python 3.10 (PycharmProjects) (2)" jdkType="Python SDK" />
     <orderEntry type="sourceFolder" forTests="false" />
   </component>
 </module>
\ No newline at end of file
Index: INTPY/C3_modules_import_files_data/time.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import time\r\nimport calendar\r\n\r\nprint(time.ctime())\r\nprint(time.time())\r\n\r\nc = calendar.TextCalendar()\r\nc.pryear(2022)
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/INTPY/C3_modules_import_files_data/time.py b/INTPY/C3_modules_import_files_data/time.py
--- a/INTPY/C3_modules_import_files_data/time.py	(revision aceb5b78e04eb6a1b997e1467f1364daa24c3211)
+++ b/INTPY/C3_modules_import_files_data/time.py	(date 1661937939501)
@@ -4,5 +4,9 @@
 print(time.ctime())
 print(time.time())
 
+
+# красивый календарь. Аркадий Хазанов предложил ознакомиться с ним на предмет того,
+# как в консоли реализуются по нескольку таблиц. В связи с тем, что один из сокурсников
+# сумел в Морском бое разместить две таблицы в ряд
 c = calendar.TextCalendar()
 c.pryear(2022)
\ No newline at end of file
Index: INTPY/C5_Requests_JSON_Redis_etc/C5_5_Caching_with_Redis.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/INTPY/C5_Requests_JSON_Redis_etc/C5_5_Caching_with_Redis.py b/INTPY/C5_Requests_JSON_Redis_etc/C5_5_Caching_with_Redis.py
new file mode 100644
--- /dev/null	(date 1662569301686)
+++ b/INTPY/C5_Requests_JSON_Redis_etc/C5_5_Caching_with_Redis.py	(date 1662569301686)
@@ -0,0 +1,198 @@
+##############################################################################
+# С5.5. Кеширование с помощью Redis
+##############################################################################
+
+# В этом юните мы будем говорить о кешировании.
+
+# Кеширование — это временное сохранение данных для дальнейшего доступа к ним.
+
+# Воспринимайте кеширование как нечто чуть более серьёзное, чем хранение ваших
+# данных в файле, но чуть менее серьёзное, чем хранение ваших данных в полноценных
+# базах. Например, Redis отлично может хранить недавние действия пользователя на
+# вашем сайте, какие-то сообщения из онлайн-чата и так далее.
+
+# Давайте же перейдём от слов к делу и научимся кешировать данные с помощью Redis.
+#
+# Первое, что вам надо будет сделать — это поставить себе Redis.
+#
+# Это можно сделать несколькими способами. Наиболее удобный, на наш взгляд, —
+# воспользоваться облачным сервисом от Redis Labs и хранить ваши данные в облаке.
+# Как это сделать, можете посмотреть в видео ниже.
+
+# Если же вы работаете на Mac OS, то процедура будет крайне похожа на процедуру на
+# Linux, так как и там, и там Redis легко устанавливается через терминал. Однако вы
+# также можете воспользоваться установкой с Windows, так как она немного сложнее, но
+# зато подходит для всех платформ, потому как находится в облаке.
+#
+# Для работы с Redis в Python нужно установить специальную библиотеку:
+
+# pip3 install redis
+
+# Теперь, если вы установили Redis себе на компьютер, то дальше ничего делать не нужно.
+# А если вы пользовались бесплатным облачным сервисом Redis Labs ( https://app.redislabs.com/ ),
+# то вам необходимо будет дополнительно вводить пароль при подключении. Пароль можно найти,
+# перейдя в вашу созданную БД и скопировав следующее поле:
+# Access Control & Security - Default User Password ...
+
+# Теперь давайте попробуем всё же написать код подключения к нашей базе данных:
+
+import redis  # импортируем библиотеку
+
+red = redis.Redis(
+    host=хост,
+    # ваш хост, если вы поставили Редис к себе на локальную машину, то у вас это будет
+    # localhost. Если же вы находитесь на Windows, то воспользуйтесь полем host из вашей
+    # облачной БД, которую мы создавали в скринкасте.
+    port=порт,
+    # порт подключения. На локальной машине это должно быть 6379. Для пользователей
+    # облачного сервиса порт всегда разный, поэтому его надо копировать оттуда же, что и host.
+    password=пароль
+    # для локальной машины пароль не требуется (если вы устанавливали Редис к себе на компьютер
+    # и не пользовались облачным сервисом из скринкаста выше). Для пользователей облачного
+    # сервиса пароль находится в вашей облачной базе данных в поле password
+)
+
+# Если же вы пользовались облачным сервисом от Redis Labs, то ваше значение host
+# будет храниться в поле endpoint до двоеточия, а port — после двоеточия.
+
+# И да, обратите внимание, что порт мы указывали целым числом, а не строкой.
+#
+# Теперь давайте попробуем записать данные в кеш. Для этого используется метод:
+# .set(<название переменной для хеширования>, <значение переменной в виде строки>).
+
+import redis
+
+red = redis.Redis(
+    host='хост',
+    port=порт,
+    password='пароль'
+)
+
+red.set('var1', 'value1')  # записываем в кеш строку "value1"
+print(red.get('var1'))  # считываем из кеша данные
+
+# В результате в консоли мы увидим:
+#
+# Но на этом ещё не всё. Вся загвоздка здесь в том, что данные, записанные нами,
+# не зависят от текущей сессии. Они не стираются после того, как скрипт закончит
+# работу. Их состояние зависит только от самого хранилища, которое крутится у нас в облаке.
+#
+# Давайте теперь удалим некоторые строчки и убедимся, что данные, которые мы з
+# аписывали в предыдущей сессии, сохранились.
+
+import redis
+
+red = redis.Redis(
+    host='хост',
+    port=порт,
+    password='пароль'
+)
+
+print(red.get('var1'))  # считываем из кеша данные
+
+# И вот! Всё тот же результат!
+
+# Как видим, строки хранятся отлично. И получать их можно оттуда так же легко.
+# Давайте теперь попробуем записать в кеш что-нибудь посложнее, например, словарь.
+
+import redis
+import \
+    json  # так-так-так, кто это тут у нас? Наш старый друг Джейсон заглянул на огонёк! Ну привет, чем ты сегодня нас порадуешь?
+
+red = redis.Redis(
+    host='хост',
+    port=порт,
+    password='пароль'
+)
+
+dict1 = {'key1': 'value1', 'key2': 'value2'}  # создаём словарь для записи
+red.set('dict1', json.dumps(dict1))  # с помощью функции dumps() из модуля json превратим наш словарь в строчку
+converted_dict = json.loads(
+    red.get('dict1'))  # с помощью знакомой нам функции превращаем данные, полученные из кеша обратно в словарь
+print(type(converted_dict))  # убеждаемся, что мы получили действительно словарь
+print(converted_dict)  # ну и выводим его содержание
+
+# Наконец, давайте научимся удалять данные из кеша по ключу.
+# Это делается совсем просто.
+
+import redis
+import json
+
+red = redis.Redis(
+    host='хост',
+    port=порт,
+    password='пароль'
+)
+
+red.delete('dict1')  # удаляются ключи с помощью метода .delete()
+print(red.get('dict1'))
+
+# Проверяем консоль:
+#
+
+# Как итог мы видим, что у нас вывелось None. То есть ключа,
+# который мы добавили, больше нет.
+#
+# Вот и всё. В этом юните мы научились устанавливать Redis, записывать
+# и хранить в нём данные, а также считывать и удалять их.
+#
+# В заключение хотим отметить, что Redis — это довольно мощный инструмент.
+# Его, конечно же, не желательно использовать как основную базу данных для
+# каких-либо более или менее серьёзных проектов. Дело в том, что сам по себе
+# он крайне неструктурирован, и чем пытаться закопать в кеш какую-либо
+# определённую структуру всех хранимых объектов, легче воспользоваться г
+# отовыми СУБД, например, PostgreSQL, которые мы будем проходить дальше в курсе.
+#
+# Однако в Redis отлично хранятся данные, которые по своей структуре не похожи
+# ни на одну таблицу или же которые надо будет просто периодически считывать
+# и забывать про них. Инструмент очень полезный и необычный. Лучше во всяком
+# случае, чем хранить данные в файле.
+#
+# Надеемся, данный юнит был вам полезен и вы научились кешировать данные с помощью Redis.
+
+#
+# Задание 5.5.1
+# Попробуйте самостоятельно зарегистрироваться на app.redislabs.com. Создайте
+# аккаунт с бесплатной подпиской и новую базу данных.
+
+# Задание 5.5.4
+#
+# Напишите программу, которая будет записывать и кешировать номера телефонов ваших друзей.
+#
+# Программа должна уметь воспринимать несколько команд:
+#
+#         записать номер;
+#         показать номер друга в консоли при вводе имени;
+#         удалить номер друга по имени.
+#
+# Кеширование надо производить с помощью Redis. Ввод и вывод информации должен быть
+# реализован через консоль (с помощью функций input() и print()).
+
+red = redis.Redis(
+    host = 'ваш хост',
+    port = ваш порт,
+    password = пароль
+)
+
+cont = True
+
+while cont:
+    action = input('action:\t')
+    if action == 'write':
+        name = input('name:\t')
+        phone = input('phone:\t')
+        red.set(name, phone)
+    elif action == 'read':
+        name = input('name:\t')
+        phone = red.get(name)
+        if phone:
+            print(f'{name}\'s phone is {str(phone)}')
+    elif action == 'delete':
+        name = input('name:\t')
+        phone = red.delete(name)
+        if phone:
+            print(f"{name}'s phone is deleted")
+        else:
+            print(f"Not found {name}")
+    elif action == 'stop':
+        break
Index: INTPY/C5_Requests_JSON_Redis_etc/C5_6_Control_project.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/INTPY/C5_Requests_JSON_Redis_etc/C5_6_Control_project.py b/INTPY/C5_Requests_JSON_Redis_etc/C5_6_Control_project.py
new file mode 100644
--- /dev/null	(date 1662569946982)
+++ b/INTPY/C5_Requests_JSON_Redis_etc/C5_6_Control_project.py	(date 1662569946982)
@@ -0,0 +1,87 @@
+##############################################################################
+# С5.6. Контрольный проект
+##############################################################################
+
+# Вот и всё, начальная школа закончилась. Пришла пора шагнуть во взрослую
+# разраберскую жизнь. Вам предстоит написать проект, который вы с гордостью
+# сможете показать своим друзьям/работодателю/внукам, сказав, что этот проект
+# был вашим первым детищем. Этот проект проверят наши замечательные менторы и дадут вам обратную связь.
+#
+# А поскольку начальная школа хоть и закончилась, но всё же это начальная школа,
+# мы подготовили для вас серию скринкастов, в которой подробно и обстоятельно
+# описывается каждый шаг написания похожего проекта. Это тоже будет бот, крайне
+# похожий по функционалу, но с небольшими отличиями. Да чего уж вам рассказывать.
+# Смотрите, сами всё и узнаете!
+#
+# Сначала нам понадобится создать бота.
+#################################
+# Написание бота. Часть 1
+# ###############################
+
+########################################################################################
+# Затем нужно будет написать обработчики, которые будут выполнять основную часть работы.
+########################################################################################
+#
+
+#############################################################
+# Написание бота. Знакомство с API, пишем главный обработчик
+# ###########################################################
+
+
+##############################################################################################
+# После этого мы доработаем наш код, начав исправлять ошибки, если вдруг что-то пойдёт не так.
+# ############################################################################################
+
+
+#####################################
+# Написание бота. Обрабатываем ошибки
+# ###################################
+
+########################################################################################
+# После чего мы приведём наш код в порядок, разделив его по функционалу на разные файлы.
+########################################################################################
+
+
+#############################
+# Написание бота. Рефакторинг
+#############################
+
+
+############################################################################
+# Далее мы окончательно сделаем нашего бота дружелюбным, и всё будет готово!
+############################################################################
+
+
+############################
+# Написание бота. Заключение
+############################
+#
+
+##############################################################################
+# Теперь, используя полученные знания, вы самостоятельно сможете написать
+# очень похожего бота, который будет работать с обычными валютами.
+
+# Задание
+# Напишите Telegram-бота, в котором будет реализован следующий функционал:
+
+#
+    # 1. Бот возвращает цену на определённое количество валюты (евро, доллар или рубль).
+    # 2. При написании бота необходимо использовать библиотеку pytelegrambotapi.
+    # 3. Человек должен отправить сообщение боту в виде <имя валюты, цену которой он хочет
+    #    узнать> <имя валюты, в которой надо узнать цену первой валюты> <количество первой валюты>.
+    # 4. При вводе команды /start или /help пользователю выводятся инструкции по применению бота.
+    # 5. При вводе команды /values должна выводиться информация о всех доступных валютах в читаемом виде.
+    # 6. Для получения курса валют необходимо использовать любое удобное API и отправлять к нему запросы
+    #    с помощью библиотеки Requests.
+    # 7. Для парсинга полученных ответов использовать библиотеку JSON.
+    # 8. При ошибке пользователя (например, введена неправильная или несуществующая валюта или неправильно
+    #    введено число) вызывать собственно написанное исключение APIException с текстом пояснения ошибки.
+    # 9. Текст любой ошибки с указанием типа ошибки должен отправляться пользователю в сообщения.
+    # 10. Для отправки запросов к API описать класс со статическим методом get_price(), который принимает
+    #     три аргумента и возвращает нужную сумму в валюте:
+    #           имя валюты, цену на которую надо узнать, — base;
+    #           имя валюты, цену в которой надо узнать, — quote;
+    #           количество переводимой валюты — amount.
+    # 11. Токен Telegram-бота хранить в специальном конфиге (можно использовать .py файл).
+    # 12. Все классы спрятать в файле extensions.py.
+
Index: INTPY/C3_modules_import_files_data/test344.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/INTPY/C3_modules_import_files_data/test344.py b/INTPY/C3_modules_import_files_data/test344.py
new file mode 100644
--- /dev/null	(date 1661946766806)
+++ b/INTPY/C3_modules_import_files_data/test344.py	(date 1661946766806)
@@ -0,0 +1,18 @@
+# Задание 3.4.4
+# Создайте любой файл на операционной системе под название input.txt и
+# построчно перепишите его в файл output.txt.
+
+f = open('input.txt', 'w', encoding='utf8')
+f.write("Раз, два, три, четыре, пять!\n")
+f.write("Вышел зайчик погулять.\n")
+f.write("Вдруг охотник выбегает,\n")
+f.write("Прямо в зайчика стреляет!\n")
+f.close()
+
+with open('input.txt', 'r') as input_file:
+    with open('output.txt', 'w') as output_file:
+        for line in input_file:
+            output_file.write(line)
+
+        # print(output_file.read())
+
Index: INTPY/C3_modules_import_files_data/pupils.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/INTPY/C3_modules_import_files_data/pupils.txt b/INTPY/C3_modules_import_files_data/pupils.txt
new file mode 100644
--- /dev/null	(date 1661949824309)
+++ b/INTPY/C3_modules_import_files_data/pupils.txt	(date 1661949824309)
@@ -0,0 +1,15 @@
+Иванов О. 4
+Петров И. 3
+Дмитриев Н. 2
+Смирнова О. 4
+Керченских В. 5
+Котов Д. 2
+Бирюкова Н. 1
+Данилов П. 3
+Аранских В. 5
+Лемонов Ю. 2
+Седых М. 4
+Клюшкина Е. 3
+Фомин А. 1
+Булочкин С. 2
+Колышкин М. 1
\ No newline at end of file
Index: INTPY/C3_modules_import_files_data/test356.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/INTPY/C3_modules_import_files_data/test356.py b/INTPY/C3_modules_import_files_data/test356.py
new file mode 100644
--- /dev/null	(date 1661958621682)
+++ b/INTPY/C3_modules_import_files_data/test356.py	(date 1661958621682)
@@ -0,0 +1,29 @@
+##################################################################################
+# Задание 3.5.6
+# Напишите контекстный менеджер, который умеет безопасно работать с файлами.
+# В конструктор объекта контекстного менеджера передаются два аргумента:
+# первый — путь к файлу, который надо открыть, второй — тип открываемого файла
+# (для записи, для чтения и т. д.).
+#
+# При входе в контекстный менеджер должен открываться файл, и возвращаться
+# объект для работы с этим файлом.
+#
+# При выходе из контекстного менеджера файл должен закрываться.
+# (Эталоном работы можно считать контекстный менеджер open).
+
+class OpenFile:
+    def __init__(self, path, type):
+        self.file = open(path, type, encoding="utf8")
+
+    def __enter__(self):
+        return self.file
+
+    def __exit__(self, exc_type, exc_val, exc_tb):
+        self.file.close()
+
+with OpenFile('test2.txt', 'wt') as f:
+    f.write("Пишу сие чрез такую занимательнейшую и \n"
+            "прелюбопытственнейшую штучку, коей является \n"
+            "презабавнейший скрипт под титлом \n"
+            "контекстный мэнэжэрр")
+    print(f.read())
\ No newline at end of file
Index: INTPY/C3_modules_import_files_data/test346.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/INTPY/C3_modules_import_files_data/test346.py b/INTPY/C3_modules_import_files_data/test346.py
new file mode 100644
--- /dev/null	(date 1661949852223)
+++ b/INTPY/C3_modules_import_files_data/test346.py	(date 1661949852223)
@@ -0,0 +1,26 @@
+# Задание 3.4.6
+# В текстовый файл построчно записаны фамилии и имена учащихся класса и
+# их оценки за контрольную. Выведите на экран всех учащихся, чья оценка
+# меньше 3 баллов. Cодержание файла:
+#
+# Иванов О. 4
+# Петров И. 3
+# Дмитриев Н. 2
+# Смирнова О. 4
+# Керченских В. 5
+# Котов Д. 2
+# Бирюкова Н. 1
+# Данилов П. 3
+# Аранских В. 5
+# Лемонов Ю. 2
+
+filename = 'pupils.txt'
+
+with open(filename, encoding='utf8') as file:
+    for line in file:
+        grade = int(line.split()[-1])
+        if grade < 3:
+            name = ' '.join(line.split()[:-1])
+            print(name)
+
+
Index: INTPY/C3_modules_import_files_data/test345.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/INTPY/C3_modules_import_files_data/test345.py b/INTPY/C3_modules_import_files_data/test345.py
new file mode 100644
--- /dev/null	(date 1661948442367)
+++ b/INTPY/C3_modules_import_files_data/test345.py	(date 1661948442367)
@@ -0,0 +1,30 @@
+# Задание 3.4.5
+# Дан файл numbers.txt, компоненты которого являются действительными числами
+# (файл создайте самостоятельно и заполните любыми числами, в одной строке одно
+# число). Найдите сумму наибольшего и наименьшего из значений
+# и запишите результат в файл output.txt.
+
+filename = 'numbers.txt'
+output = 'output.txt'
+# sum_ = None
+
+with open(filename) as f:
+    min_ = max_ = float(f.readline())
+    for line in f:
+        num = float(line)
+        if num > max_:
+            max_ = num
+        elif num < min_:
+            min_ = num
+
+    sum_ = min_ + max_
+
+with open('output.txt', 'w') as f:
+    f.write(str(sum_))
+    f.write('\n')
+
+
+if __name__ == '__main__':
+    f = open('output.txt', 'r')
+    print(f.read())
+    f.close()
Index: INTPY/C4_Algorythms_Data_structures/test441.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/INTPY/C4_Algorythms_Data_structures/test441.py b/INTPY/C4_Algorythms_Data_structures/test441.py
new file mode 100644
--- /dev/null	(date 1662092595016)
+++ b/INTPY/C4_Algorythms_Data_structures/test441.py	(date 1662092595016)
@@ -0,0 +1,13 @@
+# Задание 4.4.1
+# Демонстрация того, что вычисления в рекурсивной функции идут
+# в обратном направлении, то есть не при РЕКУРСИВНОМ СПУСКЕ, а
+# при РЕКУРСИВНОМ ВОЗВРАТЕ
+
+def f(n):
+    if n == 0:
+        return
+    else:
+        f(n-1)
+        print(n)
+
+f(5)
Index: INTPY/C4_Algorythms_Data_structures/_queue_.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/INTPY/C4_Algorythms_Data_structures/_queue_.py b/INTPY/C4_Algorythms_Data_structures/_queue_.py
new file mode 100644
--- /dev/null	(date 1662215662827)
+++ b/INTPY/C4_Algorythms_Data_structures/_queue_.py	(date 1662215662827)
@@ -0,0 +1,121 @@
+# Попробуем создать обработчик задач на бесконечном цикле с использованием очереди:
+
+# Создадим класс Queue — нужная нам очередь
+class Queue:
+    # Конструктор нашего класса, в нём происходит нужная инициализация объекта
+    def __init__(self, max_size):
+        self.max_size = max_size  # размер очереди
+        self.task_num = 0  # будем хранить сквозной номер задачи
+
+        self.tasks = [0 for _ in range(self.max_size)]  # инициализируем список с нулевыми элементами
+        self.head = 0  # указатель на начало очереди
+        self.tail = 0  # указатель на элемент следующий за концом очереди
+
+    # Добавьте в класс Queue метод is_empty, который проверяет наличие элементов
+    # в очереди, используя указатели head и tail. Запрещается использование
+    # функции len(list_), так как её сложность .
+    def is_empty(self):
+        # if self.head and self.tail == 0:
+        #     return False
+        # else:
+        #     return True
+        # Правильный ответ:
+        # да, если указатели совпадают и в них содержится ноль
+        return self.head == self.tail and self.tasks[self.head] == 0
+
+    # Добавьте в класс Queue метод size, который возвращает текущий размер очереди.
+    # Учтите, что необходимо рассмотреть несколько случаев: когда очередь пустая,
+    # когда очередь полная (какому условию соответствует?), а также отдельное
+    # внимание стоит обратить на тот случай, когда хвост очереди переместился
+    # в начало списка (закольцевался).
+    def size(self):
+        if self.is_empty():
+            return 0
+        elif self.head == self.tail:
+            return self.max_size
+        elif self.head > self.tail:
+            return self.max_size - self.head + self.tail
+        else:
+            return self.tail - self.head
+
+    # Добавьте в класс Queue метод add, который добавляет задачу в конец очереди.
+    # Также учтите, что размер массива ограничен и при достижении этого предела,
+    # необходимо перенести указатель в положение 0. После добавления задачи в очередь,
+    # она должна вывести уведомление об этом в формате:
+    # "Задача №1 добавлена"
+    def add(self):
+        self.task_num += 1
+        self.tasks[self.tail] = self.task_num
+        print(f"Задача №{self.tasks[self.tail]} добавлена")
+        self.tail = (self.tail + 1) % self.max_size
+
+    # Добавьте в класс Queue метод show, печатающий информацию о приоритетной
+    # задаче в формате    # "Задача №1 в приоритете"
+    def show(self):
+        print(f"Задача №{self.tasks[self.head]} в приоритете")
+
+    # Добавьте в класс Queue метод do, который печатает в консоль задачу
+    # (=выполняет её) и, соответственно, удаляет её из очереди, присваивая
+    # ей значение 0. Формат вывода: # "Задача №1 выполнена"
+    def do(self):
+        print(f"Задача №{self.tasks[self.head]} выполнена")
+        self.tasks[self.head] = 0
+        self.head = (self.head + 1) % self.max_size
+
+
+
+# Используем класс
+size = int(input("Определите размер очереди: "))
+q = Queue(size)
+
+while True:
+    cmd = input("Введите команду:")
+    if cmd == "empty":
+        if q.is_empty():
+            print("Очередь пустая")
+        else:
+            print("В очереди есть задачи")
+    elif cmd == "size":
+        print("Количество задач в очереди:", q.size())
+    elif cmd == "add":
+        if q.size() != q.max_size:
+            q.add()
+        else:
+            print("Очередь переполнена")
+    elif cmd == "show":
+        if q.is_empty():
+            print("Очередь пустая")
+        else:
+            q.show()
+    elif cmd == "do":
+        if q.is_empty():
+            print("Очередь пустая")
+        else:
+            q.do()
+    elif cmd == "exit":
+        for _ in range(q.size()):
+            q.do()
+        print("Очередь пустая. Завершение работы")
+        break
+    else:
+        print("Введена неверная команда")
+
+# Итак, первым делом реализуем проверку наличия элементов в очереди.
+#
+# Задания на самопроверку.
+#
+# Задание 4.4.6
+# Добавьте в класс Queue метод is_empty, который проверяет наличие элементов
+# в очереди, используя указатели head и tail. Запрещается использование
+# функции len(list_), так как её сложность .
+
+# Задание 4.4.7
+# Добавьте в класс Queue метод size, который возвращает текущий размер очереди.
+# Учтите, что необходимо рассмотреть несколько случаев: когда очередь пустая,
+# когда очередь полная (какому условию соответствует?), а также отдельное
+# внимание стоит обратить на тот случай, когда хвост очереди переместился
+# в начало списка (закольцевался).
+
+# Укажите номера задач, которые выполнятся при завершении работы алгоритма,
+# через запятую, соблюдая порядок выполнения. Команды очереди записываются
+# в следующем порядке:
Index: INTPY/C5_Requests_JSON_Redis_etc/C5_1_Intro.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/INTPY/C5_Requests_JSON_Redis_etc/C5_1_Intro.py b/INTPY/C5_Requests_JSON_Redis_etc/C5_1_Intro.py
new file mode 100644
--- /dev/null	(date 1662394013418)
+++ b/INTPY/C5_Requests_JSON_Redis_etc/C5_1_Intro.py	(date 1662394013418)
@@ -0,0 +1,11 @@
+#########################################################################
+# C5.1. Введение
+#########################################################################
+#
+# Итак, мы подошли к завершению изучения темы, связанной с объектно-ориентированным
+# программированием в Python. В данном модуле изучим инструменты, которые позволят
+# взаимодействовать с web-контентом, будем открывать и загружать интернет-страницы
+# через специальные модули Python, а не в привычном смысле через браузер.
+#
+# Итоговым заданием для закрепления ООП будет создание бота в мессенджере Telegram,
+# который будет выдавать вам актуальные курсы валют.
Index: INTPY/C3_modules_import_files_data/numbers.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/INTPY/C3_modules_import_files_data/numbers.txt b/INTPY/C3_modules_import_files_data/numbers.txt
new file mode 100644
--- /dev/null	(date 1661948177120)
+++ b/INTPY/C3_modules_import_files_data/numbers.txt	(date 1661948177120)
@@ -0,0 +1,10 @@
+23.65786
+1.4856
+65.763
+4.856
+1.132
+32.986
+45.743
+958.65
+153.689
+4256.6321
\ No newline at end of file
Index: INTPY/C4_Algorythms_Data_structures/naiv_sort.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/INTPY/C4_Algorythms_Data_structures/naiv_sort.py b/INTPY/C4_Algorythms_Data_structures/naiv_sort.py
new file mode 100644
--- /dev/null	(date 1662365145240)
+++ b/INTPY/C4_Algorythms_Data_structures/naiv_sort.py	(date 1662365145240)
@@ -0,0 +1,31 @@
+# Помните, в начале модуля мы говорили про алгоритмы сложности O(n!)?
+# Сейчас в первый и в последний раз мы с вами реализуем такой алгоритм.
+
+import random  # модуль, с помощью которого перемешиваем массив
+
+
+# пусть имеем массив всего лишь из 9 элементов
+array = [2, 3, 1, 7, 9, 4, 6, 5, 8]
+
+def factorial_sort(array):
+    is_sort = False  # станет True, если отсортирован
+    count = 0  # счётчик количества перестановок
+
+    while not is_sort:  # пока не отсортирован
+        count += 1  # прибавляем 1 к счётчику
+
+        random.shuffle(array)  # перемешиваем массив
+
+        # проверяем отсортирован ли
+        is_sort = True
+        for i in range(len(array) - 1):
+            if array[i] > array[i + 1]:
+                is_sort = False
+                break
+
+    print(array, "Количетво итераций: ", count)
+
+factorial_sort(array)
+# # [1, 2, 3, 4, 5, 6, 7, 8, 9]
+# print(count)
+# 290698
\ No newline at end of file
Index: INTPY/C4_Algorythms_Data_structures/LinkedList.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/INTPY/C4_Algorythms_Data_structures/LinkedList.py b/INTPY/C4_Algorythms_Data_structures/LinkedList.py
new file mode 100644
--- /dev/null	(date 1662310079752)
+++ b/INTPY/C4_Algorythms_Data_structures/LinkedList.py	(date 1662310079752)
@@ -0,0 +1,114 @@
+# Сейчас мы попробуем создать класс LinkedList, реализующий список.
+# Элементы списка будут представлять собой экземпляры класса Node.
+
+class Node:  # класс элемента
+    def __init__(self, value=None, next_=None):  # инициализируем
+        self.value = value  # значением
+        self.next = next_  # и ссылкой на следующий элемент
+
+    def __str__(self):
+        return "Node value = " + str(self.value)
+
+
+class LinkedList:  # класс списка
+    def __init__(self):  # инициализируем пустым
+        self.first = None
+        self.last = None
+
+    def clear(self):  # очищаем список
+        self.__init__()
+
+    def __str__(self):  # функция печати
+        R = ''
+
+        pointer = self.first  # берём первый указатель
+        while pointer is not None:  # пока указатель не станет None
+            R += str(pointer.value)  # добавляем значение в строку
+            pointer = pointer.next  # идём дальше по указателю
+            if pointer is not None:  # если он существует, добавляем пробел
+                R += ' '
+        return R
+
+    def pushleft(self, value):
+        if self.first is None:
+            self.first = Node(value)
+            self.last = self.first
+        else:
+            new_node = Node(value, self.first)
+            self.first = new_node
+
+    def pushright(self, value):
+        if self.first is None:
+            self.first = Node(value)
+            self.last = self.first
+        else:
+            new_node = Node(value)
+            self.last.next = new_node
+            self.last = new_node
+
+    def popleft(self):
+        if self.first is None:  # если список пустой, возвращаем None
+            return None
+        elif self.first == self.last:  # если список содержит только один элемент
+            node = self.first  # сохраняем его
+            self.__init__()  # очищаем
+            return node  # и возвращаем сохранённый элемент
+        else:
+            node = self.first  # сохраняем первый элемент
+            self.first = self.first.next  # меняем указатель на первый элемент
+            return node  # возвращаем сохранённый
+
+    def popright(self):
+        if self.first is None:  # если список пустой, возвращаем None
+            return None
+        elif self.first == self.last:  # если список содержит только один элемент
+            node = self.first  # сохраняем его
+            self.__init__()  # очищаем
+            return node  # и возвращаем сохраненный элемент
+        else:
+            node = self.last  # сохраняем последний
+            pointer = self.first  # создаём указатель
+            while pointer.next is not node:  # пока не найдём предпоследний
+                pointer = pointer.next
+            pointer.next = None  # обнуляем указатели, чтобы
+            self.last = pointer  # предпоследний стал последним
+            return node  # возвращаем сохранённый
+
+    def __iter__(self):  # объявляем класс как итератор
+        self.current = self.first  # в текущий элемент помещаем первый
+        return self  # возвращаем итератор
+
+    def __next__(self):  # метод перехода
+        if self.current is None:  # если текущий стал последним
+            raise StopIteration  # вызываем исключение
+        else:
+            node = self.current  # сохраняем текущий элемент
+            self.current = self.current.next  # совершаем переход
+            return node  # и возвращаем сохранённый
+
+    def __len__(self):
+        count = 0
+        pointer = self.first
+        while pointer is not None:
+            count += 1
+            pointer = pointer.next
+        return count
+
+
+
+# Задание 4.6.3
+# Как будет выглядеть список после выполнения последовательности операций?
+
+if __name__ == '__main__':
+    LL = LinkedList()
+
+    LL.pushright(1)
+    LL.pushleft(2)
+    LL.pushright(3)
+    LL.popright()
+    LL.pushleft(4)
+    LL.pushright(5)
+    LL.popleft()
+
+    print(LL)
+    print(len(LL))
\ No newline at end of file
Index: INTPY/B2_Data_types/bkank000.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/INTPY/B2_Data_types/bkank000.py b/INTPY/B2_Data_types/bkank000.py
new file mode 100644
--- /dev/null	(date 1662881549756)
+++ b/INTPY/B2_Data_types/bkank000.py	(date 1662881549756)
@@ -0,0 +1,7 @@
+text_ = "Москва о сколько в этом звуке для сердца русского слилось"
+values = text_.split(' ')
+# вот такой интересный способ множественного присваивания значений отдельным переменным из списка
+a, b, c, d, e, f, g, h, i, j = values
+print(d, a, g, j, i)
+print(b, e, f, c, h)
+print(sorted(values))
Index: INTPY/C4_Algorythms_Data_structures/merge_sort.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/INTPY/C4_Algorythms_Data_structures/merge_sort.py b/INTPY/C4_Algorythms_Data_structures/merge_sort.py
new file mode 100644
--- /dev/null	(date 1662386745995)
+++ b/INTPY/C4_Algorythms_Data_structures/merge_sort.py	(date 1662386745995)
@@ -0,0 +1,37 @@
+# Сортировка слиянием
+
+
+def merge_sort(L):  # «разделяй»
+    if len(L) < 2:  # если кусок массива равен 2,
+        return L[:]  # выходим из рекурсии
+    else:
+        middle = len(L) // 2  # ищем середину
+        left = merge_sort(L[:middle])  # рекурсивно делим левую часть
+        right = merge_sort(L[middle:])  # и правую
+        return merge(left, right)  # выполняем слияние
+
+
+def merge(left, right):  # «властвуй»
+    result = []  # результирующий массив
+    i ,j = 0 ,0  # указатели на элементы
+
+    # пока указатели не вышли за границы
+    while i < len(left) and j < len(right):
+        if left[i] < right[j]:
+            result.append(left[i])
+            i += 1
+        else:
+            result.append(right[j])
+            j += 1
+
+    # добавляем хвосты
+    while i < len(left):
+        result.append(left[i])
+        i += 1
+
+    while j < len(right):
+        result.append(right[j])
+        j += 1
+
+    return result
+
Index: INTPY/C4_Algorythms_Data_structures/quick_sort.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/INTPY/C4_Algorythms_Data_structures/quick_sort.py b/INTPY/C4_Algorythms_Data_structures/quick_sort.py
new file mode 100644
--- /dev/null	(date 1662387692112)
+++ b/INTPY/C4_Algorythms_Data_structures/quick_sort.py	(date 1662387692112)
@@ -0,0 +1,48 @@
+
+# Быстрая сортировка
+
+import random
+
+def qsort(array, left, right):
+    middle = (left + right) // 2
+
+    p = array[middle]
+    i, j = left, right
+    while i <= j:
+        while array[i] < p:
+            i += 1
+        while array[j] > p:
+            j -= 1
+        if i <= j:
+            array[i], array[j] = array[j], array[i]
+            i += 1
+            j -= 1
+
+    if j > left:
+        qsort(array, left, j)
+    if right > i:
+        qsort(array, i, right)
+
+# -----------------------------------------------------------
+# быстрая сортировка с рандомным ведущим элементом
+
+def qsort_random(array, left, right):
+    p = random.choice(array[left:right + 1])
+    i, j = left, right
+    count = 0
+    while i <= j:
+        while array[i] < p:
+            i += 1
+        while array[j] > p:
+            j -= 1
+        if i <= j:
+            count += 1
+            array[i], array[j] = array[j], array[i]
+            i += 1
+            j -= 1
+
+    if j > left:
+        qsort_random(array, left, j)
+    if right > i:
+        qsort_random(array, i, right)
+
Index: INTPY/C4_Algorythms_Data_structures/choose_sort.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/INTPY/C4_Algorythms_Data_structures/choose_sort.py b/INTPY/C4_Algorythms_Data_structures/choose_sort.py
new file mode 100644
--- /dev/null	(date 1662365703397)
+++ b/INTPY/C4_Algorythms_Data_structures/choose_sort.py	(date 1662365703397)
@@ -0,0 +1,31 @@
+# Сортировка выбором
+
+array = [2, 3, 1, 4, 6, 5, 9, 8, 7] # выше он уже есть, повторять не обязательно
+
+def choose_sort(array):
+    for i in range(len(array)):  # проходим по всему массиву
+        idx_min = i  # сохраняем индекс предположительно минимального элемента
+        for j in range(i + 1, len(array)):
+            if array[j] < array[idx_min]:
+                idx_min = j
+        if i != idx_min:  # если индекс не совпадает с минимальным, меняем
+            array[i], array[idx_min] = array[idx_min], array[i]
+
+    print("Сортировка по возрастанию: ", array)
+
+def choose_sort_desc(array):
+    for i in range(len(array)):  # проходим по всему массиву
+        count = 0
+        idx_max = i  # сохраняем индекс предположительно максимального элемента
+        for j in range(i + 1, len(array)):
+            if array[j] > array[idx_max]:
+                idx_max = j
+                count += 1
+        if i != idx_max:  # если индекс не совпадает с минимальным, меняем
+            array[i], array[idx_max] = array[idx_max], array[i]
+
+    print("Сортировка по убыванию: ", array)
+
+if __name__ == '__main__':
+    choose_sort(array)
+    choose_sort_desc(array)
\ No newline at end of file
Index: INTPY/C4_Algorythms_Data_structures/bubble_sort.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/INTPY/C4_Algorythms_Data_structures/bubble_sort.py b/INTPY/C4_Algorythms_Data_structures/bubble_sort.py
new file mode 100644
--- /dev/null	(date 1662365744623)
+++ b/INTPY/C4_Algorythms_Data_structures/bubble_sort.py	(date 1662365744623)
@@ -0,0 +1,12 @@
+array = [2, 3, 1, 4, 6, 5, 9, 8, 7]
+
+def bubble_sort(array):
+    for i in range(len(array)):
+        for j in range(len(array) - i - 1):
+            if array[j] > array[j + 1]:
+                array[j], array[j + 1] = array[j + 1], array[j]
+
+    print("Сортировка пузырьком: ", array)
+
+if __name__ == '__main__':
+    bubble_sort(array)
\ No newline at end of file
Index: INTPY/C4_Algorythms_Data_structures/binary_tree.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/INTPY/C4_Algorythms_Data_structures/binary_tree.py b/INTPY/C4_Algorythms_Data_structures/binary_tree.py
new file mode 100644
--- /dev/null	(date 1662298809807)
+++ b/INTPY/C4_Algorythms_Data_structures/binary_tree.py	(date 1662298809807)
@@ -0,0 +1,67 @@
+#
+
+class BinaryTree:
+    def __init__(self, value):
+        self.value = value
+        self.left_child = None
+        self.right_child = None
+
+    def insert_left(self, next_value):
+        if self.left_child is None:
+            self.left_child = BinaryTree(next_value)
+        else:
+            new_child = BinaryTree(next_value)
+            new_child.left_child = self.left_child
+            self.left_child = new_child
+        return self
+
+    def insert_right(self, next_value):
+        if self.right_child is None:
+            self.right_child = BinaryTree(next_value)
+        else:
+            new_child = BinaryTree(next_value)
+            new_child.right_child = self.right_child
+            self.right_child = new_child
+        return self
+
+    def pre_order(self):
+        print(self.value, end=' ')   # обработка запроса
+        if self.left_child is not None:
+            self.left_child.pre_order()
+        if self.right_child is not None:
+            self.right_child.pre_order()
+
+    def post_order(self):
+        if self.left_child is not None:
+            self.left_child.post_order()
+        if self.right_child is not None:
+            self.right_child.post_order()
+        print(self.value, end=' ')   # обработка запроса
+
+    def in_order(self):
+        if self.left_child is not None:
+            self.left_child.in_order()
+
+        print(self.value, end=' ') # обработка
+
+        if self.right_child is not None:
+            self.right_child.in_order()
+
+
+# Задание 4.5.5
+# Реализуйте структуру дерева при помощи класса BinaryTree. (рис.)
+
+node_root = BinaryTree(2).insert_left(7).insert_right(5)
+node_7 = node_root.left_child.insert_left(2).insert_right(6)
+node_6 = node_7.right_child.insert_left(5).insert_right(11)
+node_5 = node_root.right_child.insert_right(9)
+node_9 = node_5.right_child.insert_left(4)
+
+# Обход дерева
+# ( см. метод pre_order класса BinaryTree )
+
+node_root.pre_order()
+print()
+node_root.post_order()
+print()
+node_root.in_order()
\ No newline at end of file
Index: INTPY/C4_Algorythms_Data_structures/par_checker.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/INTPY/C4_Algorythms_Data_structures/par_checker.py b/INTPY/C4_Algorythms_Data_structures/par_checker.py
new file mode 100644
--- /dev/null	(date 1662129060897)
+++ b/INTPY/C4_Algorythms_Data_structures/par_checker.py	(date 1662129060897)
@@ -0,0 +1,24 @@
+# функция проверки правильности расстановки пар скобок
+
+def par_checker(string):
+    stack =[]
+
+    for s in string:
+        if s == "(":
+            stack.append(s)
+        elif s == ")":
+            if len(stack) > 0 and stack[-1] == "(":
+                stack.pop()
+            else:
+                return False
+
+    return len(stack) == 0
+
+if __name__ == '__main__':
+    a = "Мы (тоже (когда-то)) (были) молодыми ((и для) (нас) пели (соловьи))"
+    print("Все скобки закрыты: ",par_checker(a))
+    print()
+    s = (5 + 6) * (7 + 8) / (4 + 3)
+    # print("Все скобки закрыты: ",par_checker((5 + 6) * (7 + 8) / (4 + 3)))
+    print(s)
+
Index: INTPY/C4_Algorythms_Data_structures/insert_sort.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/INTPY/C4_Algorythms_Data_structures/insert_sort.py b/INTPY/C4_Algorythms_Data_structures/insert_sort.py
new file mode 100644
--- /dev/null	(date 1662367226912)
+++ b/INTPY/C4_Algorythms_Data_structures/insert_sort.py	(date 1662367226912)
@@ -0,0 +1,23 @@
+
+# Сортировка вставками
+
+array = [2, 3, 1, 4, 6, 5, 9, 8, 7]
+
+def insert_sort(array):
+    count = 0
+    for i in range(1, len(array)):
+        x = array[i]
+        idx = i
+        while idx > 0 and array[idx - 1] > x:
+            array[idx] = array[idx - 1]
+            idx -= 1
+            count += 2
+        array[idx] = x
+
+    print("Сортировка вставками: ", array, count)
+
+if __name__ == '__main__':
+    insert_sort(array)
+
+
+
diff --git a/INTPY/C3_modules_import_files_data/test347.py b/INTPY/C3_modules_import_files_data/test347.py
new file mode 100644
